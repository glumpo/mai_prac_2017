\sectiontop
%\lhead{426}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}
\hspace{-14pt}ным действиям на интервалах $[0,n_i[$. Зато другие операции --- напри- 
\linebreak мер, сравнение элементов --- менее очевидны. Эта проблема осложняет- \linebreak ся еще тем, что в общем, когда используем модулярную арифметику,\linebreak  стоит избегать вычислений с «обычными» числами, ибо переход от од- \linebreak ной системы к другой не является пренебрегаемым.\par
Проблема определения конкретных цифр в числе, полученном при \linebreak
модулярных вычислениях, используя лишь его модулярные составляющие (т.е. не восстанавливая настоящее число), также весьма не тривиальна. Займемся теперь различными проблемами такого типа.\par
Оригинальная идея, принадлежащая Гарнеру (1958) и представлен-\linebreak ная у Кнута [99], состоит в том, чтобы связать с модулярным пред-\linebreak ставлением еще одно представление, называемое смешанной системой счисления. \\ 
\vspace{0.3mm}

\textbf{(10) Определение.}
\vspace{2mm}
\par
Основанием смешанной системы счисления называется множество \linebreak
из $r\geq2$ целых чисел $n_1, n_2,\ldots, n_r$, не обязательно взаимно простых.\linebreak
Если положим $N_i = \prod_{j<i}n_j$ и $n=n_1 n_2\ldots n_r$, то имеется биекция
$$[О, ni[\times \cdots \times [0, n_r[\rightarrow[О, n[, (z_i,\ldots, z_r)\rightarrow x = \sum\limits^{r}_{i=1}z_iN_i.$$
Обратное отображение определяется при помощи евклидовых делений:
$$x = q_1n_1 + z_1,\quad q_1 = q_2n_2 + z_2,\quad \ldots,\quad q_{r-1} = q_rn_r + z_r.$$
В случае, когда все числа n, равны, получаем обычную позиционную
систему счисления (смешанная система счисления, следовательно, это
система, в которой основание варьируется). 
\vspace{3mm}
\par
Прежде чем изучать переход от модулярного представления к 
представлению в смешанной системе счисления, продемонстрируем два 
основных метода изменения основания позиционной системы. 
Предположим, что мы работаем с целыми числами и с основанием 6, а хотим \linebreak
представить их в системе с основанием В. Подобные замены основания
часто возникают, например, при операциях ввода-вывода целых чисел \linebreak
на компьютере: для человека более удобной является система 
счисле-\linebreak ния с основанием 10, в то время как сама машина работает с 
осно-\linebreak ванием 2. В обоих представленных методах мы рассматриваем целое\linebreak число $u$, записанное в двух формах $\sum u_{i}b^{i}$ или $\sum U_{i}B^{i}$ в зависимости \linebreak
от соответствующего основания $b$ или $B$.

\newpage

%\lhead{\small\textit{IV-2.2 Модулярная арифметика и смешанная система счисления}}
%\rhead{427}
\textbf{Изменение основания при помощи умножения}
\par
 Предположим, что мы располагаем позиционной арифметикой с 
основанием $b$, к которому и хотим перейти. Это, например, все тот же
случай, когда работают вручную и $b = 10^n$. Перевод числа $(U_{r},\ldots,U_{0})_{B}$ тогда осуществляется как поиск значения многочлена $\sum U_{i}X^{i}$ в точке$B$. В процессе перевода вычисляем схему Горнера для данного 
многочлена. Вычисления будут значительно проще, если $B < b$, так как
в этом случае значения операндов во всех осуществляемых действиях
меньше чем $b$.\par
Например, приведем число $х = (31415)_9$ к основанию 10:
$$x = (((3 \times 9+1)\times9 + 4)\times9+1)\times9 + 5 = 20750.$$
Предположим, что у нас на машине реализована арифметика с 
основанием $2^{16}$ (умножение чисел, меньших $2^{16}$, имеется на всех современных машинах). Тогда в программе, которая читает большие числа, переход от представления пользователя (в десятичной системе) к внутреннему представлению (в двоичной) может быть осуществлен при помощи этого метода с $B = 10^{4}$ и $b = 2^{16}$. \\

\textbf{Изменение основания при помощи деления} \par
Этот дуальный к предыдущему методу способ реализуется 
посредством последовательного деления. Чтобы перевести число $x$ из
представления с основанием $B$ в представление с основанием $b$, 
разделим $x$ на $b$. Остаток от этого деления дает цифру наименьшего веса для
$x$ в основании $b$, затем повторяем то же самое для частного. Процесс
останавливается, когда очередное частное равно нулю. Метод 
предполагает умение делить числа, представленные в основании $B$, поэтому предпочтительнее его использовать при $b < B$.\par
Например, переведем число $x = (31415)_{10}$ в число по основанию 7.
Для этого разделим $x$ на 7 и получим остаток 6 и частное 4487, 
потом получим остаток 0 и частное 641, затем остаток 4 и частное 91
и т.д. В итоге, читая полученные остатки в обратном порядке, 
находим $(160406)_{7}$.\par
Если теперь у нас имеется арифметика с основанием $2^16$, а мы 
хотим получить результаты вычислений в системе с основанием 10, то
удобно использовать этот метод, положив $B = 2^{16}$ и $b = 10^{4}$. Заметим,
что можно было использовать первый метод с $B = 2^{8}$ и $b=10^{3}$, если
предположить, что сложение и умножение с основанием $10^{3}$ 
запрограммировано (что не так сложно). %черный квадрат справа

\pagebreak
\newpage

%\lhead{428}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}
Вернемся теперь к системам со смешанным основанием. Научимся
сначала находить цифры в системе со смешанным основанием, исходя
из модулярных компонент.\\
\textbf{(11) Формулы определения цифр} (из модулярных компонент).\par
 Пусть $n_1,n_2,\ldots, n_r$ — попарно взаимно простые числа. Пусть
$N = \prod_{j<i} n_{j}$ и $C$» — обратные к $N_{i}$,- по модулю $n_{i}$. Рассмотрим целое число $х$ модулярные компоненты которого $х_{1},х_{2},\ldots, x_{r}$ тогда цифры $x$ в системе со смешанным основанием $n_{i}$ обозначим через $z_i$; они находятся по формулам:
\begin{flushleft}
\hspace{72pt}$z_{1} = x_{1} mod\ n_1,$ \\
\hspace{72pt}$z_{2} = C_{2}(x_{2} - z_{1}) mod\ n_{2}$ \\
\hspace{72pt}$z_{3} = C_{3}(x_{3} - (N_{2}z_{2} + z_{1}))mod\ n_{3}$ \\
\hspace{85pt}\vdots  \\
\hspace{72pt}$z_{r} = C_{r}(x_{r} - (N_{r-1}z_{r-1}+\cdots+N_{2}z_{2}+z_{1}))mod\ n_{1}.$
\end{flushleft}
\begin{myproof}
Рассмотрим формулы (1), полученные в китайской теореме об остатках:
\begin{flushleft}
\hspace{72pt}$y_{1} = x_{1}\ mod\ n_{1},$  \\
\hspace{72pt}$y_{2} = N_{2}(C_{2}(x_{2}-y_{1})\ mod\ n_{2})+ y_{1},$  \\
\hspace{85pt}\vdots \\
\hspace{72pt}$y_{r} = N_{r}(C_{r}(x_{r}-y_{r-1})\ mod\ n_{r})+y_{r-1}$ \\
\end{flushleft}
и положим $z_{1} = y_{1}, z_{2} = C_{2}(x_{2} - y_{1})\ mod\ n_{2},\ \ldots, z_r = C_{r}(x_{r}\ -\linebreak y_{r-1})\ mod\ n_{r} $.Тогда $0 \leq z_{i} < n_{i}$ и $x =\sum z_{i}N_{i}$. Теперь исключим числа $y_{i}$ используемые в этих формулах, и найдем соотношения\linebreak
для определения $z_{i}$.
\end{myproof}
Все это реализовано в алгоритме 3 (слева). \par
Чтобы осуществить обратный переход от системы со смешанным
основанием к модулярному представлению, достаточно провести 
следующие вычисления:
\begin{flushleft}
\hspace{2cm}$x_{1} = z_{1},$ \\ 
\hspace{2cm}$x_{2} = z_{1} + z_{2}n_{1}\ mod\ n_{2},$ \\ 
\hspace{2cm}$x_{3} = z_{1} + z_{2}n_{1} + z_{3}n_{1}n_{2}\ mod\ n_{3},$ \\ 
\hspace{2.5cm} \vdots  \\
\hspace{2cm}$x_{r} = z_{1} + z_{2}n_{1} + \cdots + z_{r}n_{1} \vdots n_{r-1}.$
\end{flushleft}
\pagebreak
\newpage
%\lhead{\small\textit{IV-2.2 Модулярная арифметика и смешанная система счисления}}
%\rhead{429}

Алгоритм 3 проводит эти вычисления по аналогии с предыдущим,
используя схему Горнера.
\begin{table}[h]
\centering
\begin{tabular}{ll}
\hline
\multicolumn{2}{|c|}{$n_{1}, n_{2}, \ldots, n_{r},$ попарно взаимно просты,}\\
\multicolumn{2}{|c|}{$N_{i} = \prod_{j < i} n_{j}$ и $C_{i}N_{i}\equiv 1\ (mod \ n_{i})$}                           \\
\multicolumn{2}{|c|}{$x = \sum_{i = 1}^{r} z_{i}N_{i}$ и $x \equiv x_{i}\ (modn_{i})$, где $0 \leq z_{i}, x_{i} < n_{i}.$}                           \\ 
\multicolumn{1}{|l|}{$\underline{(x_{1},\ldots,x_{r})\rightarrow (z_{1},\ldots, z_{r})}$} & \multicolumn{1}{l|}{$\underline{(z_{1},\ldots, z_{r}) \rightarrow (x_{1}, \ldots , x_{r})}$ } \\ 
\multicolumn{1}{|l|}{z[0] = x[0];} & \multicolumn{1}{l|}{x[0] = z[0]; } \\ 
\multicolumn{1}{|l|}{\textbf{for (int i = 1; i < r; ++i) \{} } & \multicolumn{1}{l|}{\textbf{for (int i = 1; i < r; ++i) \{}} \\ 
\multicolumn{1}{|l|}{\qquad s = z[i-1];} & \multicolumn{1}{l|}{\qquad s = z[i];} \\ 
\multicolumn{1}{|l|}{\qquad \textbf{for (int j = 0; j < i; j++) \{}} & \multicolumn{1}{l|}{\qquad \textbf{for (int j = 0; j < i; j++) \{}} \\ 
\multicolumn{1}{|l|}{\qquad \qquad s = (s * n[j] + z[j]) \% n[i]; } & \multicolumn{1}{l|}{\qquad \qquad s = (s * n[j] + z[j]) \% n[i];} \\ 
\multicolumn{1}{|l|}{\qquad \textbf{\}}} & \multicolumn{1}{l|}{\qquad \textbf{\}}} \\ 
\multicolumn{1}{|l|}{\qquad z[i] = (1 / n[i]) * (x[i] - s) \% n[i];} & \multicolumn{1}{l|}{\qquad x[i] = s; } \\ 
\multicolumn{1}{|l|}{\colorbox{gray}{$s = N_{i-1}z_{i-1}+\cdots+N_1z_1\ (mod\ n_i$}} & \multicolumn{1}{|l|}{\colorbox{gray}{$s = (\cdots(z_in_{i-1} + z_{i-1})n_{i-2} + )$}} \\ 
\multicolumn{1}{|l|}{\ } & \multicolumn{1}{|l|}{\colorbox{gray}{$\cdots)n_1+z_1\ (mod\ n_i$}} \\
\multicolumn{1}{|l|}{\textbf{\}}} & \multicolumn{1}{l|}{\textbf{\}}} \\
\multicolumn{1}{|l}{\ } & \multicolumn{1}{l|}{\ } \\
\hline
\end{tabular}
\end{table}
\begin{center}
\textbf{Алгоритм 3.} Переход от модулярного представления к смешанной
системе счисления
\end{center}

Рассмотрим теперь применение системы со смешанным основанием
к некоторым проблемам, сформулированным в начале раздела. \\
\textbf{Сравнение двух целых чисел} \par
 Предположим, что у нас имеются два целых числа $x$ и $x'$, 
заданные своими модулярными компонентами, и мы хотим узнать, которое
из этих чисел (можем считать, что они оба лежат в интервале $[0, m[$)
больше, по возможности не вычисляя явный вид этих чисел. Вычислим
сначала цифры $(z_{i})$ и $(z_{i}')$, соответствующие $x$ и $x'$в смешанной системе счисления, определяемой модулями. В этом случае $x < x'$ тогда и 
только тогда, когда наибольший вес $i$, на котором различаются эти числа,
таков, что $z_{i} < z_{i}'$. \\
\textbf{Определение цифр в позиционной системе счисления} \par
 Пусть целое число $x$ задано своими модулярными компонентами и
мы хотим вычислить его цифры в системе с основанием $b$, взаимно
простым со всеми модулями. Вычислим сначала цифры числа $x$ в 
системе со смешанным основанием и обозначим их, как обычно, $z_{1},\ldots,z_{r}$. В этих обозначениях число $x$ запишется как $\sum z_{i}N_{i}$, что позволяет вычислить $x\ mod\ b$, используя схему Горнера.
$$x\ mod\ b = (\ldots((z_{r}\ mod\ b)* n_{r-1} +z_{r-1}\ mod\ b)\ldots)*n_{1}+ z_{1}\ mod\ b $$
\pagebreak
\newpage
%\lhead{430}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}
Таким образом, мы получили первую цифру $x$ в системе счисления с
основанием $b$. Чтобы повторить эту процедуру, нужно вычислить 
модулярные компоненты числа $(x - (x\ mod\ b))/b$ при помощи 
модулярного вычитания (которое совпадает с обычным вычитанием, ибо $x mod b$
меньше или равно $x$) и модулярного деления (которое возможно, так
как $b$ обратимо по всем модулям $n_{i}$).\par
Рассмотрим, например, три простых числа $n_{1} = 1009, n_{2} = 2039,
n_{3} = 907$. Пусть $x$ — число из интервала $[0, 1 866 017 357[$ и его остатки по модулям $n_{1}, n_{2}$ и $n_{3}$ равны $x_{1}$ = 23, $x_{2}$ = 41 и $x_{3}$ = 35. Вычислим сначала цифры $x$ в системе со смешанным основанием: 23, 1746, 144.Чтобы вычислить последнюю цифру $x$ в системе с основанием 10, 
проведем соответствующие вычисления по модулю 10 и получим:
$$x_{0}\equiv((23 \times 1009 + 1746) \times 2039 + 144 = (3 \times 9 + 6) \times 9 + 4 \equiv 1 (mod\ 10).)$$
Зная обратные к 10 по модулям $n_{i}$ а это 101, 204 и 635, вычисляем
модулярные компоненты числа $x' = (x - x_{0})/10$ :
\begin{equation*}
\begin{split}
x' = ((23 - 1) \times 101 mod 1009, (41 - 1) \times 204 mod 2039, \\
(35 - 1) \times 635 mod 907) = (204, 7, 729),
\end{split}
\end{equation*}
которым соответствуют цифры смешанного представления $x'$:
204, 990,14\ldots В итоге мы восстановим все цифры числа $x = 298\ 020\ 281$,
не вычисляя само $x$ (самые большие числа, использованные нами, не
превосходят 2039).\\
\sectiontop
\subsection{Умножение целых чисел методом Полларда}
В настоящее время этот метод является самым быстрым и позволяет
перемножать два числа длины $n$ за $\mathcal{O}(n\log{}n)$ элементарных 
умножений, а не за $\mathcal{O}(n^{2})$, как обычный метод. Важно отметить, что это не асимптотический метод, т.е. пригодный для умножения чисел любой
длины, напротив, он ограничивает размер чисел. Правда, на 
практике эта граница ни на что не влияет, так как метод Полларда 
позволяет умножать числа, имеющие около 1 миллиарда десятичных цифр!
Существуют и другие, асимптотически быстрые методы умножения;
такие, как метод Шёнхаге — Штрассена [162], который имеет 
сложность $\mathcal{O}(n\log{}n\log{}\log{}n)$, или упрощенная версия Карпа [29] со сложностью $\mathcal{O}(n\log{}^{2}n)$. Однако, в диапазоне применения метода Полларда они хуже последнего, а первый метод настолько сложен, что, возможно, никогда не будет реализован.
\pagebreak
\newpage
%\lhead{\textit{IV-2.3 Умножение целых чисел методом Лолларда}}
%\rhead{431}
Метод Полларда основан на применении алгоритма вычисления 
быстрого преобразования Фурье, которое будет изучено в главе V. 
Основной результат этой главы, с которым мы сейчас будем работать, 
выглядит следующим образом: \\
\textbf{(12) Теорема} (быстрое преобразование Фурье).\\
Существует метод интерполяции на п специально выбранных 
точках, который работает с многочленами, степени строго меньшей п, я
требует $\mathcal{O}(n\log{}n)$ умножений коэффициентов (вместо $n^{2}$, обычно необходимых).\par
Эти методы позволяют быстро умножать по модулю $X^{n} - 1$ 
многочлены степени, строго меньшей n, за$\mathcal{O}(n\log{}n)$ элементарных 
умножений.\par
 Метод Полларда заключается в следующем: пусть $u$ и $v$ два 
перемножаемых числа, записанных в системе с основанием $b$: $u = \sum_{i<n}u_{i}b^{i}$, $v = \sum_{i < n}v_{i}b^{i}$($u$ и $v$ длины $\leq n$). Эти два числа могут быть рассмотрены как значения в точке $b$ многочленов $U = \sum u_{i}X^{i}$ и $V = \sum v_{i}X^{i}$.
\begin{itemize}
\item Начнем с умножения многочленов $U$ и $V$. Эта операция, 
используя быстрое преобразование Фурье, требует $\mathcal{O}(n\log{}n)$  умножений цифр.
\item Обсудим теперь переносы: коэффициенты произведения 
многочленов, полученного на предыдущем этапе, в действительности
могут быть больше основания выбранной системы и проблема не
в том, чтобы вычислить значение произведения в точке $b$, а в том,
чтобы управлять недоступными вычислениями.
\end{itemize}

Как мы видим, метод Полларда разбивается на два различных этапа: вычисление произведения многочленов и переносы цифр в уме. Мы изучим оба эти этапа по отдельности. Начнем с простой операции переноса цифр. \\
\textbf{(13) Предложение} (перенос цифр в уме).\par
  Пусть $u = \sum_{i<n}u_{i}b^{i}$ и $v = \sum_{i < n}v_{i}b^{i}$ --- Два перемножаемых числа, a $U$ и $V$ — многочлены с целыми положительными коэффициентами, соответствующими этим числам. Пусть $W =\sum_{i<2n-1} \alpha_{i}X^{i}$--- произведение $U$ и $V$.\par
 ($i$) Тогда $w = uv = W(b)$ и цифры $w_{i}$ числа $w$ могут быть получены
по следующим рекуррентным формулам: 
\begin{center}
$w_{i} = \beta_{i}mod\ b, $ \quad где\quad $\beta_{i+1} = \alpha_{i+1} + fraq{\beta_{i}-w_{i}}{b}$\enskip и\enskip $\beta_0 = \alpha_{0}$\quad (2)
\end{center}
\pagebreak
\newpage

%\lhead{432}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}

($ii$)Если константа М не меньше всех $\alpha_{i}$, то все числа $\beta_{i}$,

\begin{myproof}
($i$)Покажем, что $\alpha_0 + \alpha_{1}b + \cdots + \alpha_{i}b^{i} = w_{0} + w_{1}b + \cdots + w_{i-1}b^{i-1}+ \beta_{i}b^{i}$
для всех $i$ (положим $\alpha_{i} = 0$, если $ i \geq 2n — 1$). Если мы к тому же докажем, что $\beta_{i} = 0$ для $i \geq 2n$, то это и будет означать, что $w_{i}$--- цифры $w$. Из (2) получаем $\beta_{i+1}b^{i+1} + w_{i}b^{i} = \alpha_{i+1}b^{i+1} + \beta_{i}b^{i}$,откуда и следует предыдущая формула (при $i = 0$ она проверяется непосредственно). \\ 
Коэффициенты $\alpha_{i}$ равны нулю при $i > 2n - 2$ и, следовательно,
$\beta_{i} \leq \beta_{i-1}/b$для всякого $i > 2n — 2$, это доказывает, что, начиная с некоторого $i_{0}$, коэффициенты $\beta_{i}$, нулевые. Равенство $W(b) =\sum w_{i}b^{i}$ доказывает, что это выполнено при $i_0$, меньшем или равном $2n$. \\
($ii$) Найдем константу $М'$, которая мажорирует все $\beta_{i}$. По 
формуле (2) $\beta_{i+1} \leq M + M'/b$ и, следовательно, если существует $М'$,удовлетворяющая неравенству $M + M'/b \leq M'$, то она 
удовлетворяет и нашим требованиям. Нетрудно проверить, что $Mb/(b-1)$ удовлетворяет последнему неравенству. Кроме того, оно больше $\beta_{0}$(так как $\beta_{0}$ это цифра в системе с основанием $b$). 
\end{myproof}

На этом этапе обсуждения можно было бы подумать, что все 
закончено и все, что можно было сказать о методе Полларда, сказано. Ничего
подобного! Какова в действительности граница величины 
перемножаемых целых чисел? Чтобы ответить на этот вопрос, нужно перейти к
изучению главы V и подробнее рассмотреть условия применения 
алгоритма FFT. \par
 Для применения FFT к многочленам степени $< n$ необходимо, чтобы
$n$ было достаточно составным (например, степенью 2), а также 
перейти в поле $\mathbb{Z}_p$, в котором существует примитивный корень $n$-й степени из 1. Последнее условие выполняется, например, при $p \equiv 1 (mod n)$. Но (какой ужас!), если работать по модулю $p$, то коэффициенты 
произведения многочленов, вычисленные с помощью FFT, более не являются
точными, а лишь сравнимы с настоящими коэффициентами. Если мы
хотим получить точный результат, то $p$ должно мажорировать 
коэффициенты произведения. \\
\textbf{(14) Предложение} (Поллард). \\ 
\par
Пусть $n$ — достаточно сильно составное число (например, степень 2
или 3) и $p$ — простое число, удовлетворяющее условию $p \equiv 1 (mod n)$. 
\pagebreak
\newpage

%\lhead{\textit{IV-2.3 Умножение целых чисел методом Лолларда}}
%\rhead{433}
Пусть $u$ и $v$ — два целых числа такие, что
$$u = \sum\limits^{k-1}_{i = 0}u_{i}b^{i},\quad v = \sum\limits^{l-1}_{i = 0}v_{i}b^{i},\quad 2sup(k,l) \leq n, (b - 1)^{2}inf(k, l) < p$$
Тогда можно перемножить $u$ и $v$ при помощи алгоритма Поллардау 
используя быстрое преобразование Фурье в поле $\mathbb{Z}_p$. Сложность 
вычислений --- $\mathcal{O}(n\log{}n)$  умножений в $\mathbb{Z}_p$.\par
Очевидно, что сложность именно такая: именно столько операций
требует алгоритм умножения многочленов при помощи Fft, а 
переносы в уме имеют линейную сложность относительно величины 
результата действия алгоритма. Что касается неравенства, которому 
удовлетворяет $p$, то оно просто означает, что коэффициенты произведения
многочленов меньше $p$. 

\begin{table}[h]
\centering
\small
\begin{tabular}{|l l l l|}
\hline
$40961 = 5\times2^{13} + 1$ & & & \multicolumn{1}{c|}{\ }\\ 
\multicolumn{4}{|c|}{} \\
\hline
$122289 = 3 \times 2^{12} + 1$ & $61441 = 15 \times 2^{12} + 1$ & & \multicolumn{1}{c|}{\ }\\
\multicolumn{4}{|c|}{} \\
\hline
$18433=9\times2^{11} + 1$ & $59393=29\times2^{11} + 1$  & & \multicolumn{1}{c|}{\ }\\
\multicolumn{4}{|c|}{} \\
\hline
$13313=13\times 2^{10}+1$ & $15361=15\times 2^{10}+1$ & $19457=19\times2^{10}+1$ & $25601=25\times2^{10}+1$ \\
$37889=37\times2^{10}+1$ & $39937=39\times2^{10}+1$ & $50177=49\times 2^{10}+1$ & $58369=57\times2^{10}+1$ \\ 
$64513=63\times2^{10}+1$ & & & \multicolumn{1}{c|}{\ } \\
\multicolumn{4}{|c|}{} \\
\hline

$7681=15\times2^9+1$ & $10753=21\times2^9+1$ & $11777=23\times2^9 + 1$ & $17921=35\times2^9 + 1$  \\
$23041=45\times2^9+1$ & $26113=51\times 2^9 + 1$ & $32257=63\times 2^9 + 1$ & $36353=71 \times 2^9 + 1$ \\ 
$45569=89 \times 2^9+1$ & $51713=101\times 2^9+1$ & & \multicolumn{1}{c|}{\ } \\
\multicolumn{4}{|c|}{} \\
\hline
$257=1 \times 2^8 + 1$ & $769=З\times2^8 + 1$ & $3329=13\times2^8 + 1$ & $7937=31\times2^8 + 1$  \\
$9473=37\times2^8+1$ & $14081=55\times2^8 + 1$ & $14593=57\times2^8 + 1$ & $16129=63\times2^8 + 1$ \\
$22273=87\times2^8+1$ & $23297=91\times2^8 + 1$ & $26881=105\times2^8+1$ & $30977=121\times2^8+1$ \\
$31489=123\times2^8+1$ & $36097=141\times2^8+1$ & $37633=147\times2^8+1$ & $40193=157\times2^8+1$ \\
$41729=163\times2^8+1$ & $43777=171\times2^8+1$ & $46337=181\times2^8+1$ & $49409=193\times2^8+1$  \\
$49921=195\times2^8+1$ & $57089=223\times2^8+1$ & $57601=225\times2^8+1$ & $60161=235\times2^8+1$  \\
\hline
\end{tabular}
\end{table}
\begin{flushleft}
\vspace{-18pt}
\textbf{Таблица 2.}Простые числа < $2^{16}$ и представимые в виде $p - 1 = q^{2^{k}}$
\end{flushleft}
\par
Рассмотрим более подробно, насколько большие целые числа можно\linebreak
умножать при помощи этого алгоритма. Для этого необходимо \linebreak
уточнить характеристики целых чисел, используемых в алгоритме, и \linebreak
подробнее остановиться на его конкретной реализации. Как уже \linebreak
упоминалось, умножение многочленов, использующее быстрое \linebreak
преобразование Фурье, наиболее просто реализуется в $\mathbb{Z}_p$ и при условии, что $p = q^{2k+1}$с нечетным $q$. При этом можно точно перемножать (в этом\linebreak 
\begin{flushleft}
\tiny
28-1017
\end{flushleft}
\pagebreak
\newpage

%\lhead{434}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}

\hspace{-14pt}поле) многочлены длины $k$. Выше сказанное как раз и составляет 
формальную характеристику алгоритма Полларда.\par
  Перейдем теперь к практическим соображениям. Вычисления 
должны производиться по модулю $p$; следовательно, машина, на которой
реализуется этот метод, должна позволять легко осуществлять такие
модулярные вычисления. В частности, простое число $p$ должно быть
таким, чтобы его можно было закодировать в виде машинного 
слова; по аналогичным соображениям таковым должно быть и основание
используемой системы счисления. Теперь почти все ограничения 
сформулированы. Остается только найти простые числа $p$, которые можно
реализовать на машине, и при этом степень 2 в $p - 1$ была бы 
достаточно велика. В таблице 2 приведены простые числа, меньшие $2^{16}$ и
такие, что степень двойки в разложении $p - 1$ на простые множители
не меньше 8. Эта таблица позволяет выбирать простые числа при 
работе на 16-битной машине. Мы ограничимся этим частным случаем для
изучения производительности метода Полларда. \par
 В данной таблице наибольший интерес представляет число $40961$\linebreak $=
5 \times 2^13 + 1$ , так как оно содержит наибольшую степень 2, а его 
нечетный делитель наименьший. Вернемся к условиям предложения 14 
(внимание, $n$ теперь обозначает длину чисел в системе с основанием $b$):
используется система счисления с основанием $b$ и длина $n$ чисел в этой
системе удовлетворяет неравенствам $(b — 1)^{2}n < 40961$ и $n = 2^{m} \leq 2^{12}$.Учитывая специфику используемых машин, наиболее разумным 
представляется выбор основания системы счисления в виде степени 2, $b = 2^{l}$,и тогда предыдущие условия перепишутся как $2^{2l+m} \leq 2^{15} < 40961$ и
$m < 12$. Посмотрим как отразятся эти неравенства на величине перемножаемых чисел. Ниже приведена таблица возможных значений $l,m$ и
величины перемножаемых чисел с этими характеристиками (эти 
величины порядка $b^{n} = 2^{l2^{m}}$).
\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline  
$l$ & 7 & 6 & 5 & 4 & 3 & 2 & 1 \\ 
\hline
$m$ & 1 & 3 & 5 & 7 & 9 & 11 & 12 \\
\hline
$u,v \leq$ & $2^{14}$ & $2^{48}$ & $2^{160}$ & $2^{512}$ & $2^{1536}$ & $2^{4096}$ & $2^{4096}$   \\
\hline
\end{tabular}
\end{table}

Как видим, величина перемножаемых чисел растет при уменьше-\linebreak
нии основания системы, тем не менее не достигая экстраординарных\linebreak
значений: например, $2^{4096}$ --- число, которое имеет порядка 1230 десятичных цифр. Если довериться грубым результатам этой таблицы, то \linebreak
можно подумать, что наиболее приемлемое для работы основание системы счисления есть 4, ибо это наибольшее основание, при котором достигается верхняя граница размера перемножаемых чисел. Здесь на- \linebreak
\pagebreak
\newpage
%\lhead{\textit{IV-2.3 Умножение целых чисел методом Лолларда}}
%\rhead{435}
\hspace{-14pt}до действовать быстро! Если использовать это основание, то можно
было бы перемножать 1000-значные числа, но эти вычисления 
потребовали бы промежуточных действий (по модулю $p$), приводящих к числам
почти достигающим $2^{16}$. Следовательно, каждая цифра кодируется 16-
битным словом. При использовании системы счисления с основанием
4 на каждые 16 бит, необходимых для промежуточных вычислений,
эффективно используются лишь 2, которые управляют цифрами, а 
значит, с пользой работает лишь 1/8 часть памяти. Например, 
кодирование близкого к максимально допустимому числа требует 2048 
машинных слов, тогда как это же кодирование требует 256 слов в системе
с основанием $2^{16}$. Кроме того, арифметические операции в системе с
основанием 4 недостаточно эффективны в современных машинах, в то
время как основание 256 лучше всего использует и память, и потенциал
машины. Таким образом, читатель может убедиться, что для того, 
чтобы максимально оптимизировать использование имеющихся ресурсов,
нужно быть как можно ближе к максимуму возможностей машины. То
же самое касается основания системы и используемых чисел. И ясно,
что это невозможно в тех условиях, которые мы только что описали.\par
  Конечно, если вместо 16-разрядной машины работают на 
32-разрядной, то величина перемножаемых при помощи алгоритма чисел 
увеличивается (в таблице 3 приведены простые числа $p$, меньшие $2^{31}$ и
такие, что степень 2 в разложении $p - 1$ не меньше 21). Но, используя
китайскую теорему об остатках, можно улучшить приведенные выше
рассуждения, откуда мы и получим настоящий алгоритм Полларда.\par
 Выберем три простых числа $p_{1}, p_{2}$ и $p_{3}$ которые можно 
закодировать на машине (мы предполагаем теперь, что наша машина 
32-разрядная) и удовлетворяющие неравенству $(b - 1)^{2}n < 2p_{1}p_{2}p_{3}$.Интуитивно можно считать, что два из этих чисел мажорируют основание системы счисления, а третье --- длину умножаемых чисел, и, таким образом, мы
приблизимся к тем границам, о которых только что говорили. \par
   \textbf{Метод Полларда} умножения двух чисел $u$ и $v$, при обозначениях
начала раздела, выглядит следующим образом: \par
($i$) приведем цифры $u$ и $v$; по модулям $p$,- и получим шесть 
многочленов $U_{1}, U_{2}, U_{3}$ и $V_{1},V_{2}, V_{3}$. Эта операция имеет линейную сложность по сравнению с величиной чисел (и может быть проведена немедленно, если простые числа мажорируют основание системы),\par
($ii$) используем FFT для умножения по модулям $p_{1}, p_{2}, p_{3}$ трех пар\linebreak
полученных многочленов и приходим к многочленам $W_{1}, W_{2}, W_{3}$. Эта \linebreak
\begin{flushleft}
\scriptsize
*28
\end{flushleft}

\pagebreak
\newpage

%\lhead{436}
%\rhead{\small\textit{IV-2 Китайская теорема об остатках}}

\hspace{-14pt}операция имеет сложность порядка $\mathcal{O}(6n\log{}n)$, где $n$ --- длина исходных чисел, \par
  ($iii$) с помощью результатов предыдущего раздела 
восстанавливаем многочлен $W = UV$. Сложность этого преобразования линейная по отношению к величине произведения многочленов, \par
 ($iv$) наконец, производим переносы в уме, чтобы получить цифры
произведения $w = uv$. Сложность этой операции пропорциональна 
величине результата (т.е. при плохом стечении обстоятельств вдвое больше
величины операндов).\par
 Из таблицы 3 видно, что имеются простые числа $p = q^{2^{k}} + 1$, 
меньшие $2^{31}$, для которых $q$ достаточно мало. Для применения метода надо
все-таки выбрать их таким образом, чтобы вычисления по модулям $p$,
были как можно проще. На используемой нами машине мы не располагаем операциями с 32 битами, дающими 64 битовые результаты, но можем без труда организовать вычисления по модулю числа, меньшего $2^{30}$. Выберем числа
\begin{center}
$469\ 762\ 049 = 7 \times 226 + 1, 167 772 161 = 5 \times 225 + 1,$ \\
$754\ 974\ 721\ = 45 \times 2^{24} + 1,$
\end{center}
что немедленно дает нам границу на величину чисел, к которым 
можно применять алгоритм: они могут иметь более $2^{23}$ цифр в выбранной
системе счисления (но так, чтобы их произведение имело не более $2^{24}$
цифр). Основание системы счисления, которое мы должны выбрать, должно оптимально использовать память, а следовательно, использовать как можно лучше 32 бита, в которых у нас записаны простые числа. Кроме того, если мы хотим оптимизировать фазу ($i$) алгоритма Полларда, то лучше выбрать основание меньше используемых простых чисел. 
\begin{table}[h]
\centering
\small
\begin{tabular}{|l l l|}
\hline
$2013265921=15\times2^{27}+1$ & & \\ 
\multicolumn{3}{|c|}{} \\
\hline
$469762049=7\time 2^{26}$ & $1811939329=27\times2^{26}+1$ & \\  
\multicolumn{3}{|c|}{} \\
\hline
$167772161=5\times2^{25} + 1$ & $1107296257=ЗЗ\times2^{25}+1$ & $1711276033=51\times2^{25}+1$  \\
$2113929217=63\times2^{25}+1$ & & \\
\multicolumn{3}{|c|}{} \\ 
\hline
$754974721=45\times2^{24}+1$ & $1224736769 = 73\times2^{24}+1$ & $2130706433=127\times2^{24}+1$  \\
\multicolumn{3}{|c|}{} \\
\hline
$377487361=45\times2^{23}+1$ & $595591169=71\times2^{23}+1$ & $645922817=77\times2^{23}+1$ \\
$880803841=105\times2^{23}+1$ & $897581057=107\times2^{23}+1$ & $998244353=119\times2^{23}+1$ \\  
$1300234241=155 \times 2^{23}+1$ & $1484783617=177\times2^{23}+1$ & $2088763393=249\times2^{23}+1$ \\
\multicolumn{3}{|c|}{} \\  
\hline
\end{tabular}
\end{table}
\vspace{-14pt}
\begin{flushleft}
\textbf{Таблица 3.} Простые числа < $2^{31}$ и пред ставимые в виде $p - 1 = q^{2^{k}}$
\end{flushleft}
\pagebreak
\newpage

%\lhead{\textit{IV-2.3 Умножение целых чисел методом Лолларда}}
%\rhead{437}

\begin{table}[h]
\centering
\small
\begin{tabular}{|l l l|}
\hline
\multicolumn{3}{|c|}{} \\
$104857601=25\times2^{22} + 1$ & $113246209=27\times2^{22} + 1$ & $138412033=ЗЗ\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$155189249=37\times2^{22} + 1$ & $163577857=39\times2^{22} + 1$ & $230686721=55\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$415236097=99\times2^{22} + 1$ & $415236097=99\times222 + 1$ & $683671553=163\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$918552577=219\times2^{22}+1$ & $935329792=223\times2^{22}+1$ & $943718401=225\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$985661441=235\times2^{22}+1$ & $1161822209=277\times2^{22}+1$ & $1212153857=289\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$1321205761=315\times2^{22}+1$ & $143864627а=343\times2^{22}+1$ & $1572864001=375\times2^{22}+1$  \\
\multicolumn{3}{|c|}{} \\
$1790967809=427\times2^{22}-1$ & $1866465281=445 \times 2^{22}+1$ & $2025848833=483\times2^{22}-1$  \\
\hline
\multicolumn{3}{|c|}{} \\
$23068673=11\times2^{21} + 1$ & $69206017= ЗЗ \times2^{21} + 1$ & $81788929=39\times221 + 1$  \\
$111149057=53\times2^{21} + 1$ & $132120577=63\times2^{21} + 1$ & $136314881=65\times2^{21} + 1$ \\ 
$169869313=81\times2^{21} + 1$ & $186646529=89\times2^{21} + 1$ & $199229441=95\times2^{21} + 1$  \\
$21181235a=101\times2^{21}+1$ & $249561089=119\times2^{24}+1$ & $257949697=123\times2^{21} + 1$  \\
$270532609=129\times221 + 1$ & $274726913=131\times221 + 1$ & $383778817=183\times2^{21} + 1$  \\
$387973121=185\times2^{21} + 1$ & $459276289=219\times2^{21} + 1$ & $463470593=221\times2^{21} + 1$ \\ 
$576716801=275\times2^{21} + l$ & $597688321=285х2^{21} + 1$ & $635437057=303\times2^{21} + 1$  \\
$639631361=305\times2^{21} + 1$ & $648019969=309\times2^{21} + 1$ & $710934529=339\times2^{21} + 1$ \\ 
$715128832=341\times2^{21} + 1$ & $740294657=353\times2^{21} + 1$ & $786432001=375\times2^{21} + 1$  \\
$799014913=381\times2^{21} + 1$ & $824180737=393\times2^{21} + 1$ & $899678209=429\times2^{21} + 1$  \\
$924844032=441\times2^{21} + 1$ & $950009857=453\times2^{21} + 1$ & $962592769=459\times2^{21} + 1$  \\
$975175681=465\times2^{21} + 1$ & $1004535809=479\times2^{21} + 1$ & $1012924417=483\times2^{21} + 1$  \\
$109261619а=521\times2^{21} + 1$ & $1138753537=543\times2^{21} + 1$ & $1151336449=549\times2^{21} + 1$  \\
$1205862401=575\times2^{21} + 1$ & $1214251009=579\times2^{21} + 1$ & $1218445313=581\times2^{21} + 1$  \\
$128135987а=611\times2^{21} + 1$ & $1306525697=623\times2^{21} + 1$ & $1327497217=633\times2^{21} + 1$  \\
$136524595а=651\times2^{21} + 1$ & $1415577601=675\times2^{21} + 1$ & $1541406721=735\times2^{21} + 1$  \\
$1558183937= 743\times2^{21} + 1$ & $1570766849= 749\times2^{21} + 1$ & $1654652929= 789\times2^{21} + 1$ \\ 
$1709178881=815\times2^{21} + 1$ & $1835008001=875\times2^{21} + 1$ & $1868562433=891\times2^{21} + 1$  \\
$1893728257=903\times2^{21} + 1$ & $193147699а=921\times2^{21} + 1$ & $1998585857=953\times2^{21} + 1$  \\
$2095054849=999\times2^{21} + 1$ & $2099249153=1001\times2^{21} + 1$ & \multicolumn{1}{c|}{\ } \\
\hline    
\end{tabular}
\end{table}
\begin{center}
Окончание таблицы 3.
\end{center}
Наконец, чтобы ускорить вычисления на машине, это основание должно быть степенью 2 и даже степенью $2^{8}$, поэтому мы выберем $b = 2^{24}$. Тогда верхняя грань умножаемых чисел равна
$$b^{2^{23}} = 2^{24 \times 8388608} = 2^{201326604};$$
это означает, что при выбранных простых числах можно перемножать
числа, имеющие примерно 70 миллионов цифр в десятичной записи 
(заметим, что современные машины имеют порядка $2^{23}$ байт памяти, что
%что делать
\pagebreak
\newpage

%\lhead{438}
%\rhead{\small\textit{IV-3 Группа обратимых элементов в $\mathbb{Z}/n\mathbb{Z}$}}
\hspace{-14pt}позволяет кодировать $2^{21}$ цифр в системе с основанием $2^{32}$). Конечно,
если выбрать простые числа еще большими, например,
\begin{center}
$3\ 221\ 225\ 473 = 3 \times 230 + 1, 3\ 489\ 660\ 929= 13 \times 228 + 1,$
$2\ 013\ 265\ 921 = 15\times2^{27} + 1,$
\end{center}
и уметь достаточно экономично считать в системе с основанием $2^{32}$,
то получится еще более впечатляющая граница:
$$b^{2^{26}} = 2^{32 \times 67108864} = 2^{2\ 147\ 483\ 648},$$
что составляет примерно 700 миллионов десятичных цифр 
(кодирование одного такого числа требует порядка 250 миллионов байт).
\vspace{10pt}


\sectiontop
\section{Группа обратимых элементов в $\mathbb{Z}/n\mathbb{Z}$}


\hspace{-14pt}Если А --- коммутативное кольцо с единицей, то группа обратимых
элементов А есть
$$U(A) = \{x \in A \vrule\ \exists y \in A:xy = yx = 1  \}$$
Если $А$ и $В$ — два унитарных коммутативных кольца, то ясно, что
$U(А \times В) = U(А) \times U(В)$. Вспомним следствие 8, сформулированное в
разделе 2, и уточним одно из его следствий. \\
Пусть $n_{1}, n_{2}, \ldots, n_{q}$--- попарно взаимно простые целые числа и $n = n_1n_2\ldots n_q$. Тогда $U(\mathbb{Z}/n\mathbb{Z})\simeq U(\mathbb{Z}/n_1\mathbb{Z})\times \cdots \times U(\mathbb{Z}/n_q\mathbb{Z})  $. В 
частности, если разложение $n$ на простые множители есть $p_1^{\alpha_1}p_2^{\alpha_2} \ldots p_r^{\alpha_r}$, то

$$U(\mathbb{Z}/n\mathbb{Z})\simeq U(\mathbb{Z}/p_1^{\alpha_1}\mathbb{Z})\times U(\mathbb{Z}/p_2^{\alpha_2}\mathbb{Z}) \times \cdots \times U(\mathbb{Z}/p_r^{\alpha_r}\mathbb{Z}).$$
Следовательно, изучение группы обратимых элементов $\mathbb{Z}/n\mathbb{Z}$ сводится к изучению аналогичной группы для $\mathbb{Z}/p^{\alpha}\mathbb{Z}$ с простым $p$. \\
\sectiontop
\subsection{Порождающие $\mathbb{Z}/n\mathbb{Z}$ и функция Эйлера}
\vspace{4pt}\textbf{(16) Определение.} 
\par
Порядок группы $U(\mathbb{Z}/n\mathbb{Z})$ для $n \in N$ назовем функцией Эйлера я обозначим ее через $\varphi(n)$. Значение функции Эйлера в точке $n$ равно числу элементов интервала $[0, n[$, взаимно простых с $n$, или числу порождающих циклической группы порядка $n$.
\pagebreak
\newpage

%\lhead{\small\textit{IV-3.1 Порождающие $\mathbb{Z}/n\mathbb{Z}$ и функция Эйлера}}
%\rhead{439}
\textbf{(17) Предложение.} \\
($i$) Если $p$ --- простое число и $\alpha > 0$, то $\phi(p^{\alpha}) = p^{\alpha - 1}(p - 1)$. В частности, $\varphi(p) = p - 1$. \par
($ii$) Если $n$ --- положительное целое число, то $\sum_{d|n}\varphi(d) = n$. \par
($iii$) Если $n$ и $m$ --- взаимно просты, то $\varphi(nm) = \varphi(n)\varphi(m)$(это прямое следствие китайской теоремы об остатках).\par  
($iv$) Следовательно, если $n = p_1^{\alpha_1} \ldots p_r^{\alpha_r}$--- разложение $n$ на простые множители, то
$$\varphi(n) = \prod\limits_{i = 1}^{r}p_{i}^{\alpha_{i}-1}(p_{i} - 1) = n\prod\limits_{i = 1}^{r}(1 - \frac{1}{p_i})$$
\begin{myproof}
($i$) $U(\mathbb{Z}/p^{\alpha}\mathbb{Z})$--- это множество элементов из $U(\mathbb{Z}/p^{\alpha}\mathbb{Z})$, взаимно простых с $p$. Так как $p$ простое, то это также множество элементов из $U(\mathbb{Z}/p^{\alpha}\mathbb{Z})$, которые не кратны $p$. Следовательно,
\begin{center}
$U(\mathbb{Z}/p^{\alpha}\mathbb{Z}) =\mathbb{Z}/p^{\alpha}\mathbb{Z} - p\mathbb{Z}/p^{\alpha}\mathbb{Z}$\enskip и\enskip $\varphi(p^{\alpha}) = p^{\alpha} - p^{\alpha - 1}$
\end{center}
что и требовалось доказать.  \\
($ii$) Пусть $\mathbb{Z}_{n,d} = \{x \in \mathbb{Z}/n\mathbb{Z} \}$. Тогда $\mathbb{Z}_{n,d}$ содержится в подгруппе $\{ х \in \mathbb{Z}/n\mathbb{Z} | dx = 0 \}$,которая является циклической группой порядка $d$, если $d$ делит $n$ (предложение 4). Множество  $\mathbb{Z}_{n,d}$ есть множество порождающих элементов этой циклической группы, а значит, состоит из $\varphi (d)$ элементов. Чтобы закончить доказательство, достаточно заметить, что семейство $\mathbb{Z}_{n,d}$ --- это разбиение множества $\mathbb{Z}/n\mathbb{Z}$. \\
Пункт ($iv$) немедленно следует из ($i$) и ($iii$).
\end{myproof}
\textbf{(18) Следствие.} \\
  \textbf{($i$)Теорема Лагранжа:} пусть $x \in U(\mathbb{Z}/n\mathbb{Z})$, тогда $x^{\varphi (n)} = 1$, что можно перефразировать следующим образом: для всякого целого $x$, взаимно простого с $n$, $x^{\varphi(n)} \equiv 1\ (mod\ n)$. \par
  \textbf{($ii$) Малая теорема Ферма}: пусть $p$ --- простое,а $x$ — целое 
число $x \not\equiv 0\ (mod\ p)$, тогда $x^{p - 1} \equiv 1\ (mod\ p)$. Освобождаясь от ограничений на $x$, получаем эквивалентную формулировку теоремы: $x^{p}\equiv x\ (mod\ p)$.
\pagebreak
\newpage

%\lhead{440}
%\rhead{\small\textit{IV-3 Группа обратимых элементов в $\mathbb{Z}/n\mathbb{Z}$}}
\textbf{Примеры} \par
 \textbf{1.} Пусть $n$ = 26. Группа обратимых элементов в $\mathbb{Z}_{26}$ равна
$$\{1,3,5,7,9,11,15,17,19,21,23,25\}$$
и, следовательно, $\varphi (26) = \varphi (2) \varphi (13) = 12$. Можно проверить, что для этого кольца 12 --- наименьший показатель $m$ такой, что $x^{m} = 1$. Наименьший как в смысле обычного упорядочения целых чисел, так и в
смысле делимости. Это так называемый индикатор Кармайкла числа 26 или экспонента группы $U(\mathbb{Z}_{26})$. \par
  \textbf{2.} Пусть $n = 15$. Обратимые по модулю 15: 1, 2, 4, 7, 8, 11, 13
и 14. Функция Эйлера от 15, следовательно, равна 8, но на этот раз
это не самый маленький показатель с $x^{m} = 1$ для всех $x \in \mathbb{Z}/15\mathbb{Z}$. Действительно, $\varphi(3) = 2$ и $\varphi(5) = 4$; откуда, если $y \in U(\mathbb{Z}_{3})$ и $z \in U(\mathbb{Z}_5)$, то $y^{2} = 1$ и $z^4 = 1$, следовательно, $x^4 = 1$ для всех $x \in U(\mathbb{Z}_{15})$.Экспонента группы $U(\mathbb{Z}_{15}$) равна 4, а не 8. \par
  \textbf{3.} Рассмотрим $n = 561 = 3 \cdot 11 \cdot 17$.$\varphi (561) = 320$ и не трудно проверить, что индикатор Кармайкла 561 равен 80. К тому же 561 --- исключительное число в том смысле, что 80 делит $561 - 1$. Следовательно
для $x$ взаимно простого с 561, выполняется: $x^{560} \equiv 1\ (mod\ 561)$, 
иначе говоря, 561 удовлетворяет малой теореме Ферма, не являясь при этом простым числом. Такие числа называются числами Кармайкла. Мы столкнемся с этими числами при изучении теста на простоту Рабина — Миллера. \\
%\subsectiontop
\subsection{Системы криптографии с открытым ключом}
В качестве применения элементарных свойств группы $U(\mathbb{Z}/n\mathbb{Z}$ мы дадим несколько примеров систем шифрования с открытым ключом. 
Ставится следующая задача: некий Томас хочет быть уверен в 
конфиденциальности посланий, которые он получает. Для этого он определяет
две функции, одну мы обозначим через $C$ и назовем ключом 
зашифрования, а вторую $D$ назовем ключом расшифрования. В классических
криптографических схемах обе функции держатся в секрете. Принцип
системы с открытым ключом был впервые предложен Диффи и Хеллманом [64] со следующими требованиями на функции $C$ и $D$:\par
  ($i$) Если $M$ какое-то послание, то $D(C(M)) = M$.\par
  ($ii$) Очень трудно, или невозможно, найти $D$, зная $C$\par
  ($iii$) Наконец, ключ $C$ невозможно взломать, даже если известны
любые выбранные пары (незашифрованное сообщение, зашифрованное
сообщение). $C$ --- так называемая функция-ловушка.
\pagebreak
\newpage
%\lhead{\small\textit{IV-3.2 Системы криптографии с открытым ключом}}
%\rhead{441}

\rule{0pt}{18pt}
 Это последнее ограничение является тем козырем, который 
позволя-\linebreak ет Томасу предоставить ключ $C$ для общественного пользования. При\linebreak
этом, если кто-то хочет послать конфиденциальное сообщение Томасу,\linebreak
он его кодирует при помощи ключа шифрования $C$. Согласно 
гипо-\linebreak тезам, лишь Томас сможет декодировать это сообщение при помощи\linebreak
известного только ему ключа расшифрования.\par
 Прежде чем рассмотреть несколько систем шифрования с 
откры-\linebreak тым ключом, рассмотрим пример использования этих систем: 
удосто-\linebreak верение посланий, называемое еще электронной подписью. Во время\linebreak
обмена информацией между двумя лицами очень важно для обоих 
убе-\linebreak диться в «достоверности» своего партнера и в том, что никто другой \linebreak
не может узнать содержание посланий. Точнее, принимающий может\linebreak
проверить личность посылающего, так что посылающий не сможет 
впоследствии отказаться от своего сообщения.\par
 Рассмотрим двух корреспондентов, Романа и Клару, с 
соответству-\linebreak ющими ключами зашифрования и расшифрования $C_r , D_r , C_c$ и $D_c$, ко-\linebreak торые будем считать биективными. Роман может подписать свое 
сообщение следующим образом. Сначала он кодирует свою подпись $S$, 
ис-\linebreak пользуя свой ключ расшифрования $D_r$, а затем полученный результат
кодирует ключом зашифрования Клары $C_c$, который известен. Клара \linebreak
получает сообщение $C_c(D_r(S))$ и последовательно применяет к нему \linebreak
ключ расшифрования $D_c$, который известен только ей, и ключ 
заши- \linebreak фрования $C_r$, который известен всем. Поскольку функции 
зашифрова-\linebreak ния и расшифрования взаимно обратны, то она получает подпись 
Ро-\linebreak мана, достоверность которой подтверждается тем фактом, что только\linebreak
один Роман мог воспользоваться ключом $D_r$. Фактически, для 
тако-\linebreak го механизма подписи было бы достаточно, чтобы Роман закодировал
свою подпись своим ключом расшифрования, кодируя же ее ключом
зашифрования Клары, он уверен, что ее сможет декодировать только\linebreak
Клара.\par
 Еще одно интересное применение описано Гарелом [81] (книга, 
ко-\linebreak торую надо обязательно прочитать!), и заключается оно в игре в 
по-\linebreak кер по телефону. Пусть два игрока, один на западном, а другой на\linebreak
восточном побережье США, хотят сыграть партию в покер по теле-\linebreak фону. Проблемы, возникающие при этом: раздать каждому по 5 карт,\linebreak
сыграть партию и в конце партии иметь возможность проверить, что\linebreak
никто из участников не плутовал. Для этого используют систему двух\linebreak
ключей, зашифрования и расшифрования, и предполагают, что ключи\linebreak
обоих игроков коммутируют. Кроме того, до конца партии оба игрока\linebreak
хранят свои ключи расшифрования в секрете и открывают их лишь в\linebreak
конце, чтобы позволить сопернику проверить не было ли плутовства.

\newpage

%\lhead{442}
%\rhead{\small\textit{IV-3 Группа обратимых элементов в $\mathbb{Z}/n\mathbb{Z}$}}
Чтобы раздать карты, один игрок, Томас, берет 52 карты и 
кодирует их, используя свой ключ зашифрования, затем он перемешивает
полученные коды и посылает их второму игроку, Роману. Тот 
вынимает из полученного пакета 10 карт, из которых выбирает 5 карт для
Томаса, а 5 для себя и кодирует свои карты ключом зашифрования.
Затем он посылает их все Томасу, который декодирует все 10 карт: 5
карт появятся незашифрованными (так как ключи игроков 
коммутируют) --- это его карты. Оставшиеся 5 карт он снова посылает Роману,
который также сможет их декодировать. Теперь можно начать партию
и ее развитие будет идти по тому же протоколу, что и раздача, когда
речь пойдет об обмене картами.\\
\subsectiontop
\subsubsection{Система RSA}
\par
 Эта система была предложена в 1977 году Ривестом, Шамиром и
Адлеманом [156]. Принцип ее действия чрезвычайно прост: выбирается
группа $G$ порядка $g$, который держится в секрете (в $G$ возможны 
вычисления), а также целое число $с$ (ключ расшифрования), обратимое по
модулю $g$. Передаваемое сообщение представляет собой 
последовательность элементов из $G$, каждый из которых является зашифрованным
членом последовательности, соответствующей исходному сообщению.
Элемент $x \in G$ шифруется как $x^c$. Получатель, который знает $g$, может
вычислить обратное к $c$ по модулю $g$ число, скажем $d$. Биекции $x \rightarrow x^c$ и $x \rightarrow x^d$ взаимно обратные: $(x^{c})^{d} = x$, так как порядок $G$ равен g. Сообщение, таким образом, может быть декодировано посредством возведения в степень $d$ каждого члена полученной последовательности.\par
  Чтобы применить этот метод, остается найти такие группы, 
порядок которых трудно вычислим, в то время как вычисления в них 
достаточно просты. В качестве таких групп можно взять группы обратимых
элементов в $\mathbb{Z}/n\mathbb{Z}$, если не известно разложение п на простые множители. Итак, выбираются два больших простых числа, $p$ и $q$. Легко 
вычислить $\varphi(n) = (p - 1)(q - 1)$ --- число, которое держится в секрете (действительно, зная $\varphi (n)$, можно найти сумму чисел $p$ и $q$, произведение которых $n$ известно). Зная же $n$ и $c$, невозможно обратить $c$ по модулю $\varphi (n)$, так как $\varphi (n)$ можно вычислить, используя факторизацию $n$.\par
 Если $c$ и $d$ взаимно обратны по модулю $\varphi(n)$, то биекции $x \rightarrow x^c$ и $x \rightarrow x^d$ также взаимно обратны в $U(\mathbb{Z}/n\mathbb{Z})$. Фактически же эти биекции взаимно обратны и в $\mathbb{Z}/n\mathbb{Z}$. \\
 
\textbf{(19) Лемма.} \\

  Пусть $p$ и $q$ --- два различных простых числа и $f \equiv 1\ (mod\ (p-1)(q-1))$. Тогда $x^{f} = x$ для всех $x \in \mathbb{Z}/n\mathbb{Z}$.
\pagebreak
\newpage
%\lhead{\textit{IV-3.2.1 Система RSA}}
%\rhead{443}
\begin{myproof}
$f - 1$ кратно $q - 1$, а значит, $p^{f - 1} \equiv 1\ (mod\ q)$ и $p^f \equiv p\ (mod\ q)$, откуда $p^f \equiv p\ (mopd\ pq)$, так как ри</ различны. Меняя местами $p$ и $q$, получим аналогичное сравнение. Таким образом, необходимое
нам равенство верно для $x \in U(\mathbb{Z}_{pq} \bigcup \{p,q \})$. Оно сохраняется при умножениях, а следовательно, оно верно для любого $x \in \mathbb{Z}_{pq}$, ибо любой необратимый элемент кратен $p$ или $q$.
\end{myproof}
  Следовательно, можно закодировать исходное сообщение, ставя в
соответствие каждому его члену элемент из $\mathbb{Z}_n$. Расшифровка 
гарантирована.\\
\textbf{Пример} \par
  Рассмотрим следующие два простых числа $p$ и $q$ и их произведение $n$:
\begin{center}
$p = 37\ 866\ 809\ 061660\ 057\ 264\ 219\ 253\ 397,$ 
$q = 2^{60} - 173 = 1152\ 921\ 504\ 606\ 846\ 803,$ 
$n = pq = 43\ 657\ 458\ 478\ 029\ 293\ 976\ 669\ 622\ 635\ 814\ 729\ 303\ 016\ 339\ 791.$
\end{center}
Отметим, что факторизация п обычным методом потребовала бы 
порядка $10^{17}$ операций, что соответствует примерно 1000 лет работы 
машины, выполняющей миллион операций в секунду. Немного 
усовершенствованный, типа метода Полларда (раздел 6.3), метод факторизации
требует порядка $10^9$ операций, а значит, с выбранными числами 
предложения система шифрования может быть взломана. Однако на практике
выбирают простые числа, имеющие порядка 100 цифр в десятичной 
записи, и там даже метод Полларда бессилен. Итак, в качестве открытого
ключа требуется обнародовать п и число, обратимое по модулю
$$(p - 1)(q - 1) = 43 657 458 478 029 293 938 802 813 573 001750 534 190 239 592,$$
например, $c = 3$. Если исходное послание представляется в виде числа
$$m = 123 456 654 092127 765 342 896 201397,$$
то посылающий возводит его в куб по модулю $n$, что дает
$$m^{3}\ mod\ n = 36 807 684 002 873 914 344 429 802 591 773 115 971466 280 467.$$
Получатель легко может обратить 3 по модулю $\varphi (n)$ действительно,
так как $p$ и $q$ сравнимы с 2 по модулю 3, то $\varphi (n) = (n - 1)(q - 1)$
сравнимо с 1 по модулю 3, а значит, число
$$d = \varphi (n) - (\varphi (n) - 1)/3 = 29104 972 318 686 195 959 201875 715 334 500 356 126 826 395$$
\newpage
