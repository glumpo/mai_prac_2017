    \documentclass{../../template/mai_book}

    \defaultfontfeatures{Mapping=tex-text}
    % \setmainfont{DejaVuSans}
    \setdefaultlanguage{russian}

    \begin{document}
    %\rhead{\emph{\leftmark}}
    %\lhead{\thepage}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
    % это можно убрать при сшивке с предыдущими страницами

    \setcounter{chapter}{3}
    % ОБЯЗАТЕЛЬНО ДВА РАЗА
    %\chapter[Модули над кольцами главных идеалов]{Модули над кольцами главных идеалов}
    %\thispagestyle{empty} % обязательно после chapter!!!

    %\setcounter{section}{10}
    %\section{Решения упражнений}

    \setcounter{subsection}{32}
    %\subsection{Абелевы группы данного порядка $n$}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \newpage
    \chaptertop
    \setcounter{page}{406}
    %\restoretop

    \setcounter{lstlisting}{7}
    \begin{center}
    \begin{minipage}{0.80\textwidth}
    \begin{lstlisting}[
    mathescape=true,
    captionpos={bo},
    caption={Коррекция последовательности $(r_1, \ldots, r_s)$}\label{euclid}
    ]
    	$u \gets 0$;
    	for $i$ $\textbf{in}$ $s...1$ do
    		$u \gets u + r_i;\quad▷\ u = r_i + ... + r_s;$
    		if $(s − i + 1)(1 + r_i ) \leqslant u$ then
    			$r_s \gets u − (s − i)(1 + r_i);$
    			$r_i...s−1 \gets 1 + r_i$;
    			exit;
    		end if
    	end for
    \end{lstlisting}
    \end{minipage}
    \end{center}

    %\setcounter{algorithm}{7}
    %\begin{algorithm}
    %\caption{Коррекция последовательности $(r_1, \ldots, r_s)$}\label{euclid}
    %\begin{algorithmic}
    %\State $u\gets 0;$
    %\For{$i$ \textbf{in} $s...1$}
    %\State $u\gets u + r_i;$ \Comment{$u = r_i + ... + r_s;$}
    % \If{$(s-i+1)(1+r_i) \leqslant u$}
    % \State $r_s \gets u - (s - i)(1 + r_i);$
    % \State $r_{i\ldots s-1} \gets 1 + r_i;$
    % \State \textbf{exit;}
    % \EndIf;
    %\EndFor;
    %\end{algorithmic}
    %\end{algorithm}

    Например, для $r = 6$ получаем следующие $\rho(6) = 11$ последователь-\linebreak ностей:
    \begin{gather*}
    (6),\quad (1, 5),\quad (2, 4),\quad (3, 3),\quad (1, 1, 4),\quad (1, 2, 3),\quad (2, 2, 2),\\
    (1, 1, 1, 3), \quad (1, 1, 2, 2), \quad (1, 1, 1, 1, 2),\quad (1, 1, 1, 1, 1, 1),
    \end{gather*}
    которые образуют для $p = 2$ одиннадцать абелевых групп порядка 64:
    \begin{gather*}
    \mathbb{Z}_{64},\quad \mathbb{Z}_2\times \mathbb{Z}_{32},\quad \mathbb{Z}_4\times \mathbb{Z}_{16},\quad \mathbb{Z}_8 \times \mathbb{Z}_8,\quad \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_{16},
    \quad \mathbb{Z}_2\times \mathbb{Z}_4 \times \mathbb{Z}_8 ,\\ \quad \mathbb{Z}_4 \times \mathbb{Z}_4 \times \mathbb{Z}_4,\quad \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_8 ,\quad \mathbb{Z}_2 \times \mathbb{Z}_2\times \mathbb{Z}_4 \times \mathbb{Z}_4 ,\\ \quad \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2\times \mathbb{Z}_4,\quad \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2 \times \mathbb{Z}_2.
    \end{gather*}

    Приведем таблицу чисел $\rho(r)$\footnote{Заметим, что число $\rho(r)$ равно $\rho(r)$, числу разбиений $r$ на меньшие слагаемые, так что для определения значения $\rho(r)$ при больших $r$ можно воспользоваться знаменитой формулой Рамануджана, дающей решению задачи partitio numerorum.~— {\slshape Прим. перев.}}:

    \begin{table}[h!]
    \centering
    \label{my-label}
    \begin{tabular}{|l|cccccccccc|}
    \hline
    \multicolumn{11}{|c|}{\begin{tabular}[c]{@{}c@{}}$\rho_r = $ число абелевых групп порядка $\rho^r$,\\ $\rho$~— произвольное простое число\end{tabular}} \\ \hline
    $r$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
    $\rho_r$ & 1 & 2 & 3 & 5 & 7 & 11 & 15 & 22 & 30 & 42 \\ \hline
    $r$ & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 & 20 \\
    $\rho_r$ & 56 & 77 & 101 & 135 & 176 & 231 & 297 & 385 & 490 & 627 \\ \hline
    \end{tabular}
    \end{table}

    {\bfseries b.\;}\,Отношение Безу $1 = u\,n + v\,m\,$ для $\,x \in \Omega\,$ влечет $\,x = v\,m\,x + u\,n\,x$ и $\,\Omega = \Omega^{(n)} \oplus \Omega^{(m)}\,$. Остается определить порядок $\Omega^{(n)}$. Так как $\Omega^{(n)}$~— конечная абелева группа, обнуляющаяся $n$, то она является
    частным от степени $\mathbb{Z}_n$ и, следовательно, если простое $p$ делит порядок группы $\Omega^{(n)}$, то $p$ делит $n$. Разложение на простые множители порядка группы $\Omega^{(n)}$ (соответственно группы $\Omega^{(m)}$) состоит из простых делителей $n$ (соответственно $m$). А так как $\card \Omega^{(n)} \times \card \Omega^{(m)} = n\,m$, то $\card \Omega^{(n)} = n$ и $\card \Omega^{(m)} = m$.

    {\bfseries c.\;}\,Если $\Omega^\prime\,$ и $\,\Omega^{\prime\prime}$~— две абелевы группы порядков, соответственно, $n$ и $m$, то $\Omega^\prime \times \Omega^{\prime\prime}$~— абелева группа порядка $n\,m$. Обратно, группа $\Omega$ порядка $n\,m$, где $n$ и $m$ взаимно просты, представляется единственным образом в виде произведения группы порядка $n$ и группы порядка $m$. Действительно, $\Omega = \Omega^{(n)} \oplus \Omega^{(m)}$ и, кроме того, если $\Omega = \Omega^\prime \oplus \Omega^{\prime\prime}$, где $|\Omega^\prime| = n$ и $|\Omega^{\prime\prime}| = m$, то $\Omega^\prime = \Omega^{(n)}$ и $\Omega^{\prime\prime} = \Omega^{(m)}$. Таким образом, получили, что любые абелевы группы порядка $nm$ представляются в виде произведения абелевой группы порядка $n$ и абелевой группы порядка $m$ (и к тому же единственным способом), откуда следует мультипликативность $\theta$.

    Если $p^{r_1}_1p^{r_2}_2 \ldots p^{r_k}_k$~— разложение на простые множители числа $n$, то \linebreak $\theta(n)=p(r_1)p(r_2) \ldots p(r_k)$, и имеются $42$ абелевы группы порядка $21\,600$.

    \subsection{\normalsize {Вычисление инвариантных множителей}}

    {\bfseries a.\;}\,Если положить $ f_1 = e_1 + \ldots + e_n,\,f_2 = e_1 - e_2,\,f_3 = e_1 - e_3, \ldots ,\,f_n = e_1 - e_n$, то $\{f_1, e_2, e_3, \ldots, e_n\}$ будет базисом $\mathbb{Z}^n$, а его первый вектор будет базисом $F$, в то время, как множество $\{e_1, f_2, f_3, \ldots, f_n\}$ будет базисом $\mathbb{Z}^n$, а его последние $n-1$ векторов будут образовывать базис $E$.

    {\bfseries b.\;}\,$\{f_1, f_2, \ldots, f_n\}$~— базис $E \oplus F$, его матрицей в каноническом базисе будет первая из приведенных ниже матриц. Если в этой матрице прибавить к столбцу 1 столбец 2, столбец 3, \ldots, затем столбец $n$, то получим матрицу, вторую по порядку. Теперь достаточно прибавить к строке 1 строку 2, строку 3, \ldots, затем строку $n$, и мы получим матрицу, изображенную последней.

    \[ \begin{pmatrix}
    1 & 1 & 1 && 1\\
    1 & -1 & 0 && 0\\
    1 & 0 & -1 && 0\\
    \vdots & \vdots & \vdots && \vdots\\
    1 & 0 & 0 && -1
    \end{pmatrix},\quad
    \begin{pmatrix}
    n & 1 & 1 && 1\\
    0 & -1 & 0 && 0\\
    0 & 0 & -1 && 0\\
    \vdots & \vdots & \vdots && \vdots\\
    0 & 0 & 0 && -1
    \end{pmatrix},
    \]

    \[ \begin{pmatrix}
    n & 0 & 0 && 0\\
    0 & -1 & 0 && 0\\
    0 & 0 & -1 && 0\\
    \vdots & \vdots & \vdots && \vdots\\
    0 & 0 & 0 & \dots & -1
    \end{pmatrix}
    .\]

    \newpage

    \subsection{\normalsize{Другое вычисление инвариантных множителей}}

    Метод приведения дает следующие матрицы:

    \[ L = \begin{pmatrix}
    1 & 0 & 0 & 0\\
    2 & 1 & 0 & 0\\
    -1 & -1 & 1 & 0\\
    -1 & -6 & 0 & 1
    \end{pmatrix},\quad
    R = \begin{pmatrix}
    -3 & 10 & -2\\
    2 & -7 & -1\\
    0 & 0 & 1\\
    \end{pmatrix},
    \]

    \[ X^\prime = \begin{pmatrix}
    -1 & 0 & 0\\
    0 & -6 & 0\\
    0 & 0 & 0\\
    0 & 0 & 0
    \end{pmatrix},
    \] при этом $X^\prime = LXR$, $L$ и $R$ имеют определители 1. Матрица $L$ индуцирует изоморфизм из $\mathbb{Z}^4/\im{X}$ в $\mathbb{Z}^4/\im{X}^\prime$, который выражается равенствами:
    $$ L(f_1) = \overline{e}_1 + 2\overline{e}_2-\overline{e}_3-\overline{e}_4,\quad L(f_2) = \overline{e}_2-\overline{e}_3-6\overline{e}_4,\quad L(f_3) = \overline{e}_3,\quad L(f_4) = \overline{e}_4,$$
    и дает, обращая формулы, приведенные выше, следующие искомые образующие $M$: $g_1 = f_1 - 2f_2 - f_3 - 11f_4 = 0,\,g_2 = f_2 + f_3 + 6f_4,\,g_3 = f_3$, и $\,g_4 = f_4$.

    \subsection{\normalsize{Инвариантные множители и НОД миноров}}

    Пусть $b_i$~— наибольший общий делитель миноров $X$ порядка $i$ для \linebreak $i = 1,\,2,\,3$.
    Число 2 делит все коэффициенты $X$, и существует пара коэффициентов, имеющая 2 своим наибольшим общим делителем (например, 6 и 10); следовательно, $b_1 = 2$. С другой стороны, 4 делит все миноры порядка 2 (если 2 делит $a, b, c, d,$ то 4 делит $ad - bc$), и существуют два минора порядка 2, имеющие 4 своим наибольшим общим делителем, например:

    $$\begin{vmatrix}
    8 & 4\\
    4 & 4
    \end{vmatrix} = 16 = 2^3 \quad\mathrm{и}\quad \begin{vmatrix}
    18 & 30\\
    4 & 10
    \end{vmatrix} = 60 = 2^2 \times 3 \times 5, $$
    что влечет $b_2 = 4$. Приведем миноры порядка 3:
    \begin{align*}
    \begin{vmatrix}
    8 & 4 & 20\\
    12 & 18 & 30\\
    4 & 4 & 10
    \end{vmatrix} = 0,\quad \begin{vmatrix}
    6 & 4 & 20\\
    12 & 18 & 30\\
    18 & 4 & 10
    \end{vmatrix} &= -3\,480,\\
    \begin{vmatrix}
    6 & 8 & 20\\
    12 & 12 & 30\\
    18 & 4 & 10
    \end{vmatrix} = 0,\quad \begin{vmatrix}
    6 & 8 & 4\\
    12 & 12 & 18\\
    18 & 4 & 4
    \end{vmatrix} &= 1\,392.
    \end{align*}
    \newpage
    Это дает $b_3 = \Nod(1\,392, 3\,480) = 696$. Следовательно, инвариантные \linebreak множители $a_1, a_2, a_3$ задаются равенствами: $a_1 = b_1 = 2,\, a_1a_2 = b_2 = 4,$\,\linebreak $a_1a_2a_3 = b_3 = 696$, откуда $a_1 = 2,\,a_2 = 2\,$ и $\,a_3 = 174$, что совпадает с результатами в данной главе!
    \subsection{\normalsize{Условие наличия одинаковых инвариантных множителей\\ относительно $A^n$}}

    Если $E$ и $F$ имеют одни и те же инвариантные множители, ясно, что $A^n/E$ и $A^n/F$ изоморфны. Обратно, предположим, что $A^n/E$ и $A^n/F$ изоморфны, и пусть $E^\prime \subset A^n$ (соответственно $F^\prime \subset A^n$) ~— нормальный подмодуль, эквивалентный $E$ (соответственно $F$):
    $$E^\prime = a_1A \times a_2A \times \ldots \times a_nA,\quad F^\prime = b_1A \times b_2A \times \ldots \times b_nA,$$
    где $a_i\,|\,a_{i+1}\,$ и $\,b_i\,|\,b_{i+1}$. Модули частные $A^n/E^\prime$ и $A^n/F^\prime$ тогда изоморфны (так как первый изоморфен $A^n/E$, а второй изоморфен $A^n/F$). Пусть $p$ и $q$ индексы, удовлетворяющие условию:
    $$i \in [1, p] \Leftrightarrow a_i \in U(A)\quad\mathrm{и}\quad j \in [1, q] \Leftrightarrow b_j \in U(A).$$
    Тогда $n-p = n-q$, и для $p < i \leqslant n\quad a_iA = b_iA$. Следовательно, $a_iA = b_iA$ для всех $i \in [1, n]$, что влечет равенство $E^\prime = F^\prime$. Итак, подмодули $E$ и $F$ эквивалентны в $A^n$: $E$ и $F$ имеют одни и те же инвариантные множители.



    \subsection{\normalsize{Определяющие соотношения}}

    Пусть $(e_1, e_2, e_3)$~— канонический базис $\mathbb{Z}^3$, a $\varphi -$ {\bf{сюръективный}} морфизм из $\mathbb{Z}^3$ на $\Omega$, который преобразует $e_i$ в $g_i$. Если $X$~— транспонированная матрица системы, то $\im X \subset \Ker\varphi$ и имеет место сюръекция из $\mathbb{Z}^3/\im X$ на $\mathbb{Z}^3/\Ker\varphi \simeq \Omega$. Следовательно, $\Omega$ изоморфна фактор-группе $\mathbb{Z}^3/\im X$. Но $\mathbb{Z}^3/\im X$ является группой с $|\det(X)| = 19$ элементами \ldots

    Можно вычислить две матрицы $L$ и $R$ c определителем 1 и такие, что матрица $X^\prime = LXR$ будет приведенной, например:
    $$ L = \begin{pmatrix}
    1 & 0 & 0\\
    0 & -1 & 0\\
    -2 & 5 & 1
    \end{pmatrix},\quad X^\prime = \begin{pmatrix}
    1 & 0 & 0\\
    0 & -1 & 0\\
    0 & 0 & 19
    \end{pmatrix},$$
    $$R = \begin{pmatrix}
    -8 & -25 & -132\\
    1 & 3 & 14\\
    0 & 0 & 1
    \end{pmatrix}.$$

    \newpage
    \noindent Тогда в $\mathbb{Z}^3/ImX^\prime \simeq \mathbb{Z}/19\mathbb{Z}$\quad\quad$g_1 = \overline{L(e_1)},\,\,g_2 = \overline{L(e_2)},\,\,g_3 = \overline{L(e_3)}$ будет образовывать такую систему. В данном примере $g_1 = -2,\,g_2 = 5\,$ и $\,g_3 = 1$.
    \subsection{\normalsize{Образующие и определяющие соотношения (продолжение)}}

    Пусть $(e_1, e_2, e_3)$~— канонический базис $\mathbb{Z}^3$, а $\varphi$~— {\bf{сюръективный}} морфизм из $\mathbb{Z}^3$ на $\Omega$, который переводит $e_i$ в $g_i$. Если $X$~— транспонированная матрица системы, то $\im X \subset \Ker
    \varphi$ и имеет место сюръекция из $\mathbb{Z}^3/\im X$ на $\mathbb{Z}^3/\Ker \varphi \simeq \Omega$. Следовательно, $\Omega$ изоморфна факторгруппе $\mathbb{Z}^3/\im X$. Но $\mathbb{Z}^3/\im X$ является группой с $|\det X| = 288$ элементами. Действительно, приведение инвариантных множителей показывает, что $X$ эквивалентна приведенной матрице $X^\prime$:

    $$ X = \begin{pmatrix}
    2 & 8 & 72\\
    4 & 20 & 72\\
    -6 & -16 & 324
    \end{pmatrix},\quad X^\prime = \begin{pmatrix}
    2 & 0 & 0\\
    0 & 4 & 0\\
    0 & 0 & 36
    \end{pmatrix},$$
    и, следовательно:
    $$\mathbb{Z}^3/\im X \simeq \mathbb{Z}^3/\im X^\prime \simeq \mathbb{Z}_2 \times \mathbb{Z}_4 \times \mathbb{Z}_{36} = \Omega^\prime.$$
    Если $\overline\varphi$ обозначает сюръекцию из $\Omega^\prime$ на $\Omega$, то подгруппа $96\Omega^\prime$ из $\Omega^\prime$ содержится в $\Ker\overline\varphi$ ($\Omega$ будет группой порядка 96, тогда $96\Omega = \{0\}$). Эта подгруппа имеет индекс 96 (или порядок 3), и, следовательно, $\overline\varphi$ индуцирует сюръекцию из $\Omega^\prime/96\Omega^\prime$ на $\Omega$, которая будет изоморфизмом (эти две группы имеют идентичные порядки). Остальное следует из того, что $\mathbb{Z}_{36}/96\mathbb{Z}_{36}\simeq \mathbb{Z}_{12}$.
    \subsection{\normalsize{Упражнение Чарльза Лутвиджа Доджсона}}
    %\textsf
    { \ldots Place 8 pigs in the first sty, 10 in the second, nothing in the third, and 6 in the fourth: 10 is nearer ten than 8; nothing is nearer ten than 10; 6 is nearer ten than nothing; and 8 is nearer ten than~6\footnote{B первом свинарнике должно находиться 8 поросят, во втором — 10 и в четвертом 6. Ничего не должно находиться в третьем свинарнике: он должен быть пуст... Десять ближе к 10, чем 8. Что может быть ближе к 10, чем~10? Ничто! Но именно «ничто» и находится в третьем свинарнике. Шесть ближе к~10, чем~О (арифметический псевдоним «ничего»), 8 ближе к~10, чем~6...
    \begin{flushright} (Перевод Ю. А. Данилова, Л. Кэррол «История с узелками», М., Мир, 1973.)\end{flushright}}.

    \begin{flushright} (Lewis Carroll, \textit {A tangled tale} (1885 [44])\end{flushright}}
    %~\cite{Carrol1982}

    \setcounter{section}{0}

    \chapter[Некоторые методы алгебраической алгоритмики]{Некоторые методы \\ алгебраической \\ алгоритмики}
    \thispagestyle{empty}

    \epigraph {Although unique factorization for integers is sometimes called the
    “fundamental theorem of arithmetic,” it is only occasionally that a
    student learns anything about the constructive aspects of this
    thm beyond the most elementary facts. Yet there are interesting
    unsolved mathematical and computational problems involved in
    factorization of integers and tests of primality and many of the ideas
    involved are accessible to undergraduate students\footnotemark[1].}{John D. Dixon, \emph{ Factorization and primality tests} (1984 [67])}
    %~\cite{Dixon1974}
    \footnotetext[1]{Хотя единственность разложения целых чисел на простые множители иногда называют «основной теоремой арифметики», студенты редко изучают конструктивные аспекты этой теоремы, кроме, быть может, самых элементарных фактов. Все еще существуют интересные нерешенные математические и комбинаторные проблемы, связанные с разложением целых чисел на множители с проверкой простоты, и многие из используемых там идей доступны студентам.}
    К этому моменту нами получены почти все предварительные результаты за исключением быстрого преобразования Фурье, которое будет детально изучено в главе V, и мы можем начать исследование в области алгоритмической алгебры или, по крайней мере, в той ее
    части, где добились наибольшего успеха, — в области чисел. Как следует из дальнейшего изложения, многие используемые алгоритмы
    опираются на четыре основных метода: алгоритм экспоненциальной дихотомии, алгоритм Евклида, китайскую теорему об остатках (которую мы
    изучим в этой главе) и быстрое преобразование Фурье, которое позволяет, используя алгоритм Полларда, эффективно перемножать большие числа. Конечно,
    этот подход, основанный на редукции, не слишком богат \textit{абстрактными} теоретическими результатами.\\
    \indent Как и Диксон, мы убеждены, что некоторые формальные результаты доступны даже новичку, хотя бы потому, что часто можно привести конкретную и простую иллюстрацию этих результатов. Китайская теорема об остатках, например, записанная формально, действительно может показаться абстрактной (какой-то непонятный идеал в каком-то кольце\ldots); и можно верить в ее так называемую эффективную форму до того момента, когда действительно придется использовать ее для {\textbf{вычислений}}.\linebreak Тогда переходят к менее «возвышенному» этапу, заключающемуся в изучении всех необходимых вычислений, для того, чтобы уловить все нюансы и учесть их при реализации\ldots\;В конце концов приходят, таким образом, к лучшему пониманию богатства чисел. Изучение группы обратимых по модулю $n$ элементов кажется иногда чисто алгебраическим упражнением; несколько конкретных примеров показывают, что эта группа так или иначе определяет структуру числа $n$: если имеются только два квадратных корня из 1 по модулю $n$, то $n$ — степень простого числа\ldots\;Можно указать конкретный вид этой группы, найти ее образующие, установить, что, насколько структура $\mathbb{Z}/n\mathbb{Z}$ регулярна и понятна, настолько структура группы обратимых элементов, спроектированная, как это обычно делается, на интервал $[1, n — 1]$, хаотична и сбивает с толку.\\
    \indent В противоположность некоторым понятиям, которые новичку кажутся сложными, ~— например, квадратичные вычеты, кажущаяся сложность которых обязана большей частью тому названию, которое наши предки дали квадрату (однако, слово \textit{собака} не кусается) ~— существуют очень простые понятия, доступные любому студенту, например, делители нуля в некотором кольце. Но сколько же пользы извлекли из этих особых элементов, которых старались избегать! Например, делитель нуля по модулю $n$ немедленно приводит к разложимости $n$ (благодаря, скажем, алгоритму Евклида); это является основой классических методов проверки чисел на простоту (Rabin-Miller) или вычисления квадратных корней по модулю $n\ldots$\\
    \indent В этой главе мы надеемся показать, что все эти понятия имеют простую интерпретацию, возможно, основанную на редукции, но
    позволяющую, по крайней мере, уменьшить страхи, которые мы испытываем при приближении к загадочному миру чисел.

    \epigraph {Итак, чтобы понять теорию, недостаточно констатировать, что выбранная дорога свободна от препятствий, нужно отдавать себе отчет что заставило выбрать ее. Сможем ли мы когда-нибудь сказать, что понимаем теорию, если хотим придать ей сразу окончательную форму, которую навязывает ей безукоризненная логика, чтобы не осталось никакого следа от действий наугад, которые к ней привели? Нет, в действительности мы не сможем ее понять, не сможем даже запомнить и не запомним, даже выучив наизусть.}{А. Пуанкаре, \textit{Сочинения} (1899 [161]) }
    %\cite{Schmid1978}

    \section{Кольцо $\mathbb{Z}/n\mathbb{Z}$}

    \noindent В начале этой главы мы напомним несколько основных свойств кольца $\mathbb{Z}/n\mathbb{Z}$, затем установим связь с элементарной реализацией необходимых операций для вычислений в этом кольце.

    Как принято в такого рода исследованиях, в тех случаях, когда исключена неопределенность, мы будем одинаково обозначать элемент
    кольца $\mathbb{Z}$ и его класс по модулю $n$. Если необходимо, то класс $x$ по модулю $n$ будем обозначать через $\overline{x}$ или $x \bmod n$.

    \begin{predl}
    \hspace*{0.5cm}
    Пусть $b$~— целое, а $n$~— положительное целое число. Следующие утверждения эквивалентны:

    {\bfseries a.\;} $b$ обратимо по модулю $n$,

    {\bfseries b.\;} $b$~— образующий аддитивной группы $\mathbb{Z}/n\mathbb{Z}$,

    {\bfseries c.\;} $n$ и $b$ взаимно простые.

    \end{predl}

    \begin{myproof}
    ${\bf {a \Rightarrow b}}$. Пусть $p$~— порядок $b$, тогда $pb \equiv 0\,\,(\!\!\!\mod{n})$, откуда, в силу обратимости $b, p \equiv 0\,\,(\!\!\!\mod{n})$.
    Значит, порядок $b$ делится на $n$ и, следовательно, равен $n$.\\\\
    ${\bf {b \Rightarrow c}}$. Так как $b$~— образующий, то существует $x$ такой, что $bx \equiv 1\linebreak(\!\!\!\mod{n})$, откуда $bx + kn = 1$~— равенство, являющееся соотношением Безу для $b$ и $n$.\\

    \noindent${\bf{c \Rightarrow a}}$. Запишем соотношение Безу между $b$ и $n$: $u b + v n = 1$ и рассмотрим его по модулю $n$. Коэффициент Безу $u$ и есть обратный к $b$.
    \end{myproof}
    \newpage
    Можно упростить алгоритм вычисления коэффициентов Безу и применить его для определения обратных к элементам из $\mathbb{Z}/n\mathbb{Z}$. Действительно, для этих вычислений не нужно выражать в явном виде коэффициент\linebreak Безу при $n$ и, следовательно, из алгоритма, данного во второй главе, можно исключить несколько ненужных переменных (см. алгоритм 1).

    \setcounter{lstlisting}{0}
    \begin{center}
    \begin{minipage}{0.85\textwidth}
    \begin{lstlisting}[
    mathescape=true,
    captionpos={bo},
    caption={Обращение $b$ в $\mathbb{Z}/n\mathbb{Z}$}
    ]
 $\begin{pmatrix}
    u\\
    u^{\prime}
    \end{pmatrix} \gets \begin{pmatrix}
    1\\
    0
    \end{pmatrix}; \quad \begin{pmatrix}
    r\\
    r^{\prime}
    \end{pmatrix} \gets \begin{pmatrix}
    b\\
    n
 \end{pmatrix};$
 while $r^{\prime} \ne 0$ do
    $▷\;\Nod(r, r^{\prime}) = \Nod(b, n),\ u\,b \equiv r\,\pmod{n}\;\mathrm{и}\;u^{\prime}\,b \equiv r^{\prime}\pmod{n}.$

    $q \gets r / r^{\prime};\quad \begin{pmatrix}
    u & r\\
    u^\prime & r^\prime
    \end{pmatrix} \gets \begin{pmatrix}
    0 & 1\\
    1 & -q
    \end{pmatrix}\; \begin{pmatrix}
    u & r\\
    u^\prime & r^\prime
    \end{pmatrix};$
 end while;
 $r = \Nod(b, n),\;r > 0\;\mathrm{и}\;u\,b \equiv r\; \pmod n$
 if $r = 1$ ${\textbf{then}}$
    $▷\;b$ обратимо$\;$по$\;$модулю $n$, обратное$\;u$
 else
    $▷\;b$ не$\;$обратимо$\;$по$\;$модулю $n$
 end if;
    \end{lstlisting}
    \end{minipage}
    \end{center}

    %\setcounter{algorithm}{0}
    %\begin{algorithm}
    %\caption{Обращение $b$ в $\mathbb{Z}/n\mathbb{Z}$}\label{euclid}
    %\begin{algorithmic}
    %\State $\begin{pmatrix}
    % u\\
    % u^{\prime}
    % \end{pmatrix} \gets \begin{pmatrix}
    % 1\\
    % 0
    % \end{pmatrix}; \quad \begin{pmatrix}
    % r\\
    % r^{\prime}
    % \end{pmatrix} \gets \begin{pmatrix}
    % b\\
    % n
    % \end{pmatrix};$
    %\While{$r^{\prime} \ne 0$} \Comment{$\Nod(r, r^{\prime}) = \Nod(b, n),\ u\,b \equiv r\,\pmod{n}\;\mathrm{и}\;u^{\prime}\,b \equiv r^{\prime}\pmod{n}.$}
    %\State $q \gets r / r^{\prime};\quad \begin{pmatrix}
    % u & r\\
    % u^\prime & r^\prime
    % \end{pmatrix} \gets \begin{pmatrix}
    % 0 & 1\\
    % 1 & -q
    % \end{pmatrix}\; \begin{pmatrix}
    % u & r\\
    % u^\prime & r^\prime
    % \end{pmatrix};$
    %\EndWhile; \Comment{$r = \Nod(b, n), r > 0 \mathrm{и} u\,b \equiv r\quad \pmod n$}
    % \If{$r = 1$}
    % \State \Comment{$b$ обратимо по модулю $n$, обратное $u$}
    % \Else
    % \State \Comment{$b$ не обратимо по модулю $n$}
    % \EndIf;

    %\end{algorithmic}
    %\end{algorithm}
    Отметим, что, так как $b$ положительно или равно нулю (ибо интервал $[0, n [$ представляет $\mathbb{Z}/n\mathbb{Z}$), то найденный НОД неотрицателен (и \linebreak условие проверки $r = 1$, выведенное в конце алгоритма, следовательно, \linebreak корректно).

    %(2) Следствие.
    \begin{sled}
    \hspace*{0.5cm}
    Для $n \geqslant 1$
    $$\mathbb{Z}/n\mathbb{Z}\,\,\mathrm{поле}\,\,\Leftrightarrow n\,\,\mathrm{простое}\,\,\Leftrightarrow \mathbb{Z}/n\mathbb{Z}\quad \mathrm{область\quad целостности}.$$
    \end{sled}
    Последняя элементарная операция в кольце $\mathbb{Z}/n\mathbb{Z}$~— деление двух элементов~— не всегда
    осуществима, и проблема обратимости элементов в $\mathbb{Z}/n\mathbb{Z}$ является частным случаем делимости.

    %(3) Предложение.

    \begin{predl}
    \hspace*{0.5cm}
    Пусть $a$ и $b$~— целые числа. Будем говорить, что $\overline{a}$ делится на $\overline{b}$ в $\mathbb{Z}/n\mathbb{Z}$, если существует $x$ такой, что $bx \equiv a\pmod{n};\,\overline{a}$ делится на $\overline{b}$ \linebreak тогда и только тогда, когда $a$ делится на $\Nod(b, n)$. Причем, \linebreak ${b\cdot u \dfrac {a} {\Nod(b, n)} \equiv a\pmod{n}}$, где $u$~— коэффициент Безу для $b$.
    \end{predl}

    Это предложение является следствием более общего результата, касающегося решения уравнения $bx \equiv a\pmod{n}$. Вспомним результат, доказанный в упражнении 34 главы I.

    \newpage
    %(4) Предложение.
    \begin{predl}
    \hspace*{0.5cm}
    Пусть $a$ и $b$~— два элемента из $\mathbb{Z}$.
    \begin{itemize}
    \item[($i$)] Множество $\{x \in \mathbb{Z}/n\mathbb{Z}\,|\,bx = 0\}$~— циклическая подгруппа в $\mathbb{Z}/n\mathbb{Z}$ порядка $\,|\Nod(b, n)|$, образующим этой группы является класс числа $\dfrac {n} {\Nod(b, n)}$.
    \item[($ii$)] Уравнение $bx \equiv a\,(\!\bmod\,{n})$ имеет решение тогда и только тогда, \linebreak когда а кратно $\Nod(b, n)$.
    \item[($iii$)] В этом случае частным решением будет $x_0 = u \cdot \dfrac {a} {\Nod(b, n)}$, где $u$\linebreak ~— коэффициент Безу числа b при вычислении $\Nod(b, n)$.
    \item[($iv$)] Более того, числа $x_0 \bmod \dfrac {n} {d} + k \cdot \dfrac {n} {\Nod(b, n)}$ при $0 \leqslant k < d$ образуют систему всех решений уравнения в интервале $[0, n [$.
    \end{itemize}
    \end{predl}

    Алгоритм для делимости в $\mathbb{Z}/n\mathbb{Z}$ полностью аналогичен алгоритму обратимости, если заменить конец последнего на:

    \begin{leftbar}
    \begin{lstlisting}[mathescape=true, frame=none]
 if a $\bmod\;r = 0$ then
    $▷\;b\,u \cdot \dfrac {a} {r} \equiv\;a\;\pmod{n}$
 else
    $▷\;\overline{a}$ не$\;$ делится $\;$ на$\;$ $\overline{b}\;$в$\;\mathbb{Z}/n\mathbb{Z}$
 end if;
    \end{lstlisting}
    \end{leftbar}

    %\begin{algorithm}[H]
    %\begin{algorithmic}
    %\If{$a \; \bmod\,r = 0$}
    % \LeftComment$b\,u \cdot \dfrac {a} {r} \equiv a \; (\bmod\,n)$
    %\Else
    % \LeftComment{$\overline{a} \; \mathrm{не\;делится\;на} \; \overline{b} \; \mathrm{в} \; \mathbb{Z}/n\mathbb{Z}$}
    %\EndIf;
    %\end{algorithmic}
    %\end{algorithm}

    Перейдем теперь к элементарной реализации операций в $\mathbb{Z}/n\mathbb{Z}$. Она строится на основе целых чисел
    %языка Ада
    и, следовательно, в этом случае весьма ограничена размером используемых целых чисел. Пакет, который мы собираемся частично рассмотреть, содержит, в
    принципе, все арифметические или иные операции, которые нужны при модулярных вычислениях.
    %Чтобы избежать бесполезную работу и сразу
    %получить разумное время компиляции, мы выбрали настраиваемую реализацию, параметризованную при помощи типа целых языка Ада, в
    %которой будут осуществляться промежуточные вычисления, а также целое число, по модулю которого мы хотим производить вычисления.
    Нужно отметить, что это не единственное решение для реализации используемого пакета модулярных операций. В случае, когда приходится
    часто изменять характеристику кольца (например, при использовании \textit {китайской теоремы}), может быть полезно динамически изменять эту
    характеристику перед каждой операцией. В этом случае используем пакет \textit {изменяемых} модулярных операций.

    \newpage
    \begin{lstlisting}[
    mathescape=true,
    captionpos=t,
    caption={Спецификация операций в $\mathbb{Z}/n\mathbb{Z}$},
    numbers=left,
    xleftmargin=3em,
    framexleftmargin=2.5em
    ]
#include <stdio.h>
#include <stdbool.h>

typedef int Used_Integer;
typedef int Modular_Integer; //ограничение 0...n-1 проверяется$\;$ в$\;$ функциях
Used_Integer n;

//Операции с$\;$типом Used_Integer
Used_Integer Plus (Used_Integer a, Used_Integer b);
Used_Integer Minus (Used_Integer a, Used_Integer b);
Used_Integer UnaryMinus (Used_Integer a);
Used_Integer Multiply (Used_Integer a, Used_Integer b);
Used_Integer Divide (Used_Integer a, Used_Integer b);
Used_Integer Residue (Used_Integer a, Used_Integer b);

Modular_Integer PlusModular(Modular_Integer a, Modular_Integer b);
Modular_Integer MinusModular(Modular_Integer a, Modular_Integer b);
Modular_Integer UnaryMinusModular(Modular_Integer a);
Modular_Integer MultiplyModular(Modular_Integer a, Modular_Integer b);
Modular_Integer DichotomicExponentModular(Modular_Integer, Used_Integer);
bool IsJnversible (Modular_Integer a);
Modular_Integer InverseOf(Modular_Integer a);
bool DivideModular(Modular_Integer a, Modular_Integer b, Modular_Integer *res);

char * Image (Modular_Integer Item, bool Centered);
bool Value (char * Item, Modular_Integer * res);
Modular_Integer Coerce (Used_Integer Item);
Used_Integer Lift (Modular_Integer Item; bool Centered);

\end{lstlisting}

    Язык Си не позволяет исскуственно ограничить диапазон целых чисел определенным значением, поэтому проверка этого ограничения должна присутствовать в каждой функции.
    %Ясно, что данный пакет создает новый тип (подтип типа $Used\_Integer$), позволяющий представлять целые числа по модулю n, а именно, $Modular\_Integer$, определенный в строке 16.
    Кроме различных арифметических операций, описанных в начале программы, имя которых говорит само за себя, находим в строках 25-28 примитивы внешнего представления элементов кольца. Функция $\lstinline{Image}$ выдает характеристическую последовательность, представляющую целое число, класс которого по модулю $n$ становится параметром, причем это целое число находится в интервале $[0, n [$, если второй параметр, $\lstinline{Centered}$, ложный, и в интервале $[—\lfloor n/2\rfloor, n — \lfloor n/2\rfloor [$, если $\lstinline{Centered}$ — истинный. Это позволяет, например, выдать значение $—1$ вместо $31\,415\,925$ при вычислениях по модулю $31\,415\,926$. Функция $\lstinline{Value}$ осуществляет обратное преобразование, если считать, что ее аргумент представляет целое число из интервала $[0, n [$ (при этом возвращается значение $\lstinline{true}$, а результат преобразования записывается в выходной параметр $\lstinline{res}$), если же характеристическая последовательность не соответствует этому условию, то функция возвращает значение $\lstinline{false}$. Наконец, видим функции $\lstinline{Coerce}$ и $\lstinline{Lift}$, которые позволяют переходить от типа $\lstinline{Used_Integer}$ к подтипу $\lstinline{Modular_Integer}$ и обратно. Эти функции соответствуют, выражаясь математическим языком, канонической проекции $\mathbb{Z}$ в $\mathbb{Z}/n\mathbb{Z}$ и нахождению по элементу из $\mathbb{Z}/n\mathbb{Z}$ eгo прообраза в $\mathbb{Z}$, находящегося в одном из двух обычно рассматриваемых интервалов, в зависимости от значения параметра $\lstinline{Centered}$.

    Видим также в строках 9-14 (так как это единственное место, где это возможно) переименование стандартных арифметических
    операций в тип $\lstinline{Used_Integer}$. Для этого есть причина: чтобы реализовать модулярные операции, необходимо произвести часть вычислений в типе $\lstinline{Used_Integer}$ (т.е. в $\mathbb{Z}$), а потом перевести результат в тип $\lstinline{Modular_Integer}$ (т.е. отобразить в $\mathbb{Z}/n\mathbb{Z}$). Например, алгоритм вычисления $\Nod$ применим в $\mathbb{Z}$, но, конечно, не применим в $\mathbb{Z}/n\mathbb{Z}$. Следовательно, необходимо знание стандартных операций.

    Мы не будем детально описывать реализацию тела этого пакета, это было бы довольно скучно и не интересно. Тем не менее, мы покажем
    тела некоторых функций для того, чтобы проиллюстрировать проблемы, возникающие при использовании типов целых чисел.

    Приведем сначала тело унарной функции $\lstinline{UnaryMinusModular}$:
    \begin{lstlisting}[mathescape=true, frame=none]
    Modular_Integer UnaryMinusModular(Modular_Integer a){
    	if (a == 0)
    		return a;
    	else
    		return Coerce(Minus(n, Lift(a)));
    }
    \end{lstlisting}

    Рассмотрим ветку кода \lstinline{else}.

    Поскольку функция $\lstinline{Minus}$ и $\lstinline{Lift}$. При этом функция
    $\lstinline{UnaryMinusModular}$ возвращает значение типа $\lstinline{Modular_Integer}$, поэтому конечный результат приводится к этому типу с помощью функции $\lstinline{Coerce}$.

    Рассмотрим далее тело бинарной функции \lstinline{Minus} и покажем, что в ней отсутствие конвертации между типами безопасно:
    \begin{leftbar}
    \begin{lstlisting}[mathescape=true, frame=none]
 if (a >= b) return Minus(a, b); //0 <= a - b < n
 else return Plus(a, Minus(n, b)); //0 <= n - b < n - a
    \end{lstlisting}
    \end{leftbar}

    Аналогично можно представить тело функции $\lstinline{Plus}$, которая немного сложнее вычитания. Действительно, разность двух положительных чисел есть число, меньше вычитаемого по абсолютному значению, что, очевидно, неверно для сложения.
    \begin{leftbar}
    \begin{lstlisting}[mathescape=true, frame=none]
 x = Minus(n, b); //x типа Used_Integer, ибо b может $\;$быть$\;$ равно$\;$ нулю
 if (a >= x) return Minus(a, x);
 else return Plus(a, b);
    \end{lstlisting}
    \end{leftbar}

    \renewcommand{\baselinestretch}{1.25}
    \begin{table}[h!]
    \centering
    \begin{tabular}{|rl|cccccccc|}
    \hline
    \multirow{2}{*}{$n = 8\ \left\{\vrule height 3.175ex depth 0pt width 0pt\right.\!\!\!\!\!$} & $x$ & 1 & 3 & 5 & 7 & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l|}{} \\ \cline{2-10}
    & $x^{-1}$ & 1 & 3 & 5 & 7 & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l|}{} \\ \hline
    \multirow{2}{*}{$n = 16\ \left\{\vrule height 3.1755ex depth 0pt width 0pt\right.\!\!\!\!\!$} & $x$ & 1 & 3 & 5 & 7 & 9 & 11 & 13 & 15 \\ \cline{2-10}
    & $x^{-1}$ & 1 & 11 & 13 & 7 & 9 & 3 & 5 & 15 \\ \hline
    \multirow{4}{*}{$n = 32\ \left\{\vrule height 6.175ex depth 0pt width 0pt\right.\!\!\!\!\!$} & $x$ & 1 & 3 & 5 & 7 & 9 & 11 & 13 & 15 \\ \cline{2-10}
    & $x^{-1}$ & 1 & 11 & 13 & 23 & 25 & 3 & 5 & 15 \\ \cline{2-10}
    & $x$ & 17 & 19 & 21 & 23 & 25 & 27 & 29 & 31 \\ \cline{2-10}
    & $x^{-1}$ & 17 & 27 & 29 & 7 & 9 & 19 & 21 & 31 \\ \hline
    \end{tabular}
    \caption{Обратимые по модулю $n = 8, 16, 32$}
    \label{my-label}
    \end{table}

    Что касается умножения, то проблема еще больше усложняется, так как при вычислении выражения $ a\times b\; \bmod n$ промежуточное выражение $ a\times b$ может переполнить разрядную сетку, в том числе, и для типа\linebreak $\lstinline{Used_Integer}$. Точнее, на 32-х разрядной нам гарантировано, что для значений $n$, не превышающих 46\,340, это выражение вычислимо, возможно, даже для типа, превосходящего $\lstinline{Used_Integer}$. Но 46\,340 — весьма небольшое число, и, следовательно, нужно предусмотреть какие-то обходные пути. Одна из возможностей состоит в использовании египетского умножения, изученного в главе I, но это требует выполнения большого числа модулярных сложений, которыми нельзя пренебречь (порядка 32), что очень отягощает выполнение последовательности умножений. По этой причине лучшее решение, как нам кажется, — это использование программы, написанной на языке ассемблер и, следовательно, сильно зависящей от конкретной машины (мы не будем углубляться в детали этой программы).\\\\
    {\textbf{Применение}}

    Этот пакет может быть использован, например, для написания программы вычисления обратимых по модулю $n$. В таблице 1 представлена группа обратимых по модулю 8, 16 и 32..

    Заметим, что порядок группы обратимых элементов кольца $\mathbb{Z}/2^n\mathbb{Z}$ равен половине его порядка. Все элементы этого кольца делятся на два класса: элементы \textit{нечетные}, которые обратимы, и \textit{четные}, которые необратимы.

    Можно также заметить, что в каждой из этих групп обратимых есть точно четыре элемента, которые равны своему обратному. По крайней мере два из них отличны от 1 и —1, откуда сразу следует, что группа обратимых не циклична (это было бы не так, если заменить 2 на простое нечетное число).

    Рассмотрим подробнее элемент 5. Он сравним с 1 по модулю 4. Нетрудно показать, что если $x \equiv y \pmod{n}$ и 2 делит $n$, то
    $x^2 \equiv y^2 \pmod{2n}$. Следовательно, $5^2$ сравнимо с 1 по модулю 8 и в $U(\mathbb{Z}/8\mathbb{Z})$, элемент 5 имеет порядок 2. Кроме того, $5 \equiv 1 + 4 \pmod{8}$, сравнение, которое понадобится нам позже. Переходя к $U(\mathbb{Z}/16\mathbb{Z})$ и используя предыдущие рассуждения получим, что $5^4$ сравнимо с 1 по модулю 16, а значит, 4 делится на порядок 5. Но второе сравнение по модулю 8, возведенное в квадрат, дает $5^2 \equiv 8 + 1 \pmod{16}$, откуда 5 имеет порядок 4. Для $U(\mathbb{Z}/32\mathbb{Z})$ также можно возвести в квадрат оба сравнения, \textit{полученные} в $U(\mathbb{Z}/16\mathbb{Z})$. Получаем $5^8 \equiv 1 \pmod{32}$ и $5^4 \equiv 16 + 1 \pmod{32}$, откуда 5 {\textbf{имеет}} порядок 8 в $U(\mathbb{Z}/32\mathbb{Z})$. Можно показать, что в $U(\mathbb{Z}/2^n\mathbb{Z})$ элемент 5 порождает подгруппу порядка $2^{n-2}$. Следовательно, эта подгруппа содержит половину обратимых элементов (это те же элементы, которые сравнимы с 1 по модулю 4) и нетрудно проверить, что вторая половина (элементы, сравнимые с 3 по модулю 4) состоит из элементов, противоположных к элементам этой подгруппы. Это рассуждение полностью описывает структуру группы $U(\mathbb{Z}/2^n\mathbb{Z})$~— она является прямым произведением группы порядка 2, порожденной — 1, и группы порядка $2^{n-2}$, порожденной 5.

    \section{Китайская теорема об остатках}

    \noindent Мы уже бегло ознакомились с китайской теоремой об остатках в главе III, где применяли ее для получения нормализованной формы произведения двух циклических групп. На самом деле это основной инструмент, используемый в {\textbf{модулярном исчислении}}. Существует много методов для проведения вычислений с большими целыми числами, однако, два наиболее пригодных — это позиционная нумерация и модулярное исчисление. Позиционная нумерация заключается в разложении чисел, с которыми оперируют по основанию $b$, и если действия над цифрами основания легко выполнить, то достаточно просто произвести и действия, которые были необходимы. Модулярное исчисление состоит в осуществлении нескольких малых вычислений по модулям взаимно простых чисел (чаще просто простых чисел) и получении необходимого результата при помощи теоремы об остатках. Например, если мы хотим перемножить два положительных числа $x$ и $y$, то \textit{выбираем} $n$ различных простых чисел $p_i$ так, чтобы $\prod\nolimits p_i > xy$, и берем числа $x$ и $y$ по каждому из модулей $p_i$, что дает числа $x_i$ и $y_i$. Далее вычисляем произведение $x_i$ и $y_i$ в $\mathbb{Z}/p_i\mathbb{Z}$ и получаем числа $z_i$. Китайская теорема об остатках позволяет восстановить $z = xy$ при помощи вычисленных $z_i$. Перейдем к изучению китайской теоремы об остатках и ее применений.

    \sectiontop
    \subsection{Различные формы китайской теоремы об остатках}
    \noindent Напомним сначала формулировки этой теоремы, данные в главе III.
    %(5) Китайская теорема об остатках (для двух элементов).
    \begin{thm}[Китайская теорема об остатках (для двух элементов)]
    \hspace*{0.5cm}
    Пусть $n$ и $m$ — два взаимно простых целых числа.
    \begin{itemize}
    \item[($i$)]Пусть $y$ и $z$ — два произвольных целых числа. Тогда система

    \[
    \left\{
    \begin{aligned}
    x &\equiv y \,(\bmod\,n),\\
    x &\equiv z \,(\bmod\,m)
    \end{aligned}
    \right.
    \]
    имеет по крайней мере одно решение. Кроме того, если $x^\prime$~— другое решение этой системы, то $x \equiv x^\prime (\bmod\,n\,m)$.

    \item[($ii$)] Отображение $\varphi$ множества $\mathbb{Z}$ в $\mathbb{Z}/n\mathbb{Z} \times \mathbb{Z}/m\mathbb{Z}$, которое каждому $x$ ставит в соответствие его классы по модулю $n$ и $m$: $\varphi (x) = \linebreak= (x\, \bmod\,n, x\,\bmod\,m)$, сюрьективно и его ядро $n m \mathbb{Z}$. Следовательно, оно индуцирует изоморфизм $\mathbb{Z}/nm\mathbb{Z}$ и $\mathbb{Z}/n\mathbb{Z} \times \mathbb{Z}/m\mathbb{Z}$.

    \item[($iii$)]Пусть $u$ и $v$~— соответствующие коэффициенты Безу для $n$ и $m$. Тогда морфизмы
    \[\varphi
    \left\{
    \begin{aligned}
    \mathbb{Z} &\to
    \mathbb{Z}^2,\\
    x &\mapsto (x, x)
    \end{aligned}
    \right. \quad \mathrm{и} \quad \psi\left\{
    \begin{aligned}
    \mathbb{Z}^2 &\to \mathbb{Z},\\
    (y, z) &\mapsto z\,u\,n + y\,v\,m
    \end{aligned}
    \right.
    \]
    индуцируют взаимно обратные кольцевые изоморфизмы $\mathbb{Z}/nm\mathbb{Z}$ и \linebreak $\mathbb{Z}/n\mathbb{Z} \times \mathbb{Z}/m\mathbb{Z}$. Впрочем, это единственные кольцевые изоморфизмы между этими двумя структурами.

    \item[($iv$)]Пусть $A$~— коммутативное кольцо с единицей, а $I$ и $J$~— такие идеалы $A$, что $I + J = A$. Пусть $i$ и $j$~— такие элементы из $I$ и $J$, что $i + j = 1$. Тогда произведение $IJ$ равно $I \cap J$ и отображения $\varphi:A \to A/I \times A/J$ и $\psi: A \times A \to A$, определенные по правилам $\varphi(x) = (x\,\bmod\,I, x\,\bmod\,J)$ и $\psi(y, z) = jy + iz$ для $x, y$ и $z$ из $A$ индуцируют взаимно обратные изоморфизмы колец $A/IJ$ и $A/I \times A/J$.
    \end{itemize}
    \end{thm}

    \begin{myproof}
    Мы докажем только наиболее общую форму теоремы (iv). Все остальные получаются из нее при помощи нескольких простых действий.\\
    Очевидно, $IJ \subset I \cap J$. Пусть $x$ принадлежит $I$ и $J$. Тогда $jx + ix = x$ принадлежит $IJ$, ибо каждое слагаемое принадлежит $IJ$.\\
    Можно заметить, что ядро $\varphi$ есть $I \cap J = IJ$. Так как $\varphi$ сюръективно (прообраз пары ($\overline y, \overline z$) есть $yj + zi$), то $\varphi$ является изоморфизмом соответствующих фактор колец.\\
    Ядро $\psi$ равно $I \times J$. Действительно, $jy + iz \equiv y \pmod I, jy + iz \equiv z \pmod J$\,и, следовательно, если $jy+iz \in IJ$ (в частности, $jy+iz = 0$), то $y \in I$ и $z \in J$. Поэтому $\psi$ переводит фактор кольца, указанные в условии, одно в другое и при этом является сюръективным и инъективным. Итак, $\psi$ также изоморфизм. \\
    Осталось доказать, что эти изоморфизмы взаимно обратные; это делается довольно просто: $\varphi(\psi(y, z)) = (\overline{yj}, \overline{zi}) = (\overline{y}, \overline{z})$, поскольку $i \equiv 1 (J)$ и $j \equiv 1(I)$.
    Из этого доказательства легко получить обоснования остальных утверждений теоремы.
    \end{myproof}


    \begin{beznomera}[{\textbf{Пример}}]
    \hspace*{0.5cm}
    Рассмотрим два числа: $n = 19\,687$ и $m = 17$. Оба эти числа простые и соответствующие им коэффициенты Безу $u = I$ и $v = —1158$. Произведение $n$ и $m$ равно 334\,679. Для данных $у$ и $z$ система
    \[
    \left\{
    \begin{aligned}
    x &\equiv y\,\pmod{19\,687},\\
    x &\equiv z\,\pmod{17}
    \end{aligned}
    \right.
    \]
    имеет решение $-1158 \times 17 \times у + 19\,687 \times z$. Если, например, $у = 18\,000$ и $z = 13$, то применяя данную формулу, находим решение $—354\,092\,069$. Можно взять это число по модулю $334\,679$ и получим $x = 332\,992$; другие решения системы могут быть получены добавлением к $х$ чисел, кратных $334\,679$. Следует отметить, что, несмотря на то, что искомое число мало́ $($лежит в интервале $[0, 334\,679 [)$, вычисления вызвали появление чисел в тысячи раз больших, чем размер рабочего интервала.\quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \qedsymbol

    Это достаточно общее явление и показывает просто, что описанный изоморфизм, хотя и точно определен, не позволяет эффективно решать системы сравнений. Необходимо найти такие формулы, которые позволяют решать сравнения, не выходя за пределы интервала $[0,n\,m [$.
    \end{beznomera}

    \begin{bezpodpisi}[\textbf{Вычислительные формулы}]
    \hspace*{0.5cm}
    Пусть $n$ и $m$~— два взаимно простых числа и $u$~— элемент из \{$1,\ldots,m — 1$\}, представляющий обратный к $n$ по модулю $m$. Если $y$ и $z$~— целые числа, принадлежащие соответственно интервалам $[0, n [$ и $[0, m [$, то вычисление
    $$ x = n ( u (z — y) \bmod\,m) + y$$
    дает единственное целое число из интервала $[0, nm [$, удовлетворяющее сравнениям $x \equiv y\,\,(\!\!\!\mod{n})$ и $x \equiv z\,\,(\!\!\!\mod{m})$. Кроме того, все необходимые вычисления в этом
    выражении по абсолютному значению меньше $n\,m$.
    \end{bezpodpisi}

    \begin{myproof}
    Достаточно взять формулу китайской теоремы об остатках и заменить $vm$ на $1 — un$. Тогда получим $x = nu(z — y) + y$. Так как все решения получаются из $x$ прибавлением кратных $nm$, то находим анонсированную формулу и все ее промежуточные вычисления приемлемы. Действительно,

    $$ x = n(u(z — y) \bmod m) + y \leqslant n(m — 1) + n — 1 = nm — 1. $$
    \end{myproof}

    \begin{beznomera}[\textbf{Пример (продолжение)}]
    \hspace*{0.5cm}
    Снова рассмотрим предыдущий пример, в котором промежуточные вычисления вызывали появление \textit{больших} чисел.

    Исходные данные: $n = 19\,687, m = 17, u = 1, y = 18\,000$ и $z = 13$. Сначала подсчитаем $u(z - y)\,\mod\,m = (13 - 18\,000)\!\mod\,17 = 16,$ умножаем это на $n$ и прибавляем $y$. Получаем
    $$x = 19\,687 \times 16 + 18\,000 = 332\,992,$$
    что и является искомым решением.
    \end{beznomera}

    \begin{thm}[Китайская теорема об остатках (для $r$ элементов или $r$\\ идеалов)]
    \hspace*{0.01cm}
    \begin{itemize}
    \item[($i$)] Пусть А ~— кольцо главных идеалов и $n_1, n_2, \times, n_r$~— попарно взаимно простые элементы А. Тогда
    $$\prod\limits_{i=1}^{r} A/(n_i) \simeq A/(\prod\limits_{i=1}^{r} n_i).$$
    Это означает, говоря иначе, что всякая система сравнений по модулям $n_i$ имеет единственное решение по модулю $\prod n_i$.

    \item[($ii$)]Пусть A ~— коммутативное кольцо с единицей и $I_1, I_2, \ldots, I_r$ ~— такие идеалы А, что для любых $i \ne j\,\,I_i + I_j = A$. Тогда:

    {\bfseries a.\;} $\cap_{i = 1}^{r} I_i = \prod\nolimits_{i=1}^{r}I_i,$\\
    {\bfseries b.\;} Отображение $\varphi$ из $A$ в $A/I_1 \times \ldots \times A/I_r$, которое каждому элементу А ставит в соответствие его смежный класс по идеалу $I_i$, является сюръективным гомоморфизмом колец с ядром $\prod I_i$ и индуцирует изоморфизм колец $A/\prod I_i$ и $\prod A/I_i$.
    \end{itemize}
    \end{thm}

    \begin{myproof}
    Докажем сначала ($i$). Пусть $\pi$ ~— канонический гомоморфизм $А$ на $A/(\prod n_i)$, а $\pi_i$~— канонический гомоморфизм $A$ на $A/(n_i)$. Тогда для канонического гомоморфизма $\varphi A/(\prod n_i)$ на $A/(n_i)$ выполняется $\pi_i = \varphi_i \circ \pi$, так как $\Ker \pi \subset \Ker \pi_i$. Следовательно, существует гомоморфизм $\varphi A/(\prod n_i)$ \linebreak на $\prod A/(n_i)$.\\
    Положим $\prod_i = \prod\nolimits_{i \ne j}n_j = \dfrac {\prod n_j} {n_i}$. Числа $\prod_i$ взаимно просты в совокупности (ибо $n_i$ попарно взаимно просты), и следовательно, существуют числа $q_i$ такие, что $\sum q_i \prod\nolimits_i = 1$.\\
    Применяя несколько раз китайскую теорему об остатках для двух элементов, получим, что гомоморфизм $\varphi$ инъективен. В самом деле, если для каждого $i\,a \equiv b (\bmod\,n_i)$, то $a \equiv b\;(\bmod\,\prod n_i)$.\\
    Кроме того, если $(a_1, \ldots, a_r) \in \prod A/ (n_i)$, то $a = \sum\prod_i q_i a_i$~— решение системы сравнений.

    \noindent ($ii$) Для пункта а заметим, что если $I + J = A$ и $I + K = A$, то $I + JK = A$ (рассмотреть произведение). Осталось применить результат, доказанный для двух идеалов в предложении 5. Доказательство пункта b полностью аналогично доказательству пункта$\;(i)$.
    \end{myproof}

    \begin{sled}
    \hspace*{0.5cm}
    Пусть $n_1, n_2, \ldots, n_r$~— попарно взаимно простые элементы \linebreak $\mathbb{Z}$ и $n = n_1n_2\ldots n_r$.\;Тогда
    $$U(\mathbb{Z}/n\mathbb{Z})\quad \simeq \quad U(\mathbb{Z}/n_1\mathbb{Z}) \times \ldots \times U(\mathbb{Z}/n_r\mathbb{Z}),$$
    где $U(A)$ обозначает группу обратимых элементов кольца $A$.
    \end{sled}

    Формулы, позволяющие эффективно решать системы $r$ сравнений, есть лишь обобщение соответствующих формул для двух модулей. Применяем эти формулы для двух чисел $n_1$ и $n_2$, затем для $n_1n_2$ и $n_3$ и т.д. В действительности привыкнуть к новым обозначениям даже труднее, чем понять формулы сами по себе.

    \begin{bezpodpisi}[\textbf{Вычислительные формулы}]
    \hspace*{0.5cm}
    Пусть $n_1, n_2, \ldots, n_r$~— попарно взаимно простые целые числа. Тогда решение системы сравнений $x \equiv x_i\,(\!\!\mod n_i)$ находится из последовательности вычислений:
    \[
    \left\{
    \begin{aligned}
    y_1 &= x_1\,\bmod\,n_1,\\
    y_2 &= N_2(C_2(x_2 - y_1)\,\bmod\, n_2) + y_1,\\
    y_3 &= N_3(C_3(x_3 - y_2)\,\bmod\, n_3) + y_2,\\
    &\vdots\\
    y_r &= N_r(C_r(x_r - y_{r-1})\, \bmod\, n_r) + y_{r-1},
    \end{aligned}
    \right.\eqno{(1)}
    \]
    в которой $N_i = \prod_{j<i}n_j$, коэффициенты $C_i$ удовлетворяют условиям \linebreak $C_iN_i \equiv 1\;(\!\!\mod n_i)$ и получены при помощи алгоритма Евклида для $N_i$ и $n_i$. При этих условиях число $y_r$, являющееся последним членом последовательности, будет единственным решением системы сравнений на интервале $[0, n_1 \ldots n_r [$.
    \end{bezpodpisi}
    {\slshape{Нужно отметить, что первые $k$ строк в (1) определяют решение системы сравнений $x \equiv x_i\,(\!\!\mod n_i)$ для $i \leqslant k$.}}

    Теперь можно построить алгоритм решения системы сравнений, реализующий приведенные выше вычисления (алгоритм 2).
    \setcounter{lstlisting}{1}
    \begin{center}
    \begin{minipage}{0.85\textwidth}
    \begin{lstlisting}[
    mathescape=true,
    captionpos={bo},
    caption={Китайская теорема об остатках для $\mathbb{Z}$}
    ]
 $n_1, n_2, \ldots, n_r$ попарно$\;$взаимно$\;$простые$\;$целые$\;$числа
 $x_1, x_2,\ldots, x_r$ целые$\;\mathrm{числа}$
 $\mathrm{Числа}\;C_i$ таковы,$\;$что $C-iN_i \equiv 1 (\bmod\,n_i)$
    $y \gets x_1; p \gets 1;$
    for $k\;\textbf{in}\;2 .. r$$\quad▷\;\forall_i \in [1, k[, y \equiv x_i\,(\bmod\,n_i),\;\mathrm{и}\; y \in [0, n_1 \ldots n_{k-1}[$
       $p \gets p \times n_{k-1}; y \gets p \times [C_k \times (x_k - y)\,\bmod\,n_k] + y;$
    end for;
 $\;▷\;y\;$ удовлетворяет$\;$условию$\;y \equiv x_i\,(\bmod\,n_i)\;\mathrm{и}\;y \in [0, n_1\,n_2 \ldots n_r[.$
    \end{lstlisting}
    \end{minipage}
    \end{center}

    %\begin{algorithm}
    %\begin{algorithmic}
    %\State $n_1, n_2, \ldots, n_r$ попарно взаимно простые целые числа
    %\State $x_1, x_2,\ldots, x_r$ целые числа
    %\State Числа $C_i$ таковы, что $C-iN_i \equiv 1 (\bmod\,n_i)$
    %\Begin??????????????????????????????????/////??????????????????????
    % \State $y \gets x_1; p \gets 1;$
    % \For $k\;\textbf{in}\;2 .. r$ \Comment $\forall_i \in [1, k[, y \equiv x_i\,(\bmod\,n_i),\;\mathrm{и}\; y \in [0, n_1 \ldots n_{k-1}[$
    % \State $p \gets p \times n_{k-1}; y \gets p \times [C_k \times (x_k - y)\,\bmod\,n_k] + y;$
    % \EndFor;
    %\End; \Comment $y$ удовлетворяет условию $y \equiv x_i\,(\bmod\,n_i)\;\mathrm{и}\;y \in [0, n_1\,n_2 \ldots n_r[.$
    %\end{algorithmic}
    %\end{algorithm}
    \subsection{Модулярная арифметика и смешанная система \\счисления}

    \noindent Согласно китайской теореме об остатках для попарно взаимно простых чисел $n_1, n_2, \ldots, n_r$ имеются формулы, позволяющие кодировать любое число из интервала $[0, n [$ $r$-й чисел из $[0, n_1 [\times \ldots \times [0, n_r [$. Если каждое из чисел $n_i$, можно ввести в машину и обычные операции кольца $\mathbb{Z}/n_i\mathbb{Z}$ также могут быть реализованы на этой машине, то мы располагаем арифметикой на интервале $[0, n [$, определенной следующим образом:

    \begin{align*}
    0&\simeq(0,\ldots, 0),\quad 1 \simeq(1, \ldots, 1),\\
    x&\simeq(x \bmod n_1, \ldots, x \bmod n_r),\\
    (x + y) \bmod n &\simeq ((x + y) \bmod n_1, \ldots, (x + y) \bmod n_r),\\
    (x - y) \bmod n &\simeq ((x - y) \bmod n_1, \ldots, (x - y) \bmod n_r),\\
    xy \bmod n &\simeq (xy \bmod n_1, \ldots, xy \bmod n_r),\\
    xy^{-1} &\simeq (xy^{-1} \bmod n_1, \ldots, xy^{-1} \bmod n_r).
    \end{align*}
    В последнем выражении $y^{-1}$ обозначает обратное к $y$ по модулю $n, n_1, \ldots ,n_r$. Понятно, что $y$ предполагается обратимым.

    Разумеется, речь идет об арифметике по модулю $n$. Однако, если оперировать с целыми числами из этого интервала и удается доказать, что полученный результат также лежит в этом интервале, то этот результат точен.
    %\arabic{section}

    Деление имеет, между прочим, особый статус. Если $y$ делит $x$ в $\mathbb{N}$, то $xy^{-1} \mod n$ и $x/y$ сравнимы по модулю $n$, и, следовательно, равны, так как они оба лежат в интервале $[0, n [$.

    Итак, видим, что все арифметические действия на интервале $[0, n [$ \linebreak соответствуют, благодаря китайкой теореме об остатках, аналогич-\linebreak

    %\begin{thebibliography}{999}
    %\bibitem{Carrol1982} CARROLL L. The complete illustrated works, Chancellor Press, 1982.
    %\bibitem{Dixon1974} DlXON J.D. ``Factorization and primality tests'', Amer. Math. Monthly, vol. 91, 1974, pp. 333-352.
    %\bibitem{Schmid1978} SCHMID A.F. {\emph Une philosophic de savant, Henri Poincaré et la logique mathématique,} François Maspero, 1978.
    %\end{thebibliography}

    \end{document}