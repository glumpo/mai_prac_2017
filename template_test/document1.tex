\documentclass{mai_book}
\defaultfontfeatures{Mapping=tex-text}

\setdefaultlanguage{russian}


\begin{document}
%	\newtop{LOL}
	\section{Введение в алгоритмику}
	
	\begin{beznomera}
	Lol
	\end{beznomera}
	
	predl
	
	
	Прежде чем приступить к описанию любого алгоритма, нужно ого­
	ворить общепринятые соглашения, используемые в работе. В инфор­
	матике чаще, чем в любой другой дисциплине, встречается взаимное
	непонимание между пользователем и разработчиком новых программ.
	Поэтому так важно сформулировать аксиоматику, позволяющую связ­
	но рассуждать об алгоритмах.

	Множество аксиом, которое мы собираемся сейчас описать, извест­
	но как аксиоматика Хоара [86], в честь исследователя, который первым
	формализовал семантику структур и действий последовательной алго-
	ритмики.

	\subsection{Терминология и обозначения}
	
	А л г о р и т м — это последовательность более или менее элементарных
	действий, которая позволяет пошагово решить поставленную задачу за
	конечное время. Можно формально по индукции определить, что та­
	кое алгоритм, нижеследующим образом. Цель этого введения в алго­
	ритмику — изучение и представление всех терминов, фигурирующих в
	предыдущем определении (стиль определения, который в информатике
	называется гр а м м а ти к ой ).
	Можно описать алгоритм в терминах состояний системы: состояние
	системы до применения алгоритма, состояние той же системы после
	
	\pagebreak
	
	применения алгоритма. Эти два состояния образуют то, что называет­
	ся спецификацией задачи. Таким же образом можно, описывая поэ-
|--------------------------------- тапно последовательные состоя-
|• Алгоритм — это действие       | ния (между действиями) рассма-
|• Действие — это:               | триваемой системы, проводить
|— элементарное действие         | обоснование алгоритма. Систе-
|— последовательность действий   | ма доказательства по Флой-  
|— альтернатива                  | ду [71] — это способ формализа-
|— итерация                      | ции данного процесса. Но эта ак-
|•  Элементарное действие — это: | сиоматика не просто метод дока-
|—  пустое действие              | зательства: в случае ее обобще-
|— присваивание  — ...           |ния  она может претендовать  на роль
|--------------------------------- хорошей  методологии програм­
мирования.
\parindent=1cm Состояния данной  системы  выражаются  в  виде 
утверждений,т.е. логических   формул. Рабочие гипотезы алгоритма называются 
предусловиями или данными алгоритма.  Заключения  называются постусловиями 
или результатами. Вот,   например,   способ формального описания алгоритма:

				      [предусловия] Алгоритм [постусловия]
\section{LOL}
И это то, что можно назвать спецификацией алгоритма. Используя 
данную форму выражений, можно описать аксиомы Хоара в следующем 
виде:
$\vartriangleright$ Посылки : предварительные условия к применению аксиомы. Эти 
условия  выражаются,  в  основном,  в  терминах  преобразований  утвер­
ждений посредством некоторых действий.
$\vartriangleright$ Заключение : результат построения, которым описывают аксиому.
\subsection{Присваивание}
Это элементарное  действие,  наиболее опасное  и  наиболее трудное  для 
понимания  в  последовательных  алгоритмах.  Его  семантика  чрезвы­
чайно  проста:  переменной  (иногда очень  сложной)  придают  значение 
какого-либо выражения.  Действие  присваивания  представляется  в  ал­
горитмах, как правило, двумя способами: обычно с помощью стрелки, 
направленной  влево,  а  иногда  последовательностью  знаков  «:=»,  как, 
например, в языках программирования.
\textbf{(1) Аксиома} (присваивания).
$\vartriangleright$ \textit{Посылки: х является переменной,  e  —  выражением}
$\vartriangleright$ \textit{Заключение: [] х $\leftarrow$ е [x = значению е]}
\pagebreak

\parindent=1cm Интерпретация  этой  аксиомы  следующая:  нет  никакого  предусло­
вия,  кроме  природы  его  операндов,  для  использования  присваивания. 
Каково  бы  ни  было состояние  системы,  сведенной  к  переменной х,  по­
сле выполнения присваивания х будет иметь то же самое значение,  что и е.
\parindent=1cm Если задействовано несколько переменных,  то иногда форму посту­
словия  присваивания  модифицируют.  Возьмем,  например,  систему,  со­
стоящую  из  двух  переменных х  и у,  предположим  к  тому  же,  что у
имеет значение  е.  Выполним предыдущее  присваивание. В предусловие 
можно включить  переменную у,  хотя она не  входит в присваивание.  В 
результате  имеем:  [у =   е].  Довольно часто  вместо  того,  чтобы писать 
постусловие  в  виде  [у =   е  и х  =   е],  запись  сокращают  до  [х  =   у], 
 что, разумеется,  приводит  к  исчезновению  некоторой  начальной  информа­ции.
\parindent=1cm Все  это  может  показаться  тривиальным,  и  обычно  совершаемая 
ошибка  состоит  в  смешении  присваивания с  частной  формой  записи 
уравнений (в математическом смысле)  или подстановкой. Простой при­
мер,  иллюстрирующий  трудность  проблемы,  относится  к  системе  из 
двух переменных  и  предыдущему  условию
\begin{equation}
\textit{$[\Re(x,n)] n \leftarrow n + 1 [\Re(x,n - 1)]$}
	\end{equation}
где $\Re$ - отношение,  связывающее соответствующие значения двух его 
аргументов.
\subsection{Последовательность}
Это  алгоритмическая конструкция,  заключающаяся  в соединении  дей­
ствий  в цепочку.  Ее часто представляют с помощью знака «;», который 
служит связкой  между  последовательными  действиями.  Э та конструк­
ция самая простая среди тех, которые встречаются в последовательных 
алгоритмах.
\parindent=1cm Если А и В — действия,  то обозначим  через  «А;В» действие, со­
стоящее из последовательности действий А и В в данном порядке. Э та 
горизонтальная запись обладает некоторыми неудобствами, так что 
очень часто ту же последовательность действий записывают, распола­
гая вертикально на одной прямой действия одной и той же последова­
тельности (и аннулируя, в случае необходимости, знак «;»).
\newline
\textbf{(2) Аксиома} (последовательности).
\newline
$\vartriangleright$ \textit{Посылки: А и В --- действия, P, Q и R} --- утверждения
\textit{$                            [ P ] A [ Q ]  и [Q] B [ R ]$}
\pagebreak
$\vartriangleright$ \textit{Заключение:  [Р] А; В[Р]}
\newline
\parindent=1cm Эта  аксиома  просто  выражает  тот  факт,  что  в  последовательно­
сти двух действий  предусловие  второго является  постусловием  перво­
го. Иными словами, два действия одной и той же последовательности, 
следующие  одно за другим,  действуют  совместно.  Второе  использует 
результаты первого.
\parindent=1cm Вот очень простой пример, позволяющий конкретизировать преды­
дущее  высказывание.  Рассмотрим систему,  образованную тремя цело­
численными переменными: \textit{C, x} и \textit{n}, и предположим, что эти перемен­
ные удовлетворяют следующему свойству (которое будет предусловием 
этой последовательности):\textit{$[C\times x^{n} = x_{0}^{n_{0}}]$}, где \textit{$x_{0}$} и \textit{$n_{0}$} --- две це-
лочисленные константы. Последовательность действий,  которую  при­
меняют  к  этой  системе,  представлена  справа.  Пре­
образуем сначала исходное утверждение,  используя тот 
факт, что n > 0 и \textit{$[C\times x^{n-1} \times x = x_{0}^{n_{0}}$} и n > 0 ], и применим
первое  действие  последовательности,  придав С значение,  полученное 
при умножении его начального значения  на х.Это выражается  в пре­
дыдущем утверждении  слиянием двух первых термов левого члена ра­
венства: \textit{$[C\times x^{n-1} = x_{0} и n > 0]$}. Потом, рассматривая это новое утвер­
ждение как  предусловие,  применим  второе действие, которое состоит 
в уменьшении значения п на единицу.
\parindent=1cm Таким образом, получаем постусловие  рассматриваемой последова­
тельности действий \textit{$[C\times x^{n} = x_{0}^{n_{0}} и n \geqslant 0]$}. Это последнее преобразова­
ние является примером типичного случая, упомянутого в конце преды­
дущего раздела.

\subsection{Альтернатива}
Альтернатива — это структура управления,  соответствующая  приня­
тию решения в алгоритме. Ее часто выражают в виде «если ...  т о  ...». 
Во всех алгоритмах, представленных в книге, структуры управления и 
примитивные конструкции будут записаны на английском языке, в ви­
де схем, близких к языку Ада.  Этот прием имеет два важных преиму­
щества: во-первых, алгоритмы пишутся на алгоритмическом диалекте, 
приближенном к языку  программирования; и потом,  выбранный язык 
Ада чрезвычайно точен  (небольшой эвфемизм!)  и достаточно понятен 
для записи алгоритмов.
\parindent=1cm Нет необходимости объяснять действие структуры  управления.  Ее 
семантика тождественна семантике, используемой в разговорном языке.
\newline

\textbf{(3) Аксиома} (Альтернатива).
\newline
$\vartriangleright$ \textit{Посылки: А и В --- действия; С --- предикат, P и Q --- условия.}
\textit{                            [ P и С] A [ Q ]  и [Р и (не С)] B [ Q ]}
\pagebreak
\newline
$\vartriangleright$ \textit{Заключение:  \textbf{if} \textit{C} \textbf{then} \textit{A} \textbf{else} \textit{B} \textbf{end if}} [ Q ]
\newline
Прежде всего эта аксиома выражает тот факт, что какова бы ни 
была  ветвь  используемого  теста\footnote{ Ветвью теста называют каждую часть альтернативной структуры: часть «то*
или часть «в  противном случае»}, получаем  один  и  тот  же  результат 
(благодаря разделению действий А и В).
\parindent=1cm Если продолжить анализ, то из этой аксиомы можно извлечь некото­
рую философию  (или  методологию)  программирования.  В  самом деле, 
можно субъективно объяснить такой подход и сделать вывод, что хоро­
шая альтернативная структура (т.е. альтернатива, простая для понима­
ния доказательства)  — это конструкция, в которой действия,  предста­
вленные  в каждом  из  ответвлений, очень  похожи.  Не редко,  например, 
можно  встретить  в  программах  начинающих,  а  также  в  работах лю­
дей  более  опытных  (что  красноречиво  свидетельствует  об  их опыте!) 
альтернативные структуры, в которых в зависимости от того, является 
истинным или ложным предикат, совершается вычисление с внутренни­
ми переменными  или выполняется действие  с промежуточным резуль­
татом (обычно на экран выводится сообщение). Конечно, эти програм­
мы  могут  быть  правильными  и,  следовательно,  вполне  доказуемыми, 
но  ценой  каких  искажений  в  изложении  алгоритма  и  в  формулиров­
ках  утверждений!  Не  говоря  уже  о  том,  какой  будет через  несколько 
месяцев степень понятности программы этого программиста! Зато хо­
роший алгоритм не содержит особенностей, сопровождается простыми 
и ясными утверждениями и потребует намного меньше затрат во время 
его возможной доработки.
\parindent=1cm В качестве примера рассмотрим следующую альтернативу, предста­
вляющую  небольшую  часть  дихотомического  алгоритма возведения  в 
степень,  который мы рассмотрим в дальнейшем.  Возьмем снова систе­
му, состоящую из трех целочисленных переменных С, х и n, удовлетво­
ряющую условию:
\begin{equation}
 \textit{$[C\times x^{n} = x_{0}^{n_{0}} $ и $ n > 0]$}                 
\end{equation}
Исходя  из  этой  системы  переменных,  применим  нижеследующий  эле­
ментарный   алгоритм,   который   в  основном  записывают  в   виде:
$\textbf{if} \textit{n нечетно} \textbf{then} \textit{C} := \textit{C} \ast \textit{x}; \textbf{end if};  Ключевое слово \textbf{null}$
\pagebreak
является  примитивом  алгоритмического  языка, 
выражающим  пустое  действие  (для  структура­
листов  это  действие  является  нейтральным  эле­
ментом  ассоциативной  операции  последователь­
ной композиции). Семантика пустого действия та­
кова (для любого утверждения Р):  [Р]  \textbf{null} [Р].
\parindent=1cm Итак, необходимо отдельно исследовать влияние действий каждой 
из двух ветвей теста на исходное утверждение, учитывая значение пре­
диката «n нечетно». Сначала можно записать: \textit{n = 2q + г}, деление с
остатком \textit{n} на 2; \textit{q} --- это неполное частное, а \textit{r} --- остаток. Когда \textit{n}
и \textit{p} --- целые числа удобно обозначить через n/р неполное частное  от 
деления с остатком \textit{n} на \textit{p} и через \textit{n mod p} --- остаток при этом делении; 
учитывая вышесказанное,  получаем: \textit{n = 2(n/2) + т mod 2}. Кроме того, 
значение \textit{n mod 2} выражает четность \textit{n}. Исходное  утверждение  может 
быть преобразовано в
\begin{equation}
\textit{$[C\times x^{2(n/2)+n mod 2} = x_{0}^{n_{0} и n > 0]}$}                
	\end{equation}
Теперь рассмотрим две ветви альтернативы. Если \textit{n} нечетно, то \textit{n mod} 
2 равно 1 и исходное утверждение переписывается в виде: [$C \cdot x \cdot x^{2(n/2)}=$
$x_{0}^{n_0}$ и n > 0] --- выражение,  которое легко преобразуется  после приме­
нения  действия $C \leftarrow C \cdot x$ в
\begin{equation}
[C \cdot x^{2(n/2)} = x_0^{n_0} и n > 0].
\end{equation}
Аналогичным образом, если \textit{n} четно, то 
\textit{n mod 2} равно 0 и без  всякого 
преобразования утверждение  (2)  становится тождественным  (3).
\parindent=1cm Итак, утверждение (1) преобразуется с помощью алгоритма в утвер­
ждение  (3)  при любом значении  предиката «n  нечетно».
\parindent=1cm В примере, рассмотренном выше, и в исследовании последовательно­
сти,  представленной в предыдущем  разделе,  мы  всегда начинали  дока­
зательство с преобразования исходного утверждения. Преобразование, 
которое может показаться  магическим  и  без  которого трудно  понять 
результат вычислений. В обычной практике алгоритмики все происхо­
дит  иначе;  действительно,  чрезвычайно  сложно,  если  вообще  возмож­
но, обосновать уже написанный алгоритм, и эта задача становится еще 
более сложной для  автора доказательства, если только он не автор ал­
горитма.  Чтобы  правильно составить  алгоритм,  нужно  сначала фор­
мально рассмотреть решаемую задачу, потом вывести несколько утвер­
ждений, описывающих основные этапы решения, и, наконец, построить 
одновременно алгоритм и его доказательство
\pagebreak
\parindent=1cm Но,  разумеется,  приведенные  примеры  являются  всего  лишь  учеб­
ными.  Их  цель  —  разъяснить  аксиомы,  у  которых,  как  известно,  яс­
ность — не  главнейшее  достоинство!
\subsection{Итерация}
Существует много итеративных структур управления во всех языках 
программирования, а также во всех алгоритмических формализмах. 
На самом деле, все эти структуры образуются от одной и той же эле­
ментарной структуры управления: обобщенной итерации. Обобщенная 
итерация построена с помощью примитивов \textbf{loop},  \textbf{end loop} и \textbf{exit}. Два 
первых примитива \textbf{loop} и \textbf{end loop}  являются, соответственно, левой и 
правой скобками, ограничивающими действие или последовательность 
действий, которая должна повторяться, априори, бесконечно. Прими­
тив \textbf{exit} допускает выход из цикла, в котором он представлен; этот 
примитив  всегда  ассоциируется содним  или  несколькими  условиями 
выхода из цикла и часто появляется в алгоритмах в виде \textbf{exit when}.
Справа представлена наиболее общая форма 
итерации. Эта запись достаточно ясна и не 
требует других объяснений.  На практике, что­
бы сохранить четкость алгоритмов (что озна­
чает также их понимание), мы ограничимся                  // PICTURE
использованием  циклов,  имеющих,  самое  боль­
шее,  два  выхода.  Ни  теперь,  ни  в  дальнейшем, 
мы  не  дадим  самой  общей  аксиомы  (правиль­
нее  сказать  мета-аксиомы)  итерации;  понима­
ние нескольких частных случаев итераций, изу­
чаемых в следующих разделах,  позволяет легко 
ввести  любую  нужную  аксиому.

\parindent=1cm Любопытно отметить,  что  в  практическом  плане  концепции  алго­
ритмов альтернатива, определенная в предыдущем разделе, может быть 
представлена в виде обобщенной итерации  (теоретические  последствия 
см.  [25]).
\subsection{Итерация со счетчиком или цикл «для»}
Конечно,  это  самая  распространенная  форма  итерации.  Она использу­
ется, когда точно известно количество повторений действия, необходи-
\pagebreak
									мого для решения данной задачи. Схема 
									слева представляет сосчитанную итера­
									цию, в которой i — это переменная, р и 
									q — выражения. Запись р..q обозначает 
									интервал, у которого нижняя и  верхняя
границы — соответственно p и q (что приводит, в частности, к возмож­
ности обозначения пустого интервала). Результатом этой конструкции 
является повторение внутреннего действия цикла, называемого \textbf{телом}
\textbf{цикла}, для всех значений \textbf{индекса цикла i} в заданном интервале. Это 
построение обладает как преимуществами, так и некоторыми ограни­
чениями:
\newline
$\bullet$ по своему применению переменная i (индекс  цикла)  относится к 
командной  части  цикла  (это  семантика  индекса  цикла  в  языке 
Ада),
\newline
•  следовательно,эта переменная существует и имеет определенное 
значение только в теле цикла и было бы  неправильно и бессмы­
сленно использовать ее предполаг аемое значение после выполне­
ния цикла.
\textbf{(3) Аксиома} (цикла «для»).
\newline
$\vartriangleright$ \textit{Посылки: А и В --- действия; С --- предикат, P и Q --- условия.}
\textit{                            [ P и С] A [ Q ]  и [Р и (не С)] B [ Q ]}
\pagebreak
\newline
$\vartriangleright$ \textit{Заключение:  \textbf{if} \textit{C} \textbf{then} \textit{A} \textbf{else} \textit{B} \textbf{end if}} [ Q ]
\newline
\end{document} 