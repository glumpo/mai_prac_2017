\documentclass{mai_book}
\defaultfontfeatures{Mapping=tex-text}
\setmainfont{DejaVuSans}
\setdefaultlanguage{russian}
\newlength{\MYwidth} % новый параметр длины 
	\def\MYvrule#1\par{ 
		\par\noindent 
		\MYwidth=\textwidth\addtolength{\MYwidth}{-7pt} 
		\hbox{\vrule width 1pt\hspace{5pt}\parbox[t]{\MYwidth}{#1}} 
	}
	\usepackage{wrapfig}
	\usepackage{listings}
	\usepackage{multicol}
	\usepackage{amsmath}
	\setcounter{page}{604}
    \begin{document} 
    \rhead{\small\textit{V-3 \qquad Точное вычисление FFT: произведение многочленов}}
   \lhead{604}
	\noindent предположить: когда применяют преобразование Фурье часто бывает полезно осуществить обратные преобразования.
	
	\par\bigskip {\bf (16) Лемма} (произведение двух многочлено по модулю \textit{p})
	   
	\medskip
	Пусть $p$ - простое число. Для существования алгоритма с $O(nlogn)$ модулярными операциями перемножения посредством FFT двух многочленов $R$ и $S$ над ~$\mathbb Z$/p$\mathbb Z$[X], степени которых удовлетворяют соотношениям $2 \cdot deg R < n$ и $2 \cdot deg S < n$, достаточно выполнения следующих условий: $n$ является степенью двойки и $n$ делит $p - 1$.\setcounter{page}{604}
	
	\bigskip
	
	\noindent \medskip {\bf Доказательство}
	
	\smallskip
	
	\MYvrule Пусть $w$ - корень порядка n из предыдущего доказательства. Если $F_{w}$ обозначает преобразование Фурье, связанное с этим корнем $w$, то можно вычислить произведение многочленов $R$ и $S$ следующим образом: $R \times S = n^{-1}F_{w^{-1}}(F_{w}(R) * F_{w}(S))$, где $n^{-1}$ - обратный элемент к n по модулю p, который, очевидно, можно представить в этом случае в виде целого $p - (p - 1) / n$.

	
	\medskip
	
	С точки зрения умножения многочленов с целыми коэффициентами, а не модулярными, не все так просто. Действительно, необходимо учитывать размер коэффициентов произведения, которые могут оказаться существенно больше, чем коэффициенты исходных многочленов. Однако, благодаря китайской теореме об остатках, можно всегда вычислить произведение многочленов с целыми коэффициентами, используя произведения модулярных многочленов.
	
	\par\medskip {\bf (17) Лемма.}
	
	\medskip
	\textit{Для многочлена $P = \sum_{i}p_{i}X^{i} \in \mathbb Z[X]$ положим $||P|| = max\{|p_{i}|\}$. Тогда для $R$, $S \in \mathbb Z[X]$ имеем $||RS|| \leq ||R|| \times ||S|| \times min(1 + deg R, 1 + deg S)$.}
	
	\par\bigskip {\bf (18) Предложение} (произведение многочленов с целыми коэффициентами).
	
	\medskip
	
	Для быстрого вычисления произведения двух многочленов степени, не превосходящей $D$, и коэффициентами, по модулю, не превосходящими $M$, при помощи простого числа $p$ и целого $n$, являющегося степенью двойки, где $n$ делит $p-1$, достаточно выполнения неравенств $2(D+1) < n$ и $(D + 1) \times M^{2} < p$.
	
	\smallskip  
	
	Пакет вычисления FFT должен содержать функцию, вычисляющую прямое произведение Фурье, и функцию, вычисляющую обратное преобразование Фурье.
	\newpage
	
	\lhead{\small\textit{V-3.2 \qquad Как реализовать FFT?}}
	\rhead{605}
	\textit{Спецификация пакета вычислений FFT}
	
	\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
typedef int Index_Type; //range < >
typedef int Used_Integer; //range < >
typedef Index_Type* Sequence;
Used_Integer The_Prime_Number;
Used_Integer The_Primitive_root;
int k_Max;

Sequence FFT(Sequence f);
Sequence FFT_Inverce(Sequence f);

\end{lstlisting}

\bigskip
	
	Этот пакет является настраиваемым и имеет в качестве параметров настройки используемые целые типы: $Index \_ Type$ (индексы), $Used \_ Integer$ (элементы рассматриваемых последовательностей) и тип $Sequence$, представляющий последовательности, к которым применяется FFT (тип, который будет определен пользователем). Затем идет целое $The \_ Prime \_ Number$, по модулю которого ведутся все вычисления, $The \_ Prime \_ Root$, примитивный корень (образующий группы обратимых элементов) по модулю рассматриваемого простого числа и $k \_ Max$, показатель наибольшей степени двойки, делящий порядок элемента $The \_ Primitive \_ Root$.
	
	Пакет $Fast \_ Fourier \_ Transform$ содержит две функции FFT и $FFT \_ Inverse$, которые применяются к последовательностям, длина которых есть степень двойки с показателем, меньшим $k \_ Max$, равная количеству точек, в которых вычисляется соответствующее преобразование Фурье или его обратное.
	
	Очевидно, что пользование этим пакетом предполагает совместное и согласованное использование функций $FFT$ и $FFT \_ Inverse$. В частности,
	
	$(i)$ если $p$ есть значение параметра $The \_ Prime \_ Number$, а $\xi$ - значение $The \_ Prime \_ Root$ и $k_{max}$ - значение $k \_ Max$, то $2^{k_{max}} | p - 1$ и $\xi$ имеет порядок $p-1$,

	$(ii)$ если, кроме того  $f$ - последовательность целых чисел по модулю $p$ и длина $f$ есть $2^{k}$, то $w = \xi^{p-1\over{2^k}}$	- корень из единицы степени $2^k$ и:
	
	$\bullet$ функция $FFT$, примененная к $f$, вычисляет $F_{w}(f)$,
	
	$\bullet$ функция $FFT \_ Inverse$, примененная к $\hat f$, $F_{w}^{-1}(\hat f)$.
	
	В принципе надо бы также предусмотреть предвидимое в этой спецификации исключение, которое бы возбуждалось, когда передаваемые\\
	
	\newpage
	
	\rhead{\small\textit{V-3\qquad Точное вычисление FFT: произведение многочленов}}
   \lhead{606}
	
	
		
	\noindent параметры несовместны: например, корень не примитивный, длина последовательности - не степень 2 или слишком велика...
	
	\bigskip
	
	\noindent {\bf 3.3 Умножение многочленов} 
	
	\medskip
	
	\noindent Теперь необходимо выбрать простое $p$ по модулю которого будет вычисляться преобразование Фурье и произведение многочленов. В предыдущем разделе мы рассмотрели несколько формальных свойств, связывающих это целое число, являющееся порядком преобразования Фурье, и корень из единицы. Речь идет теперь о том, чтобы практически применить эти свойствадля реализаии произведения многочленов. Какие практические ограничения обуславливают выбор $p$? Во-первых, $p-1$ должно быть составным, делящимся на возможно большую степень двойки, чтобы иметь возможность вычислять многочлены большой степени. Кроме того, необходимо легко осуществлять вычисления по модулю $p$, в частости, умножение. Точнее говоря, самая крупная операция, осуществляемая в алгоритме $FFT$, имеет вид:
	\smallskip
	\begin{center}
	$F_{m+1}(...) \leftarrow (F_{m}(...) + w^{...} \times F_{m}(...)) \mod p$
	\end{center}
	\smallskip
	Следовательно, машинное умножение для вычисления таких больших выражений, как $(p-1) + (p-1)^2 = p(p-1)$, должно осуществляться без ошибок; другими словами, это последнее выражение должно быть меньше, чем самое большое положительное целое число, представимое в машине. Если имеем дело с машинными словами в 32 бита, то самое большое положительное целое число, которое можно записать, равно, вообще говоря, $2^{31} - 1$. Простые числа, приведенные в таблице 1, отвечают приведенным выше ограничениям и <<содержат>> большие степени двойки.
	\begin{center}
	\begin{tabular}[t]{|p{2em}|p{1em}|p{2em}|p{4em}|p{2em}|p{1em}|p{2em}|p{4em}|}
	\hline 
	$p$ & $\xi$ & $\xi^{-1}$ & $p-1$ & $p$ & $\xi$ & $\xi^{-1}$ & $p-1$\\
	\hline
	13313 15361 19451 25601 & 3 7 3 3 & 4438 4389 6486 8534 & $13 \times 2^{10}$  $15 \times 2^{10}$ $19 \times 2^{10}$ $25 \times 2^{10}$ & 39937 18433 12289 40961 & 5 5 11 3 & 15975 11060 5586 13654 & $39 \times 2^{10}$ $9 \times 2^{11}$ $3 \times 2^{12}$ $5 \times 2^{13}$ \\
	\hline
	\end{tabular}
	\end{center}
	\begin{center}
	{\bf Таблица 1.} Простые числа, удобные для вычисления преобразования Фурье, и примитивные корни
	\end{center}

	Дадим теперь спецификацию пакета умножения двух многочленов по простому $p$.
	
	\newpage
	\lhead{\small\textit{V-3.3\qquad Умножение многочленов}}
   \rhead{607}

	\textit{Пакет вычисления произведения двух многочленов}
	
	\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
//Polinomical_Product.h
typedef int Index_Tupe;
typedef unsigned short int Coefficient; //0 <= Coefficient <= 2^16 - 1
const Coefficient p = 40961;
typedef Coefficient* Polynomial;
Polynomial Fast_Product(Polynomial f, Polynomial g);
Polynomial Slow_Product(Polynomial f, Polynomial g);	
	\end{lstlisting}

\bigskip	

	Кроме различных опеределений типов, он содержит две функции умножения. Первую, <<сложную>>, использующую $FFT$, и вторую, реализующуб наивный алгоритм умножения. Простое число $p$ также является видимым в этой спецификации, так как оно должно быть известно из процедур пользователей. Два многочлена, являющиеся параметрами функций $Fast \_ Product$ и $Slow \_ Product$,  должны обязательно иметь степень, строго меньшую, чем $2^{12} = 4096$, ввиду выбора $p$. Наконец, важно уточнить, что этот пакет нужен только для того, чтобы сопоставить различие во времени вычисления произведения многочленов с помощью быстрого умножения и с помощью наивного метода.
	
	Теперь представим программу для измерения времени выполнения.
	
	\textit{Сравнение алгоритмов вычисления произведения многочленов}
	
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
#include "Polynomial_Product.h"
#include "Calendar.h"

void Test_Product()
{
Index_Type k;
Time Begin_Time;

printf("Умножение многочленов длины 2**k (k <= 12)\n");
while () {
scanf("%d", &k);
if(k == 0) break;

Polynomial f,g;
//выделение памяти на 2^k элементов для f, g и иннициализация 1
Polynomial fg;

printf("%3d\n", k);

\end{lstlisting}	
	
	\newpage
	
	\rhead{\small\textit{V-3 Точное вычисление FFT: произведение многочленов}}
   \lhead{608}
	
	\textit{Продолжение}


\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
Begin_Time = Clock; fg = Fast_Product(f, g);
printf("%d\n", Clock - Begin_Time);
Begin_Time = Clock; fg = Slow_Product(f, g);
printf("%d\n", Clock - Begin_Time);
}
}
\end{lstlisting}

\bigskip
	
	Для обеспечения честности предусмотрено исключение сообщений, предназначенных пользователю, а также серия тестов, позволяющих проверить, что вычисленные произведения дают одинаковый результат независимо от использованного метода, а также различные аксессуары, необходимые с точки зрения программирования. Рассмотрим результаты выполнения программы в наивысших точках диапазона использования.
	
		\begin{center}
		$F_{m+1}(...) \leftarrow (F_{m}(...) + w^{...} \times F_{m}(...)) \mod p$
	\end{center}
	\smallskip
	Следовательно, машинное умножение для вычисления таких больших выражений, как $(p-1) + (p-1)^2 = p(p-1)$, должно осуществляться без ошибок; другими словами, это последнее выражение должно быть меньше, чем самое большое положительное целое число, представимое в машине. Если имеем дело с машинными словами в 32 бита, то самое большое положительное целое число, которое можно записать, равно, вообще говоря, $2^{31} - 1$. Простые числа, приведенные в таблице 1, отвечают приведенным выше ограничениям и <<содержат>> большие степени двойки.
	\begin{center}
		\begin{tabular}[t]{|p{8em}|p{2em}|p{2em}|p{2em}|p{2em}|p{2em}|p{3em}|p{3em}|p{3em}|}
			\hline 
			$k$ & 5 & 6 & 7 & 8 & 9 & 10 & 11 & 12 \\ 
			\hline
			$n = 2^k$ & 32& 64& 128 &256 &512& 1024& 2048 &4096 \\
			\hline
			FFT & 0.11 &0.22& 0.60 &1.26 &2.75 &5.93 &12.74 &27.41\\
			\hline
			<<Наивный алг.>> & 0.11 &0.50& 1.98& 7.91& 31.69 &126.83& 507.18& 2028.62 \\
			\hline
		\end{tabular}
	\end{center}
	
	Рассматривая время вычислений, можно легко установить, что сложность умножения многочленов имеет порядок $O(n^2)$ для обычного алгоритма и $O(nlogn)$ для быстрого алгоритма, использующего FFT.
	
	\noindent {\bf 3.4 Реализация произведения многочленов}
	
	\noindent Это вычисление использует преобразование Фурье и обратное преобразование Фурье для корня из единицы, который предстоит определить. В $\mathbb Z/40661\mathbb Z$ элемент 3 является примитивным корнем из единицы и может быть использован для вычисления преобразования Фурье на $2^{13} = 8192$ точках, что уже не так плохо. Тело пакета $Polynomial \_ Product$ начинается с конкретизации $Fact \_ Fourier \_ Transform$ с его частными параметрами. Затем осуществляется вычисление произведения для каждого из этих двух методов.
	
\textit{Реализация пакета $Polnomial \_ Product$}
	
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
#include "FFT_p"

typedef Large_Integer int;
const Large_Integer p_Large;
\end{lstlisting}	
	
	
	\newpage
	
	\lhead{\small\textit{V-3.4\qquad Реализация произведения многочленов}}
   \rhead{609}
   
\textit{Реализация пакета $Polnomial \_ Product$ (Продолжение)}
	
	\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
Polynomial Fast_Product(Polynomial F, Polynomial G){
Large_Integer Result_Length = 2;
while (Result_Length < vec_size(F) || Result_Length < vec_size(G)) {
Result_Length *= 2;
}
Result_Length *= 2;

const Index_Type = Result_Last = Result_Length - 1;
Polynomial Hat_F, Hat_G, Result; //создание Result_Last + 1 элементов

for (int i = vec_last(F); i < Result_Last; ++i) Hat_F[i] = 0;
Hat_F[vec_range(F)] = F;
for (int i = vec_last(G); i < Result_Last; ++i) Hat_G[i] = 0;
Hat_G[vec_range(G)] = G;
Hat_F = FFT(Hat_F); Hat_G = FFT(Hat_G);

for (int i = range_low(Result); i < range_up(Result); ++i) {
Result[i] = fmod(Hat_F[i] * Hat_G[i], p_Large);
}
Result = FFT_Inverse(Result);
return Result; // range is 0 .. vec_last(F) + vec_last(G)
}

Polynomial Slow_Product(Polynomial F, Polynomial G){
Polynomial FG; //создание vec_last(F) + vec_last(G) + 1 элементов и инициализация 0

for (int i = range_low(F); i < range_up(G); ++i) {
for (int j = range_low(F); j < range_up(G); ++j) {
FG[i+j] = fmod(FG[i+j] + F[i] + G[i], p_Large);
}
}
return FG;
}
\end{lstlisting}
	
\bigskip	
	
	Функция $Fast \_ Product$ должна начинаться с подгонки длины аргументов под степень двойки, превышающей потенциальную длину произведения
	
	\newpage
	
	\rhead{\small\textit{V-3\qquad Точное вычисление FFT: произведение многочленов}}
   \lhead{610}
	
	\noindent двух многочленов. Эту роль выполняет цикл, которым начинается тело функции и который вычисляет значение $Result \_ Lenght$. Затем остается лишь инициализировать аргументы функции $FFT$, а потом применить принцип вычисления умножения посредством вычисления значений в точке и интерполяции. Арифметические вычисления должны осуществляться в достаточно большом типе, как это было показано в предыдущем разделе. Тип $Large \_ Integer$, определенный в начале тела пакета, позволяет уверенно выполнять все вычисления целых, могущие вызвать переполнение, в типе $Coefficient$ до приведения по модулю $p$. Этот тип в принципе может применяться на машинах, допускающих 32-битовые слова. Очевидно, что необходимые преобразования типов несколько утяжеляют запись пакета.
	
	\bigskip
	
	\noindent {\bf 3.5 Вычисление преобразования Фурье}
	
	\medskip
	
	\noindent Для вычисленияпреобразования Фурье и его обратного необходимо знать корень $2^k$-степени из единицы, все его степени и инволюцию интервала $[0,2^k[$, обращающую двоичную записьцелых чисел. Среди настраиваемых параметров пакета $Fast \_ Fourier \_ Transform$ находится $\xi$ \\ ($The \_ Primitive \_ Root$) - примитивный корень по модулю $p$. Одна из первых операций для вычисления FFT состоит в получении из этого параметра примитивного корня $2^{k_{max}}$-й степени из единицы по модулю $p$, $\alpha = \xi^{p-1 \over 2^{k_{max}}}$. Этот корень обозначается в программе через $Alpha$ и его вычисление производится в процедуре $Alpha \_ Determination$. Далее необходимо записать степени $Alpha$ в виде массива под именем $Alpha \_ Power$, конструируемого в процедуре $Alpha \_ Powers \_ Compulation$. Наконец, нужно еще затабулировать инволюцию, необходимую для вычисления FFT, когда число точек есть степень 2.
	
	Разумеется при настройке этого пакета не всегда будем вычислять преобразование Фурье на $2^{k_{max}}$ точках. Иногда число точек не столь важно. В этом случае достаточно пробежать массивы $Alpha \_ Power$ или $Binary \_ Reverse$ с хорошо выбранным инкрементом, чтобы почти немедленно получить степени рассматриваемого корня или образ под действием инволюции.
	
	\textit{Быстрое преобразование Фурье}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
1: typedef The_Prime_Number Used_Integer;
2: Used_Integer p;
3: const Index_Type n = pow(w, k_Max);
4: typedef int Large_Integer;
\end{lstlisting}
	
	\newpage
	
	\lhead{\small\textit{V-3.5 Вычисление преобразования Фурье}}
   \rhead{611}
   
   \textit{Быстрое преобразование Фурье(Продолжение)}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
5: const Large_Integer p_Large;
6: Large_Integer Alpha;
7: Used_Integer Alpha_Power[n+1];
8: Index_Type Binary_Reverse[n];
9:
10: Sequence FFT(Sequence F)
11: {
12: Sequence F_Hat; //range = F range
13: int m = 0;
14: Index_Type Two_Power_k_m_1 = vec_length(F) / 2;
15: Index_Type Two_Power_k_Max_m_1 = n / 2;
16: Index_Type Two_Power_m = 1;
17: Index_Type i_0, i_1, i_0_j, i_1_j;
18: Large_Integer F_Hat_0, F_Hat_1;
19:
20: for (int i = range_low(F_Hat); i <= range_up(F_Hat); ++i) {
21: F_Hat[i] = F[Binary_Reverse[i * (n / vec_length(F))]];
22: }
23:
24: while () {
25: for (int i = 0; i < Two_Power_k_m_1; ++i) {
26: i_0 = 2 * i * Two_Power_k_m_1; i_1 = i_0 + Two_Power_m;
27: for (int j = 0; j < Two_Power_m; ++j) {
28: i_0_j = i_0 + j; i_1_j = i_1 + j;
29: F_Hat_0 = F_Hat[i_0_j];
30: F_Hat_1 = F_Hat[i_1_j] * Alpha_Power[j * Two_Power_k_Max_m_1];
31: F_Hat[i_0_j] = fmod(F_Hat_0 + F_Hat_1, p_Large);
32: F_Hat[i_1_j] = fmod(F_Hat_0 - F_Hat_1, p_Large);
33: }
34: }
35: if (Two_Power_k_m_1 == 1) break;
36:
37: m++;
38: Two_Power_m *= 2;
39: Two_Power_k_m_1 /= 2;
40: Two_Power_k_Max_m_1 /= 2;
41: }
42: return F_Hat;
43: }
44:
\end{lstlisting}
	
	\newpage 
	
	\rhead{\small\textit{V-3\qquad Точное вычисление FFT: произведение многочленов}}
   \lhead{612}
	
\textit{Быстрое преобразование Фурье(Продолжение)}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
45: Sequence FFT_Inverse(Sequence F)
46: {
47: const Large_Integer Inverse_Of_Length = p_Large - (p_Large - 1) / vec_length(F);
48: Sequence F_Hat; // range = F range
49: int m = 0;
50: Index_Type Two_Power_k_m_1 = vec_length(F) / 2;
51: Index_Type Two_Power_k_Max_m_1 = n / 2;
52: Index_Type Two_Power_m = 1;
53: Index_Type i_0, i_1, i_0_j, i_1_j;
54: Large_Integer F_Hat_0, F_Hat_1;
55:
56: for (int i = range_low(F_Hat); i <= range_up(F_Hat); ++i) {
57: F_Hat[i] = F[Binary_Reverse[i * (n / vec_length(F))]];
58: }
59:
60: while () {
61: for (int i = 0; i < Two_Power_k_m_1; ++i) {
62: i_0 = 2 * i * Two_Power_k_m_1; i_1 = i_0 + Two_Power_m;
63: for (int j = 0; j < Two_Power_m; ++j) {
64: i_0_j = i_0 + j; i_1_j = i_1 + j;
65: F_Hat_0 = F_Hat[i_0_j];
66: F_Hat_1 = F_Hat[i_1_j] * Alpha_Power[n - j * Two_Power_k_Max_m_1];
67: F_Hat[i_0_j] = fmod(F_Hat_0 + F_Hat_1, p_Large);
68: F_Hat[i_1_j] = fmod(F_Hat_0 - F_Hat_1, p_Large);
69: }
70: }
71: if (Two_Power_k_m_1 == 1) break;
72:
73: m++;
74: Two_Power_m *= 2;
75: Two_Power_k_m_1 /= 2;
76: Two_Power_k_Max_m_1 /= 2;
77: }
78:
79: for (int i = range_low(F_Hat); i <= range_up(F_Hat); ++i){
80: F_Hat[i] = fmod(F_Hat[i] * Inverse_Of_Length, p_Large);
81: }
82:
83: return F_Hat;
84: }
85:
\end{lstlisting}	
	
	\newpage
	\lhead{\small\textit{V-3.5 \qquad Вычисление преобразования Фурье}}
   \rhead{613}
   	
\textit{Быстрое преобразование Фурье(Продолжение)}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
86: int main()
87: {
88: Alpha_Determination();
89: Alpha_Powers_Computation();
90: Binary_Reverse_Tabulation();
91: }
\end{lstlisting}   

\bigskip	
   	
	В начале тела пакета находится определение (строка 4) типа $Large \_ Integer$, используемого для осуществления промежуточных вычислений без риска переполнения. Константа $p \_ Large$, фигурирующая после этого определения типа, используется с целью облегчения необходимых взаимных преобразований типов $Used \_ Integer$ и $Large \_ Integer$.
	
	Далее идет определение функции $FFT$, программирование которой требует некоторых уточнений. К этому моментууже вычислены значения $\alpha = \xi^{p-1 \over n}$ и $n = 2^{k_{max}}$, что позволяет вычислить преобразование Фурье на $n$ точках; но то, что можно вычислить с помощью функции $FFT$, и есть преобразование Фурье на $2^k$ точках при $k \leq k_{max}$:  достаточно заменить пару $(\alpha, n)$ на $(w, q) = (\alpha^{n \over q}, 2^k)$.
	
	Получить степени корня из единицы $w = \alpha^{n \over q}$ очень легко с помощью массива $Alpha \_ Power$ степеней $\alpha$. Нужно также уметь вычислять двоичную инволюцию на интервале $[0,q[$ исходя из инволюции на интервале $[0,n[$ (уже затабулированной). Пусть $\sigma_q : [0,q[ \rightarrow [0,q[$ - двоичная инволюция. Тогда для $i \in [0,q[$ имеем $\sigma_{q}(i)=\sigma_{2q}(2i)$. Действительно, если $i = \left\langle {i_{q-1} \ldots i_1 i_0} \right \rangle$, то получаем:
	\begin{center}
		$\sigma_{q}(i) = \left\langle {i_{q-1} \ldots i_1 i_0} \right \rangle$, $2i = \left\langle {i_{q-1} \ldots i_1 i_0} \right \rangle$ \\
		$\sigma_{2q}(2q) = \left\langle {0 i_0 i_1 \ldots i_{q-1}} \right \rangle = \sigma_{q}(i)$,
	\end{center}

	\noindent откуда можно легко вывести, что
	
	\begin{center}
		$\sigma_{q}(i) = \sigma_{2q}(2i) = \sigma_{4q}(4i) = \ldots = \sigma_{2^{k_{max}}}({2^{k_{max}} \over q}i) $,
	\end{center}
	где всегда предполагается, что $i$ находится в интервале $[0,q[$.
	
	Чтобы закончить рассмотрение этого пакета, дадим некоторые комментарии по поводу реализауии алгоритма $FFT$. Если заметить, что переменная $Two \_ Power \_ m$ представляет $2^m$, а переменная $Two \_ Power \_ k \_m \_ 1$ представляет значение $2^{k-m-1}$, и что переменная $Two \_ Power \_ k \_ Max \_ m \_ 1$
	
	\newpage
	
	\rhead{\small\textit{V-3\qquad Точное вычисление FFT: произведение многочленов}}
    \lhead{614}
	
	\noindent представляет значение $2^{k_{max}-m-1}$ почти немедленно получаем алгоритм, представленный в конце раздела 3.1. Главное различие заключается в цикле по $m$, который в алгоритме был циклом {\bf for}, а теперь является общей итерацией. Это объясняется последовательным вычислением необходимых степеней двойки. В алгоритме это вычисление осуществляется неявно, что может создать впечатление, что выражение $2^m$ и $2^{k-m-1}$ вычислялись на каждой итерации.
	
	Для реализацииобратного преобразования Фурье достаточно продублировать код функции $FFT$ и модифицировать инструкции, записанные в строках 36 и 37. Так, вместо $\alpha^{j2^{k_{max}-m-1}}$ надо использовать в действительности $\alpha^{-j2^{k_{max}-m-1}}$. Во избежание возможный проблем с ограничениями при возведении $\alpha$ в отрицательную степень, когда тип индексов в массиве степенейне обязательно имеет отрицательную часть, можно заменеить показатель $-j2^{k_{max}-m-1}$ на $-j2^{k_{max}-m-1} \mod n$ и использовать выражение $\alpha^{n-j2^{k_{max}-m-1}}$, что и записано в строках 77 и 78. Такое упрощение возможно, если предварительно затабулировать $\alpha^n$ в массиве степеней $\alpha$. Исходя из этого, можно выразить в явном виде интервал индексов, используемых в объявление массива $Alpha \_ Power$.
	
	Наконец, другое различие между преобразованием Фурье и его обратным заключается в том, что для получения результата для обратного преобразования Фурье необходимо деление на $2^k$ (это деление происходит  в строчках 92-95). Так как $2^k$ делит $p-1$, то обратный элемент к $2^k$ по модулю $p$ представим в виде $p-(p-1)/2^k$ и содержится в интервале $[0,p-1[$.
	
	Чтобы закончить с этой программой, остается детализировать три отдельные процедуры пакета.
	
	\textit{Прекомпиляция данных}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
Fast_Fourier_Transform procedure Alpha_Determination is
constant Large_Integer = Xi_Large;
{
Alpha = 1;
for(int j = 1; j<= (p-1) / Used_Integer (n);j++){
Alpha = (Alpha * Xi-Large) % p_Large;
}
}
separate (Fast_Fourier_Transform) procedure Alpha_Powers_Computation is
Current_Power : Large_Integer = 1;
{
for (int j = 0;j <= Alpha-Power*Last/2; j++){
Alpha_Power (j) = Used_Integer (Current_Power);

\end{lstlisting}
	
	\newpage
	
\textit{Прекомпиляция данных(Продолжение)}
\begin{lstlisting}[language=C,
basicstyle=\scriptsize,
linewidth=7cm,
belowskip=-1em,
mathescape=true]
Alpha-Power (j + n/2) = р – Used_Integer (Current_Power);
Current_Power = (Current_Power * Alpha) mod p_Large;
}
}
Fast_Fourier_Transform procedure Binary-Reverse-Tabulation is
Index_Type Reversed = 0;
Natural Digits_Of_Reverse_i[k_Max - 1];
{
for(int i in Binary-Reverse 'Range){
Binary_Reverse[i] = Reverse_i;
for(int j in reverse Digits-Of-Reverse-i'Range ){
if (Digits_Of_Reverse_i[j]== 0){
Digits_Of_Reverse_i[j] = 1; Reverse_i = 2 * j + Reverse_i % 2 * (j + 1);
}
else {
Digit_Of_Reverse_i [j]= 0;
}
}
}
}
\end{lstlisting}

\bigskip
	
	\lhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \rhead{615}
	
	Процедура $Alpha \_ Determination$ требует единственного пояснения: как уже говорилось, $\xi$ - примитивный корень по модулю $p$, переданный как настраеваемый параметр, не представляет самостоятельного интереса. Нам нужен корень из единицы порядка $n$. Величина $\alpha = \xi^{p-1 \over n}$ как раз и есть такой корень.
	
	Пояснение к процедуре $Binary \_ Reverse \_ Tabulation$: отправляясь от $\sigma(i)$, представляемой переменной $Reverse \_ i$, и ее массива битов (переменная $Digets \_ Of \_ Reverse \_ i$), вычисляем массив битов для $\sigma(i+1)$. С этой целью достаточно прибавить  1 <<в обратном порядке>>. При проходе массива $Digits \_ Of \_ Reverse \_ i$ обращение порядка достигается тем, что 1 заменяется на 0, пока не встретится первый 0. В этом случае 0 заменяется на 1 и после небольшого модулярного вычисления получается $\sigma(i+1)$.
	
	\bigskip
	
	\noindent {\bf 4 Подробное рассмотрение метода 
		
		Кули и Тьюки}
	
	\medskip
	
	\noindent Для реализации FFT, как это только что было сделано, нужно заранее иметь в распоряжении явные формулы, определяющие производимые
	
	\newpage
	
	\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \lhead{616}
	
	
	\noindent вычисления. До настоящего времени предполагалось, что такие формулы существуют, а теперь пришло время получить их. Для этого рассмотрим более общую ситуацию, чем в предыдущих разделах: уже не предполагается, что число точек для вычисления есть степень двойки, но лишь, как в случае Кули и Тьюки, что это число - составное. Использование степеней двойки для реализации очень удобно и утешительно с точки зрения информатики...
	
	В этом разделе мы изучим метод FFT, принадлежащий Кули, Тьюки и Йейтсу. Рассмотрим его сначала для частного случая, когда порядок преобразования Фурье есть произведение двух чисел, затем обобщим на случай, когда этот порядок есть произвольные произведения. Это приведет к необходимости использовать смешанную систему счисления (упражнения 33, 34, 35 и 36 дают более абстрактное представление преобразования Фурье на конечных абелевых группах).
	
	\bigskip
	
	\noindent {\bf 4.1 Метод Кули - Тьюки для произведения 
		
		двух множителей }
	
	\medskip
	
	\noindent Напомним функциональные обозначения, введенные определением 8. Многочлен $P$, значения которого хотим вычислить, представляется функцией $f : [0,n[ \rightarrow A$, где $f(i)$ - коэффициент при $X^i$ в обычной записи $P$. Теперь для $0 \leq j < n$ нужно вычислить суммы
	\begin{center}
		$\hat f (i) =\sum_{0 \leq i < n} f(i) \cdot w^{ij}$.
	\end{center}
	
	\noindent {\bf (19) Предположение.}
	
	\textit{Пусть $n$ - целое составное число: $n = pq$, функция $f: [0,n[ \rightarrow A$ и  $\hat f$ - преобразование Фурье $f$. Функцию $\hat f: [0,n[ \rightarrow A$ можно вычислить с помощью промежуточной функции $g: [0,n[ \rightarrow A$ по следующим формулам:}
	
	\begin{center}
		$\hat f(j_1q + j_0) = \sum_{i_0 = 0}^{p-1} g(i_0q + j_0) \cdot w^{i_0(j_1q+j_0)}$ \\
		\smallskip
		и $g(i_0q + j_0) = \sum_{i_1 = 0}^{q-1}f(i_1p+i_0) \cdot w^{i_1j_0p}$.
	\end{center}
	\textit{В этих формулах целые $j_1$ и $i_0$ пробегают интервал $[0,p[$, а целые $j_0$ и $i_1$ - интервал $[0,q[$. Вычисление $\hat f$ требует $n(p+q-2)$ сложений и $n(p+q-3)+1$ умножений.}
	
	\newpage
	
	\lhead{\small\textit{V-4.1\qquad Метод Кули-~Тьюки для произведения двух множителей}}
   \rhead{617}
	\noindent {\bf Доказательство.}
	
	\bigskip
	
	\MYvrule Для вычисления $\hat f(j) = \sum f(i) \cdot w^{ij}$ применим евклидовы деления $i = i_1p + i_0$ и $j = j_1q+j_0$. Целые числа, получающиеся в этих выражениях, удовлетворяют соотношениям $0 \leq i_0, j_1<p$ и $0 \leq j_0, i_1<q$. Процедура Кули и Тьюки состоит в переписывании формулы для вычисления значений в точке в виде:
	\begin{center}
		$\hat f(j_1q + j_0) = \sum_{i_0, i_1}f(i_1p+i_0) \cdot w^{i_0j} \cdot w^{i_1pj}=$\\		
		$= \sum_{i_0}w^{i_0j}(\sum_{i_1}f(i_1p+i_0) \cdot w^{i_1pj})$. \hspace{1.5cm}(6)
	\end{center}
	В последнем члене равенства суммы (6) множитель $w^{i_1pj}$ внутренней суммы зависит лишь от остатка $j_0$ (числа $j$) по модулю $q$. В самом деле, $pj \equiv pj_0 (\mod n)$ и потому $w^{i_1pj}=w^{i_1j_0p}$. Следовательно, если положить $g(i_0q+j_0) = \sum f(i_1p+i_0) \cdot w^{i_1j_0p}$, то окончательно получим
	\begin{center}
		$\hat f(j_1q+j_0)=\sum_{i_0}g(i_0q+j_0)w^{i_0j}=\sum_{i_0}g(i_0q+j_0)w^{i_0(j_1q+j_0)}$.
	\end{center}
	Что касается сложности, то, для того, чтобы доказать анонсированный результат, достаточно заметить, что вычисление $g(i_0q+j_0)$ и $\hat f(j_1q+j_0)$ требует, соответственно, $q-1$ и $p-1$ умножений (кросе $g(0), g(q), \ldots, g((p-1)q)$) и $\hat f(0)$, и что существует $n$ таких вычислений.
	
	\bigskip\bigskip
	
	\noindent {\bf Интерпретация метода Кули - Тьюки для} n = 12
	
	\medskip
	
	Для изложения этого примера выберем $p =3$ и $q = 4$. Пусть $P(X) = \sum a_iX^i$ - многочлен степени $< 12$, вычисляемый в степенях $w$, корня 12-й степени из единицы: $\hat a_j = P(w^j)$ для $j = 0, 1,2,\ldots,10,11$. Следуя предыдущему доказательсьву, введем числа $b_j=g(j)$, определенные явным образом формулой $b_{4j_1+j_0}=f(j_1)+f(j_1+3)w^{3j_0}+f(j_1+6)w^{6j_0}+f(j_1+9)w^{9j_0}$, что двет следующие промежуточные значения:
	\begin{align*}
		b_0 &= a_0 + a_3 + a_6 + a_9, &\qquad b_4 &= a_1 + a_4 + a_7 + a_{10},\\
		b_1 &= a_0 + a_3w^3 + a_6w^6 + a_9w^9, &\qquad b_5 &= a_1 + a_4w^3 + a_7w^6 + a_{10}w^9,\\
		b_2 &= a_0 + a_3w^6 + a_6 + a_9w^9, &\qquad b_6 &= a_1 + a_4w^6 + a_7 + a_{10}w^3,\\
		b_3 &= a_0 + a_3w^9 + a_6w^6 + a_9w^3, &\qquad b_7 &= a_1 + a_4w^9 + a_7w^6 + a_{10}w^3,
	\end{align*}

	\newpage
	
	\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \lhead{618}
	
	\begin{align*}
	b_8 &= a_2 + a_5 + a_8 + a_{11},\\
	b_9 &= a_2 + a_5w^3 + a_8w^6 + a_{11}w^9,\\
	b_{10} &= a_2 + a_5w^6 + a_8 + a_{11}w^6,\\
	b_{11} &= a_2 + a_5w^9 + a_8w^6 + a_{11}w^3.
	\end{align*}
	
	\noindent Можно тогда вычислить числа $\hat a = \hat f(j)$, которые получаются по порождающим формулам $\hat a_{4j_1+j_0} = b_{j_0} + b_{j_0} + 4w^{4j_1+j_0}+b_{j_0}+8w^{2(4j_1+j_0)}$, которые дают нам еще 12 явных формул:
	\begin{align*}
	\hat a_0 &= b_0+b_4+b_8, &\qquad \hat a_4 &= b_0 + b_4w^4 + b_8w^8, &\qquad \hat a_8 &= b_0 + b_4w^8 + b_8w^4,\\
	\hat a_1 &= b_1+b_5w^1+b_9w^2, &\qquad \hat a_5 &= b_1 + b_5w^1 + b_9w^{10}, &\qquad \hat a_9 &= b_1 + b_5w^9 + b_9w^6,\\
	\hat a_2 &= b_2 + b_6w^2 + b_{10}w^4, &\qquad \hat a_6 &= b_2 + b_6w^6 + b_{10}, &\qquad \hat a_{10} &= b_2 + b_6w^{10} + b_{10}w^8,\\
	\hat a_3 &= b_3 + b_7w^3 + b_{11}w^6, &\qquad \hat a_7 &= b_3 + b_7w^7 + b_{11}w^2, &\qquad \hat a_{11} &= b_3+b_7w^{11}+b_{11}w^{10}.
	\end{align*}
	
	Легко убедиться, что число необходимых сложений для этого метода $(2+3) \times 12 = 60$ (в общем случае$n(p+q-2)$) в сравнении с $11 \times 12 = 132$ сложениями в наивно методе. Аналогичные оценки можно получить для мультипликативной сложности: наивный метод требует 121 умножение, а полученные сейчас формулы лишь 49 (исключая умножение на 1, стоящие выше или слева; для исключения других умножений на 1 требуется несколько более детальное изучение). Если, кроме того, $w^6=-1$, то можно сэкономить еще несколько операций.
	
	\medskip
	
	{\bf (20) Теорема} (Кули и Тьюки [55], 1965).
	
	\smallskip
	
	\textit{Пусть $w$ - корень $n$-й степени из единицы в кольце $A$, степени которого $w^0,w^1,w^2,\dots,w^{n-1}$-затабулированы. Предположим, что $n=pq$, и обозначим корень $q$-й степени из единицы через $\eta = w^p$. Предположим далее, что существует метод, позволяющий вычислить любой многочлен степени, меньшей $q$, во всех точках $1,\eta,\eta^2,\ldots,\eta^{q-1}$ с помощью $M_q$ умножений.}
	
	\textit{Тогда для любого многочлена степени меньшей $n$, можно вычислить его значения в точках $1,w^1,w^2,\ldots,w^{n-1}$, используя только $pM_q+(n-1)(p-1)$ умножений и $pA_{q}+n(p-1)$ сложений.}
	
	\medskip
	
	\noindent{\bf\textit{Пример}}
	
	\smallskip
	
	Предположим, что для вычисления значений многочлена степени $< q$, используется обычный наивный метод, который требует $q-1$ умножений (на 
	{\bf одну} степень из $\eta$ данных). В этом предположении $M_q = (q-1)^2$ для $q$ степеней $\eta = w^p$. Если применить теорему для вычисления значений многочлена степени $< n$ в точках $1,w,w^2,\ldots,w^{n-1}$, то получается $n((p-1)+(q-1))$ умножений вместо $M_n = (n-1)^2$ умножений в наивном методе. Эффективность метода Кули - Тьюки по отношению к наивному алгоритму измеряется отношением ${(pq-1)^2 \over {pq(p+q-3)-1}} \approx {pq \over (p+q)}$, и
	
	
	\newpage
	
	\lhead{\small\textit{V-4\qquad Метод Кули-~Тьюки для произведения двух множителей}}
   \rhead{619}
	
	\noindent это приблизительное значение будет лежать в основе дальнейших вычислений.
	
	Например, применение метода Кули - Тьюки к $n = 2000$ с $p = 40$ и $q = 50$ требует 176000 умножений, в то время как наивный метод требует 3998000. Метод Кули - Тьюки в 22 раза быстрее наивного метода, и это в том случае, если последний применяется только один раз, т.е. если вычисляется наивным методом значение многочлена степени $< 50$. Лучшего результата можно добиться, если итерировать метод Кули - Тьюки дальше на множитель $q$ или по другому разложить $n$.
	
	\medskip
	
	\noindent\textit{\bf Доказательство теоремы 20}
	
	\smallskip
	
	Пусть $P(X) = a_{n-1}X^{n-1}+\ldots+a_2X^2+a_1X^1+a_0$ - многочлен. Перегруппировывая коэффициенты, индексы которых совпадают по модулю $p$, запишем $P(X)=P_0(X^p)+XP_1(X^p)+\cdots+X^{p-1}P_{p-1}(X^p)$, где любой $P_r$ при $0 \leq r < p$ является многочленом степени $< q$:
	\begin{center}
		$P_r(Y)=\sum_{0 \leq i < q}a_{ip+r}Y^i$, что влечет $P_r(X^p)=\sum_{i \equiv r \pmod p}a_iX^{i-r}$.
	\end{center}
	Так как $\eta^q = 1$, величина $\eta^j$ зависит только от выбора представителя $j$ по модулю $q$ и, следовательно,
	
	\begin{multline*}
	P(w^j)=P_0(\eta^{j \mod q}) + w^jP_1(n^{j \mod q}) + \\
	+ \cdots + w^{(p-1)j}P_{p-1}(\eta^{j \mod q}).  (7)
	\end{multline*}
	
	\noindent Вычисления значений любого из многочленов $P_r$ в $q$ степенях $\eta$ требует по предположению $M_q$ умножений. Поэтому для вычисления значений $p$ многочленов $P_0,P_1,P_2,\dots,P_{p-1}$ в этих точках требуется $pM_q$ умножений. После реализации этих вычислений остается вычислить по формуле (7) $n$ вычислений, каждое из которых требует $p-1$ умножений. Эти $n$ вычислений в общей сложности требуют $(n-1)(p-1)$ умножений, исключая умножение на 1 (для $j=0$). Таким образом, всего получаем $pM_q+(n-1)(p-1)$ умножений, что завершает доказательство теоремы.
	
	\smallskip
	
	\noindent{\bf Интерпретация метода Кули - Тьюки при} $n = 12$ (продолжение)
	
	\smallskip
	
	Вернемся к предыдущему примеру для $p=3$ и $q=4$ в свете проведенного доказательства и введем многочлены $P_0(Y)=a_0+a_3Y+a_6Y^2+a_9Y^3, P_1(Y)=a_1+a_4Y+a_7Y^2+a_{10}Y^3$ и $P_2(Y)=a_2+a_5Y+a_8Y^2+a_{11}Y^3$. В этих обозначениях $\hat a_j = P_0(w^{3j})+w^jP_1(w^{3j})+w^{2j}P_2(w^3)$. Такая организация вычисления $P(w^j)$ требует введения выражений $P_0(w^{3j}), P_1(w^{3j}),P_3(w^{3j})$. Так как $w$ - корень 12 степени из единицы, что является принципиальным моментом этого преобразования, то и получим 12 таких
	\newpage 
	\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода  Кули-~Тьюки}}
    \lhead{620}
\noindent выражений ( а не 36, как можно было бы предположить). Если зануме-\\ровать эти выражения следующим образом: \\
\begin{align*}
b_0&=P_0(1)  &\qquad b_1&=P_0(\omega^3) &\qquad b_2&=P_0(\omega^6) &\qquad b_3&=P_0(\omega^9)\\
b_4&=P_1(1) &\qquad b_5&=P_1(\omega^3) &\qquad b_6&=P_1(\omega^6) &\qquad b_7&=P_1(\omega^9) \\
b_8&=P_2(1) &\qquad b_9&=P_2(\omega^3) &\qquad {b_10}&=P_2(\omega^6) &\qquad {b_11}&=P_2(\omega^9)
\end{align*}
\smallskip
то получим формулы, установленные в результате комбинаторных ис-\\ следований для этого примера в самом начале.\\

\textbf{(21) Резюме.}

\textit{Суммируя результаты теоремы Кули~---Тьюки и проведенных ис-\\ следований, получаем, что вычисление одного преобразования Фурье \\ на $n=pq$ точках требует $p$ вычислений преобразования Фурье поряд\\ ка $q$, одного преобразования Фурье порядка $p$ $p(q-1)$\\ вычислений значений многочленов степени, меньшей $p$; символически:}\\
\begin{align*}
	\textbf{Cooley-Tuckey}_{p \times q}(\omega) &\equiv p DFT_{q, \omega^p} \oplus\\
	  &\oplus 1 DFT_{p, \omega^q} \oplus p(q-1) \textbf{Evaluation}.
	  \end{align*}
\textit{Перемещая некоторые степени $\omega$ в коэффициентах $b_i$, используе-\\мые для окончательных вычислений значений, можно сразу же по-\\лучить $q-1$ преобразований Фурье порядка $p$, отсутствующих в преды-\\дущем выражении (рассмотреть, например, преобразования $b`_5=b_{5}\omega$ \\$b`_9=b_{9}\omega^2$, \dots для примера $3\times 4$), но тогда появляются дополнительные\\ умножения:}
 \begin{align*}
	\textbf{Cooley-Tuckey}_{p \times q}(\omega) &\equiv p \oplus q DFT_{q, \omega^p} \oplus\\
	&\oplus q DFT_{p, \omega^q} \oplus (p-1)(q-1) \textbf{Produit.}\\
\end{align*}
\textit{Все эти результаты, разумеется, не предвосхищают способа, кото\\ рым будут вычисляться вводимые таким образом дискретные преобра-\\ зования Фурье.}

\medskip

\noindent\textbf{Обоснование.}

\MYvrule Напомним формулу (7) из доказательства теоремы 20:
$$P(\omega^j) = P_0(\eta^{j\mod q}) + \omega^jP_1(\eta^{j\mod q})+\\ + \cdots +\omega^{(p-1)j}P_{p-1}(\eta^{j\mod q}).\eqno(7)$$\\
В этой формуле, как видим, вычисление значений в точках ${\omega^j}$ тре-\\ бует сначала вычисления значений $p$ многочленов ${P_i}$ в $q$ степенях $\eta$ :\\
это дает $p$ дискретных преобразований Фурьер порядка $q$. Затем

\newpage

\lhead{\small\textit{V-4.2\qquad Итерация метода Кули -~ Тьюки}}
   \rhead{621}

 \MYvrule надо вычислить значения $q$ многочленов, зависящих от $jmod q$, име-\\ ющих в качестве коэффициентов $P_i\eta^{jmod q}$, в точках $\omega^j$, кото-\\ рые не обязательно являются корнями степени $p$ из единицы, за \\ исключением случая, когда $j \equiv 0 mod q$, для которого мы получаем \\ дискретное преобразование Фурье порядка $p$ указанное в исходной \\ формуле, и остается только $n-p = p(q-1)$ вычислений значений в \\ точках для того, чтобы завершить вычисления.

\bigskip

\noindent\large{\bf 4.2.Итерация метода Кули -Тьюки}\\

\smallskip
\normalsize
\noindent В этом разделе обобщим результаты, установленные в предыдущем раз-\\ деле, на случай, когда число $n$ точек, в которых вычисляются значения, \\ является сильно составным: $n = n_0n_1n_2\ldots n_k$.

\medskip

\noindent{\textbf{(22) Обозначения.}}\\
\noindent\textit{Если $n=n_0n_1n_2\ldots n_k$, то обозначим:}\\ 
\indent $\pi^i$ = ${n_0}{n_1}{n_2}\ldots {n_{i-1}}$  —~ \textit{произведение первых $i$ сомножителей числа \\ $n$ (так что $\pi_0$ = 1),} \\
\indent $\pi_i$ = $n_{k-i+1}n_{k-i+2} \ldots n_k$ —~ \textit{произведение последних $i$ сомножителей.}\\
\begin{multicols}{2}
\noindent $FFT_n$ $\underrightarrow{Cooley-Tuckey}$ $n_0$ $FFT_{\pi_k}$\\
$FFT_{\pi_k}$ $\underrightarrow{Cooley-Tuckey}$ $n_1$ $FFT_{\pi_{k-1}}$\\
$FFT_{\pi_{k-1}}$ $\underrightarrow{Cooley-Tuckey}$ $n_2 FFT_{\pi_{k-2}}$

\hspace{2cm}
$\vdots$\\ 
$FFT_{\pi_2}$ $\underrightarrow{Cooley-Tuckey}$ $n_{k-1}$ $FFT_{\pi_1}$\\
Как видно из предыдущего раз-\\дела, вычисление дискретного\\ преобразования Фурье по мето-\\ду Кули~---Тьюки, когда чи-\\сло точек для вычисления есть \\ произведение двух целых $p$ и $q$,
\end{multicols}	
		\noindent помимо всего прочего требует вычисления $p$ преобразований \\
		\noindent Фурье на $q$ точках. Кроме того, к этим вычисления преобразова-\\ний Фурье следует добавить вычисления многочленов, необходимых \\ для синтеща окончательного результата. Метод, традиционно называе-\\мый $FFT$,
		\normalsize является нечем иным, как итерацией метода Кули~---Тьюки,\\ когда число точек для вычисения сильно составное. В наиболее инте-\\ресном здесь для нас случае $n=n_0n_1n_2\ldots n_k$, применение методу Кули\\ ~---Тьюки для вычисления значний в $n$ точках потребует к примеру $n_0$ вычислений преобразований Фурье на $\pi_k$ = $n_1n_2\ldots n_k$ точках. Эти \\ преобразования Фурье в свою очередь, могут быть вычислены приме-\\ нением принципа Кули~---Тьюки к разложению $\pi_k$ на $n_1$ и $n_2\ldots n_k$, \\ что требует вычисления $n_1$ преобразований Фурье в $\pi_{k-1}$ точках и т.д.\\ Схема слева хорошо иллюстрирует процессю Для начала изучим\\ сложность вычисления $FFT$, 
		\normalsize что сравнительно просто, а потом мы пе-\\рейдем к выводу явных формул, необходимых для реализации $FFT$.
		\normalsize 
		\newpage
\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \lhead{622}

\textbf{4.2.1 Сложность итерационного метода Кули---Тьюки}\\

\textbf{(23) Предложение.}\\
\textit{\indent Рекурсивное применение Кули~---Тьюки для целого $n$, пред-\\ставимо в виде $n=n_0n_1n_2\ldots n_k$, дает метод, требующий $M_n$ \textbf{умноже-\\ ний} с выражением }
	\begin{center}
		$\frac{\mathcal{M}_n}{n} = ({n_0} - 1) + (n_1 - 1) + \ldots (n_k - 1) - \frac{n-1}{n}$,
	\end{center}

	\noindent\textit{которое упрощается, когда $n$ является степенью $q$, до} 
	$\mathcal{M}_n =$ \\ $(q-1)n\log_{q}n - n + 1$.
	
	\bigskip
	
	\noindent\textbf{Доказательство.}
	
	\MYvrule По теореме 20 имеем соотношение $\mathcal{M}_n = {n_0}\mathcal{M}_{{n_1}{n_2}}\dots{n_k} + (n-1)$\\ $(n_0 -1)$, а так как $\mathcal{M}_1$ = 0, простая индукция показвает:\\
	\begin{center}
		$\frac{\mathcal{M}_n}{n} = \sum\limits_{i=0}^k(n_i - 1)\dfrac{\prod_{j=i}^k n_j-1}{\prod_{j=i}^k n_j}$, что переписывается как\\
		$\frac{\mathcal{M}_n}{n} = \sum\limits_{i=0}^k(n_i - 1) - \sum\limits_{i=0}^k\dfrac{(n_i - 1)}{\prod_{j=i}^k n_j}$.
	\end{center}
	Рассмотрим вторую сумму, входящую в это выражение, и после\\ умножения ее на $n$. Получим \\
	\begin{center}
		$\sum\limits_{i=0}^k(n_i - 1) \prod_{j=0}^{i-1} n_j$, что в точности равно $n-1$.
	\end{center}
	
	\medskip
	
	\noindent\textit{\textbf{Преобразование Фурье на 2000 точках (продолжение)}}\\
	\indent Вместо разложжения на 2000 в произведение $40\times50$ рассмотрим $2^4\times5^3$. \\ Применяя рекурсивно метод Кули~---Тьюки к множителям 2 и 5, полу-\\чим 24 000 умножений. Если сравнить этот результат с полученными\\ ранее, то можно увидеть, что произошло увеличение эффективности \\ примерно в 7 раз. Округленно число умножений уменьшилось в 166 раз\\ по отношению у наивному методу.\\
	
	\noindent\textbf{(24) Следствие.}\\
	\indent\textit{Пусть $n$ — целое число, представимое в виде $n= {q_1^{\alpha_1}}{q_2^{\alpha_2}}\cdots{q_k^{\alpha_k}}$, где \\ $q_i$ не обязательно простые. Число $\mathcal{M}_n$ необходимых умножений при}
		\newpage
		\lhead{\small\textit{V-4.2.2\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \rhead{623}
\noindent вычислении преобразования Фурье по методу Кули~---Тьюки дается \\ выражением $\mathcal{M}_n/n = \alpha_1(q_1-1) + \alpha_2(q_2-1) +\cdots+\alpha_k(q_k-1) + (n-1)/n$,\\ что можно переписать в виде \\
\begin{center}
	$\dfrac{\mathcal{M}_n}{n\log(n)} \approx \sum\limits^k_{i=1} \mu_i\times\dfrac{q_i-1}{\log(q_i)}$, где $\mu = \frac{\log(q_i^{\alpha_i})}{\log(n)}$ и $\sum\limits_i^k \mu_i = 1$.\\
\end{center} 
\textit{Выражение слева — средневзвешенное слагаемых $(q_i-1)/\log(q_i)$ , где \\ веса $\mu_i$ представляют вклад множителей $q_i^{\alpha_i}$ в $n$}\\

\indent{Вот таблица некоторых значений $(q-1)/\log(q)$для целого $q$. Из нее\\ видно, что это обозначение минимально при $q=2$.\\
\begin{center}
\begin{tabular}[t]{|p{3em}|p{25em}|}
\hline
$q$ & $2$ \qquad $3$ \qquad $4$\qquad $5$\qquad $6$\qquad $7$ \qquad$8$\qquad $9$\qquad $10$\\
\hline
$\dfrac{q-1}{\log(q)}$ & $1.44$\quad $1.82$\quad $2.16$\quad $2.48$\quad $2.79$\quad $3.08$\quad $3.36$\quad $3.64$\quad $3.90$\\
\hline
\end{tabular}
\end{center}

Например, для $n$, имеющего вид $n = 2^{\alpha}3^{\beta}5^{\gamma}$, получим 

\medskip

${\mathcal{M}_n \over {n loq (n)}} \approx {{{\mu_{\alpha}} \over {log(2)}} + {2\mu_{\beta} \over {log(3)}} + {{4\mu_{\gamma}} \over {log(5)}}}$, где  $\mu_{\alpha} + \mu_{\beta} + \mu_{\gamma} = 1$

\medskip

 \hspace{4cm} и тогда ${\mathcal{M}_n \over {n log (n)}} \approx 2,16$. \\

Интуитивно ясно, что метод Кули---Тьюки тем эффективнее, чем\\ меньше простые числа, входящие в разложение $n$.

\medskip
\textbf{4.2.2 Формулы для итераций по методу Кули \title-— Тьюки}

\medskip
\indent Метод Кули---Тьюки для произвдения двух чисел $p$ и $q$ приво-\\ дит к разложению двух индексов $i$ и $j$, взаимодействующих в сумме \\ $\widehat{f} (j)$ = $\sum f(i)\omega^{ij}$, где $i = i_{1}p + i_0$ и $j = j_0 + j_{1}q$. Если теперь рассмо-\\треть случай, когда $n$--- произведение $k+1$ целых чисел, то получим \\ начальное разложение $i = \alpha n_0 + i_0$ согласно евклидову делению на $n_0$, \\ удовлетворяющему условиям $0\leqslant i < n_0$ и $0\leqslant \alpha < \pi_k$. Продолжив про-\\цесс раздожения $\alpha$ с помощью евклидова деления на $n_1 \cdots$, получим в\\ результате\\
\indent $i = i_0 + i_{1}\pi_1 + i_{2}\pi_2 + \cdots + i_{k}\pi_k$,\qquad где $0\leqslant i_x < n_x$ для $0\leqslant x \leqslant k$. 

\medskip
\noindent Аналогичным образом, индекс $j$ может быть разложен при помощи ев-\\клидова деления на $\pi^1$ и далее, итеративным образом, на $\pi^1 \cdots$ до по-\\лучения $j = j_0 + j_{1}\pi^1 + j_{2}\pi^2 + \cdots + j_{k}\pi^k$, где $0\leqslant j_x < n_{k-x}$. И теперь\\ видно появление смешанной системы счисления из главы IV.
\newpage

\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \lhead{624}

\begin{flushleft}
  \begin{small}
		\hspace{1cm} \textbf{Замечание.} Напомним опять, что если целые $n_x$ в этом равен-\\ \hspace{1cm} стве все равны $b$, то приходим к обычному понятию позиционнной \\ \hspace{1cm} нумерации: $\pi_x = \pi^x = b^x$. Это оправдывает индексацию соста-\\ \hspace{1cm} вляющих $n$, начиная с 0. Так же замечаем, что смешанная система\\  \hspace{1cm} счисления, в которой разлагается индекс $i$, связана с представле-\\ \hspace{1cm} нием $n$ в виде произведения $n={n_0}{n_1}{n_2}\cdots{n_k}$, тогда как относит-\\ \hspace{1cm} тельно $j$ она связана с \textit{обратным порядком} $n={n_k}{n_{k-1}}\cdots{n_0}$.
	\end{small}
	\end{flushleft}
\indent В выражении $\omega^{ij}$, встречающемся в сумме $\sum f(i) \omega^{ij}$, можно заме-\\нить $ij$ на любое число, сравнимое с $ij$ по модулю $n$ (поскольку $\omega$~---\\ корень $n$-й степени из единицы). Это мы будем делать, пользуясь \\ тем, что когда $x+y \geqslant k+1$, то $\pi_x\pi^y\equiv 0 (\mod n)$. Следовательно,\\ величина $ij$ эквивалентна по модулю $n$ следующим двум выражениям\\ треугольной формы:
\begin{small}
\columnseprule = 0.3pt\columnsep=24pt 
\begin{multicols}{2}
\begin{align*}
ij &\equiv (j_k\pi^k +\cdots+ j_1\pi^1+ j_0\pi^0)i_0\pi_0\\
&+(j_{k-1}\pi^{k-1} +\cdots+ j_1\pi^1+ j_0\pi^0)i_1\pi_1\\
&\vdots\\
&+ (j_1\pi^1 + j_0\pi^0)i_{k-1}\pi_{k-1}\\
&+ (j_0\pi^0)i_k\pi_k,\\
\end{align*} 

\begin{align*}
ij &\equiv (i_0\pi_0)j_k\pi^k\\
&+ (i_0\pi_0 + i_1\pi_1)j_{k-1}\pi^{k-1}\\
&\vdots\\
&+(i_0\pi_0 + i_1\pi_1 +\cdots+ i_{k-1}\pi_{k-1})j_1\pi^1\\
&+(i_0\pi_0 + i_1\pi_1 +\cdots+ i_k\pi_k)j_0\pi^0.\\
\end{align*}
\end{multicols}
\end{small}
\noindent Используем теперь левое представление произведения $ij$ (для использо-\\ вания выражения справа см. упражнение18). Благодаря такому пред-\\ставлению $ij$ по модулю $n$, покажем, как сумма
$\widehat{f}(j)$ может быть разло-\\жена в подсуммы $\widehat{f(j)} = \sum_{i_0}\sum_{i_1}\dots\sum_{i_k}\dots$ Для этого введем обозначе-\\ние, относящееся к смешанной системе счисления с базой \{$\pi^0,\pi^1,\dots\pi^k$\}.\\В виду нашего выбора девого представления, эта база будет использо-\\ваться чаще другой.\\

\textbf{(25) Обозначение.}\\

\textit{Пусть дана последовательность $j_0,j_1,\dots, j_m,$, удовлетворяющая со-\\отношениям $0\leqslant j_0 < n_k$, $0\leqslant j_1 < n_{k-1}$,\dots, $0\leqslant j_m < n_{k-m}$. Обозначим \\ $\langle {j_m}{j_{m-1}}\dots{j_0} \rangle = j_m\pi^m + j_{m-1}\pi^{m-1} + \dots + j_0\pi^0$.}\\

\textbf{(26) Теорема.}

\textit{Определим последовательность функций [0, $n [\rightarrow A, (F_m)_{0\leqslant m \leqslant k+1}$ \\ следующим образом:}\\
	$F_0(t_0\pi^k + t_1\pi^{k-1} + \dots + t_k\pi^0)= F_0\langle t_0t_1\dots t_k\rangle = ^{def} f(t_k\pi_0+\dots+t_1\pi_1 +t_0\pi_0)$,
\newpage
\lhead{\small\textit{V-4.2.2\qquad Формулы для итерация по методу Кули-~Тьюки}}
   \rhead{625}
\textit{а для $0\leq m < k+1$ положим:}\\

	$F_{m+1}\langle t_0t_1\dots t_{k-m-1}\textbf{t}_{k-m}t_{k-m+1}\dots t_{k-1}t_k\rangle =$ \\
	
	$\sum\limits_{s=0}^{n_{k-m}-1} F_m\langle t_0t-1\dots t_{k-m-1}\textbf{s}t_{k-m+1}\dots t_{k-1}t_k\rangle {*}\omega^{s\pi_{k-m}\langle t_{k-m}t_{k-m+1}\dots t_k\rangle}$.\\
\textit{При этих обозначениях функция $F_{k+1}$ является преобразованием фурье\\ $\widehat{f}$ для $f$.}\\

\textbf{Доказательство.}

\MYvrule \begin{wraptable}{}{0.4\textwidth}
\begin{align*}
	\widehat{f}(j) &= \sum_{i_0} \omega^{i_0\pi_0\langle j_kj_{k-1}\dots j_1j_0\rangle}\\
	&\times \sum_{i_1} \omega^{i_1\pi_1\langle j_{k-1}\dots j_1j_0\rangle}\\
			&\vdots\\
			&\times \sum_{i_k} \omega^{i_k\pi_k\langle j_0\rangle}\\
				&\times f(i_0\pi_0 + i_1\pi_1 + \cdots + i_k\pi_k)
\end{align*}				
\end{wraptable}
\noindent Используя явное разложение $ij$ с помощью треугольного выражения в левой части формулы (8) для записи суммы $\widehat{f}(j)$, как указано слева. Преобразуем теперь выражение $f(i_0\pi_0+\cdots)$ в $F_0\langle i_0i_1\dotsi_k\rangle$ и обозначим через 
			\noindent$F_1$ в самую внутреннюю подсумму в выражении для $\widehat{f}(j)$ (с индексом $i_k$), через $F_2$ следующую подсумму (с индексом $i_{k-1}$) и т.д\dots
			Заметим, что первая подсумма, обозначенная через $F_1$, зависит от  индексов $i_0$, $i_1$, \dots, $i_{k-1}$ и $j_0$, следующая подсумма $F_2$ зависит от  индексов $i_0$, $i_1$, \dots, $i_{k-1}$ и $j_0$ и $j_1$. Продолжая прослеживать эти зависимости, обнаруживаем, что число слагаемых индекса $i$ уменьшается, тогда как число составляющих $j$ увеличивается при продвижении от $F_1$ до $F_{k+1}$. Это дает возможность записать явные  формулы в формулировке теоремы, вводя их теперь для $i$ и $j$ вместо безымянного индекса $t$.
			\begin{align*}
			F_1\langle i_0i_1\dotsi_{k-1}\textbf{j}_0\rangle &= \sum\limits_{i_k} F_0\langle i_0i_1\dotsi_{k-1}\textbf{i}_k\rangle\omega^{i_k\pi_k\langle j_0\rangle},\\
		F_2\langle i_0i_1\dots i_{k-2}\textbf{j}_1j_0\rangle &= \sum\limits_{i_{k-1}}F_1 \langle i_0i_1\dots\textbf{i}_{k-1}j_0\rangle\omega^{i_{k-1}\pi_{k-1}\langle j_0\rangle},\\
			&\vdots \\
			F_{m+1}\langle i_0i_1\dots i_{k-m-1}\textbf{j}_m\dots j_0\rangle &= \sum\limits_{i_{k-m}}F_m \langle i_0i_1\dots\textbf{i}_{k-m}j_m\dots j_0\rangle
			\end{align*} 
			$\hspace{8cm}\times\omega^{i_{k-m}\pi_{k-m}\langle\textbf{j}_m{\ldots}j_1j_0\rangle},$
			
	\newpage 
	\rhead{\small\textit{V-4\qquad Подробное рассмотрение метода Кули и Тьюки}}
   \lhead{626}
   
\MYvrule \begin{align*}
F_k\langle i_0\textbf{j}_{k-1}{\dots}j_1j_0\rangle &= \sum\limits_{i_1}F_{k-1} \langle i_0\textbf{i}_1j_{k-2}{\ldots}j_1j_0\rangle\\
&\times \omega^{i_1\pi_1\langle\textbf{j}_{k-1}j_{k-2}\ldots j_0\rangle},\\
\hat{f}(j) = F_k\langle \textbf{j}_{k}j_{k-1}{\ldots}j_1j_0\rangle &= \sum\limits_{i_0}F_k\langle\textbf{i}_0j_{k-1}j_{k-2}{\ldots}j_1j_0\rangle\\   &\times \omega^{i_0\pi_0\langle \textbf{j}_kj_{k-1}\ldots j_0\rangle}.
\end{align*}
\noindent Можно также доказать для $m \in [0, k+1]$ следующее инвариантное \\ соотношение (полезное для доказательства корректности алгорит*\\ма, реализующего \large{$F$}$FT$):\\
\normalsize
\begin{center}
$F_m\langle i_0i_1{\ldots}i_{k-m}j_{m-1}j_{m-2}{\ldots}j_1j_0\rangle =$ 
\end{center} 
 $\sum\limits_{i_k{,}i_{k-1}{,}{\ldots}i_{k-m}} F_0 \langle i_0i_1{\ldots}i_{k-1}i_k\rangle \times
\omega^{{\pi_{k-m+1}{\langle}i_ki_{k-1}\ldots j_{k-m+1}\rangle}_\pi{{\langle}j_{m-1}j_{m-2}\ldots j_1j_0\rangle}^\pi}$,\\
из которого легко усматривается смысл обозначений $\langle{\ldots}\rangle_\pi$ и $\langle{\ldots}\rangle^\pi$ 

\bigskip

\textbf{(26) Определение.}

\indent \textit{С данными $k+1$ целыми числами $n_0, n_1, \ldots , n_k$ и их произведением\\ $ n = n_0n_1{\ldots}n_k$ связана инволюция интервала $[0, n[,$, обозначаемая $s\longmapsto \tilde{s}$\\ и определенная формулами:}
\begin{center}
	\begin{align*}
 s = s_0\pi_0 &+ s_1\pi_1 + \cdots + s_{k-1}\pi_{k-1}+ s_k\pi_k \longmapsto \\ &\longmapsto \tilde{s} = s_k\pi^0 + s_{k-1}\pi^1 + \cdots + s_1\pi^{k-1} + s_0\pi^k .  
\end{align*}
\end{center}	       	
\textit{Инволюция переводит число в системах счисления {$\pi_q$} или {$\pi^q$} в це-\\лое  число, имеющее инверсное представление в этом же интервале в \\ дуальной системе счисления.}\\
\indent В свете этих новых обозначений можно переформулировать теоре-\\му 26: \\ 

\textbf{(28) Следствие} ( << формулы >> для программирования).

\indent\textit{Пусть $f: [0, n[ \longrightarrow A $. Определим последовательность \textbf{$k+2$ массивов}\\ $F_0, F_1, \ldots F_{k+1}$ с индексами в интервале $ [0, n[$ рекурентным соотноше-\\нием, которое применяется при} $0\leqslant m< k +1$:\\
\begin{align*}
F_{m+1}\langle &t_0t_1{\ldots}t_{k-m-1}t_{k-m}t_{k-m+1}{\ldots}t_k\rangle = \\
&=\sum_{s=0}^{n_{k-m}-1}F_m \langle t_0t_1{\ldots}t_{k-m}\textbf{s}t_{k-m+1}\ldots t_k\rangle \times
\omega^{{s\pi_{k-m}{\langle}t_{k-m}\ldots t_{k}\rangle}_\pi{\langle j_{m-1}j_{m-2}\ldots j_1j_0\rangle}^\pi},
\end{align*}
\newpage
\lhead{\small\textit{V-5\qquad Метод Гуда}}
   \rhead{627}
 
 \noindent\textit{массив $F_0$ имеет начальное значение $F_0[t]= f(\tilde{t})$. Тогда последний \\ массив $F_{k+1}$ дает преобразование Фурье $\hat{f}$ для $f$, $F_{k+1}(j)=\hat{f}(j)$ при \\ $0\leqslant j < n $.}\\
 \indent Напомним, что это формулировка, частный случай которой для \\ $n=2^k$ дан в лемме 13, была использованна в теореме 3.1 для реализа-\\ции \large{$F$}$FT$.\\
 
 \large{\textbf{5 Метод Гуда}}
 
 \medskip
 \normalsize Тогда как метод Кули и Тьюки применим, когда число точек, в которых \\ происходит вычисление значений/число точек интерполяции, является\\ сильно составным ( как в случае, когда оно является степенью просто-\\го числа), метод Гуда применяется лишь тогда, когда это число раз-\\лагается в произведение попарно взаимно простых множителей. Этот \\ метод, опубликованный Гудом в 1958 году в статье : $ The interaction of al-\\gorithm and practical Fourier series$, опережает по времени метод Кули \\ ~---Тьюки (1965). Он еще более сокращает количество умножений, необ-\\ходимых для вычисления дискретного преобразования Фурье, и делает \\ разложение \large{$D$}$FT$ \normalsize весьма однородным.\\
 
 \textbf{\large{5.1 Исследование примера} $15 = 3 \times 5$} \\
 \scriptsize
 $\begin{pmatrix}
 \hat{a}_0 \\ \hat{a}_3 \\ \hat{a}_6\\ \hat{a}_9\\ \hat{a}_{12} \\ \\\hat{a}_5 \\ \hat{a}_8 \\ \hat{a}_{11}\\ \hat{a}_{14}\\ \hat{a}_2 \\ \\ \hat{a}_{10} \\ \hat{a}_{13} \\ \hat{a}_1 \\ \hat{a}_4 \\ \hat{a}_7
 \end{pmatrix}= 
 \begin{pmatrix}
 \begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} \\
 
 \begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \xi^1\begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \xi^2\begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix}\\
 
 \begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \xi^2\begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix} & \xi^1\begin{bmatrix}
 1&1&1&1&1\\ 1&\eta^1&\eta^2&\eta^3&\eta^4\\ 1&\eta^2&\eta^4&\eta^1&\eta^3\\ 1&\eta^3&\eta^1&\eta^4&\eta^2\\ 1&\eta^4&\eta^3&\eta^2&\eta^1\\
 \end{bmatrix}
 \end{pmatrix}
 \begin{pmatrix}
 a_0 \\ a_6 \\ a_6\\ a_9\\ a_{12} \\ а_3 \\ a_9 \\\\ a_{10}\\ a_1\\a_7\\a_{13} \\ a_4 \\\\ a_5 \\ a_{11} \\a_2\\ a_8 \\ a_{14}
 \end{pmatrix} $ \\
 \normalsize
 \indent Пусть $\omega$ ~--- корень 15 степени из единицы, $\xi = \omega^5$ ~--- корень кубиче-\\ский из единицы, а $\eta = \omega^3$ ~--- корень пятой степени из единицы. Тогда \\ можно записать \large{$D$}$FT_{15}$ \normalsize указанным выше образом (здесь нужно обра-\\тить внимание на перестановки, произведенные вначале на элементах\\ $a_i$, а в конце~-- на элементах $\hat{a_i}$). \\ 
 \indent Далее покажем, что это равенство есть ничто иное, как применение \\ каитайской теоремы об остатках, которая утверждает, что фддитив-\\ные группы $\mathbb Z_{15}$ и $\mathbb Z_3\times\mathbb Z_5$ изоморфны.Если рассмотреть две матрицы  
 \newpage
 \normalsize
\rhead{\small\textit{V-5\qquad Метод Гуда}}
   \lhead{628}
\normalsize
\noindent Вандермонда $V_3$ и $V_5$, ассоциированные, соответственно, с корнями из \\ единицы $\xi$ и $\eta$, то метод Гауда реализует вычисление преобразования \\ Фурье в два этапа. Первый состоит из 3 преобразований Фурье на 5 \\ точках:\\ 

$\begin{pmatrix}
b_0 \\ b_1 \\ b_2 \\ b_3 \\ b_4
\end{pmatrix} = V_5\begin{pmatrix}
a_0 \\ a_6 \\ a_{12} \\ a_3 \\ a_4
\end{pmatrix}$, \qquad  
$\begin{pmatrix}
b_5 \\ b_6 \\ b_7 \\ b_8 \\ b_9
\end{pmatrix} = V_5 
\begin{pmatrix}
a_{10} \\ a_1 \\ a_7 \\ a_{13} \\ a_4
\end{pmatrix}$, 
$\begin{pmatrix}
b_{10} \\ b_{11} \\ b_{12} \\ b_{13} \\ b_{14}
\end{pmatrix} = V_5 \begin{pmatrix}
a_5 \\ a_{11} \\ a_2\\ a_8 \\ a_{14}
\end{pmatrix}$.\\
  
\noindent Второй этаап состоит из 5 преобразований Фурье на 3 точках:\\

$\begin{pmatrix}
\hat{a}_0 \\ \hat{a}_5 \\ \hat{a}_{10} 
\end{pmatrix} = V_3 
\begin{pmatrix}
b_0 \\ b_5 \\ b_{10} 
\end{pmatrix}$, 
$\begin{pmatrix}
\hat{a}_3 \\ \hat{a}_8 \\ \hat{a}_{13} 
\end{pmatrix} = V_3
\begin{pmatrix}
b_1 \\ b_6 \\ b_{11} 
\end{pmatrix}$, 
$\begin{pmatrix}
\hat{a}_6 \\ \hat{a}_{11} \\ \hat{a}_1 
\end{pmatrix} = V_3 
\begin{pmatrix}
b_2 \\ b_7 \\ b_{12} 
\end{pmatrix}$, \\
\begin{center}

	$\begin{pmatrix}
	\hat{a}_9 \\ \hat{a}_{14} \\ \hat{a}_4 
	\end{pmatrix} = V_3
	\begin{pmatrix}
	b_3 \\ b_8 \\ b_{13} 
	\end{pmatrix}$,	
	$\begin{pmatrix}
	\hat{a}_{12} \\ \hat{a}_2 \\ \hat{a}_7 
	\end{pmatrix} = V_3
	\begin{pmatrix}
	b_4 \\ b_9 \\ b_{14} 
	\end{pmatrix}$.
\end{center}
\noindent Это означает, что вычисления по методу Гуда дискретного преобразо-\\вания Фурье на 15 точках сводится к 3 вычислениям преобразований\\ Фурье порядка 5 плюс 5 вычислений преобразований Фурье порядка $3$:\\
$\textbf{Good}_{15,\omega} \equiv 3 DFT_{5. \omega^3} \oplus 5 DFT_{3, \omega^5}$. Сложность этого вычисления ~--- \\ 90 сложений и 68 умножений (вместо 90 сложений и 76 умножений в \\ методе Кули~---Тьюки).\\
\indent Первое обоснование предыдущего разложения дается слежующим \\ полиномиальным тождеством (справедливым в факторкольце $A[X]/\\(X^15 - 1)$:\\
\begin{align*}
\sum a_iX^i &= (a_0 + a_6X^6 + a_{12}X^{12} + a_3X^3 + a_9X^9) + \\ &+ X^{10}(a_{10} + a_1X^6 + a_7X^{12} + a_{13}X^3 + a_4X^9) +\\ &+X^5(a_5 + a_{11}X^6 + a_2X^{12} + a_8X^3 + a_{14}X^9).
\end{align*} \\ 
Полагая (как в начале изучения метода Кули~--Тьюки) $P_0(X) = a_0 + \\ a_6X^6 + a_{12}X^{12}+ a_3X^3 + a_9X^9, P_1(X) = a_{10} + a_1X^6 + a_7X^{12}+ a_{13}X^3 + a_4X^9 $ \\ и $P_2(X) = a_5 + a_{11}X^6 + a_2X^{12}+ a_8X^3 + a_{14}X^9 $, определим $b_j$ следующим \\ образом: \\
\begin{align*}
b_0&=P_0(1)  &\qquad b_1&=P_0(\omega^3) &\qquad b_2&=P_0(\omega^1) &\qquad b_3&=P_0(\omega^4) &\qquad b_4&=P_0(\omega^2)\\
b_5&=P_1(1) &\qquad b_6&=P_1(\omega^3) &\qquad b_7&=P_1(\omega^1 &\qquad b_8&=P_1(\omega^4) &\qquad b_9&=P_1(\omega^2) \\
{b_{10}}&=P_2(1) &\qquad {b_{11}}&=P_2(\omega^3) &\qquad {b_{12}}&=P_2(\omega^1) &\qquad {b_{13}}&=P_2(\omega^4) &\qquad {b_{14}}&=P_2(\omega^2).
\end{align*} 
\newpage
\lhead{\small\textit{V-5.2\qquad Теорема Гуда}}
   \rhead{629}
\begin{large}
\noindent \textbf{ 5.2 Теорема Гуда}	
\end{large}

\medskip
\noindent Прежде, чем говорить о теореме Гуда, введем сначала некоторые опре-\\деления, необходимые впоследствии. Такой способ позволит, в свое вре-\\мя, быстрее сконуентрироваться на основной идее Гуда, не спотыкаясь \\ о незнакомые понятия.\\
\indent В этом разделе индексы используемых матриц начинаются с нуля, а \\ не с 1, так как в конце мы применим полученные результаты к матри-\\ цам Вандермонда. Но это не относится к следующему определению. \\

\noindent\textbf{(29) Определение.} 

\medskip
\indent \textit{ Для любой $n\times m$-матрицы $A$ и $p{\times}q$-матрицы $B$} \textbf{тензорное про-\\изведение} $A\otimes B$ \textit{есть $np\times qm$-матрица, имеюзая следующую блочную\\ запись:} \\
\begin{center}
	$A\otimes B = 
	\begin{pmatrix}
	a_{11}B &  a_{12}B & \ldots & a_{1m}B\\
	a_{21}B &  a_{22}B & \ldots &   a_{2m}B\\
	\vdots & \vdots & \vdots & \vdots \\ 
	a_{n1}B &  a_{n2}B & \ldots &  a_{nm}B
	\end{pmatrix}
	 = C$,
\end{center}
\noindent\textit{ это можно записать для матрицы, индексы которой начинаются с нуля, \\ следующим образом:} $c_{pi_1+i_2, qj_1 + j_2} = a_{i_1, j_1}b_{i_2, j_2}$. \\ 

\noindent \textbf{(30) Определение и свойства.}

\medskip
\indent\textit{ $(i)$  Пусть $\sigma$~--- перестановки интервала $[0, n[$.} \textbf{Перестановочная \\ матрица} $P_\sigma$ -~ \textit{это матрица, определенная по правилу: $P_\sigma(e_j) = e_{\sigma(j)}$, \\ если $e_0, e_2, \ldots , e_{n-1}$ ~-- канонический базис}\\
	\indent \textit{($ii$) Для $a = (a_0, \ldots, a_{n-1})$ обозначим через $a_\sigma$ $n$-ку ($a_{\sigma(0)}, \ldots ,\\ a_{\sigma(n-1)}$); заметим, что $a_\sigma = P_{\sigma^{-1}}(a)$.} \\
		\indent\textit{($iii$) Умножение слева матрицы порядка $n$ на матрицу  $P_\sigma$ соответ-\\ствует перестановке строк матрицы под действием перестановки $\sigma$.\\Аналогичным образом, умножение справа матрицы порядка $n$ на ма-\\трицу $P_{\sigma^{-1}}$ соответствует перестановке столбцов матрицы под дей-\\ствием перестановки $\sigma$.} \\
			\indent\textit{($iv$) Более формально: пусть дана квадратная матрица $V$ порядка \\ $n$, тогда матрица $W = P_\sigma V P_{\tau^{-1}}$ ~--- матрица, полученная из $V$ переста-\\новкой строк и столбцов, отвечающих перестановкам $\sigma$ и $\tau$, соответ-\\ственно, эти две матрицы связаны соотношением $W_{\sigma(i)\tau((j))} = V_{ij}$}. \\ 
			
				\noindent \textbf{(31) Свойство} (тензорного произведения матриц).
				
				\smallskip
			\indent \textit{Пусть $A$ и $B$ ~---две квадратные матрицы произвольных порядков.\\Тогда $A\otimes B$ и $B\otimes A$~--- подобные матрицы, связанные соотношением}
			\newpage
\rhead{\small\textit{V-5\qquad Теорема Гуда}}
   \lhead{630}
\noindent \textit{ $A\otimes B = P_i(B\otimes A)P_i$, где $i$~--- известная инволюция, переставляющая \\ представление целого числа в двух смешанных дуальных системах счи-\\сления, определенных через размерности матриц ( см.определение 27). } \\ 
\indent На протяжении всего этого раздела рассматривается целое число $n$, \\ представимое в виде произведения $ n = pq$, где $p$ и $q$ взаимно просты.\\ Часто будет использоваться соотношение Безу $up + vq = 1$. Матрица \\ $V$ является матрицей Вандермонда, ассоциированной с $\omega$, корнем $n$-й \\ степени из 1, т.е. $V = (\omega^{ij})$.\\
\indent Как видно из примера $DFT_{15}$, можно ввести в вычисление дискрет-\\ного преобразования Фурье тензорные произведения преобразований \\ Фурье. Следующая лемма является лишь одним из этапов этого по-\\строения. \\ 

\noindent\textbf{ (32) Лемма.}\\
\indent \textit{Пусть $\tau$~--- перестановка интервала $[0, n[$, определнная по правилу \\ $\tau(x) = vqx_1 + upx_2 \mod n$, где $(x_1,x_2)$~--- запись $x$ в смешанной системе \\ счисления $(p, q): x = x_1q+x_2$. Важно заметить, что эта перестановка зависит лишь от $p$ и $q$, и не зависит от $u$ и $v$, и тесно связана с китай-\\ской теоремой об остатках в следующем смысле : $\tau(x)$~-- единственное целое число в интервале  $[0, n[$, для которого $\tau(x)\equiv x_1\mod q$ и $\tau(x)  \equiv\\ x_2\mod p$.} \\
\indent \textit{При этих условиях $V = P_\tau(V'_p \oplus V'_q)P_{\tau^{-1}}$ ~--- выражение, где $V'_p$~---\\матрица Вандермонда, ассоциированная с корнем $p$-й степени из еди-\\ницы $\omega ^{vq}$, а $V'_q$~--- матрица Вандермонда, ассоциированная с корнем  $q$-й\\ степени из единицы $\omega ^{up}$}.\\

\noindent\textbf{Доказательство.}\\
\MYvrule \noindent В выражении преобразования Фурье $\hat{a}_j = \sum a_i\omega^{ij}$ представим $i$ и \\ $j$ как явные функции вычетов $i_p, i_q, j_p, j_q$ по модулям $p$ и $q$ (используя \\ явные формулы китайском теоремы об остатках). Тогда получим : \\ \begin{center}
	$\hat{a}_j = \sum _i \omega ^{(vqi_p + upi_q)(vqj_p + upj_q} = \sum _i \omega^{vqi_pj_p}\omega^{upi_qj_q}$, 
\end{center}
так как $up$ и $vq$ ~---ортогональные индемпотенты по модулю $n$. Сле-\\довательно, матрица $V$ имеет в качестве своего общего элемента с \\ координатами ($i, j$) произведение  ($\bar{\xi}^{i_pj_p}\bar{\eta^{i_qj_q}}$), где $\bar{\xi} = \omega ^{ij}$ и $\bar{\eta} = \omega^{up}$ .\\ Здесь уже можно видеть, как появляется тензорное произведение, \\ к котрому мы стремимся.\\
	Если обозначим через $V'_p = (\bar{\xi}^{ij})$ матрицу порядка $p$, а через \\ $V'_q = (\bar{\eta}^{ij})$~--- матрицу порядка $q$, то (по определению 29) можно \\ заметить, что элементы с индексами ($i, j$) матрицы $V'_p\otimes V'_q$ суть	
	\newpage 
	\lhead{\small\textit{V-5.2\qquad Теорема Гуда}}
   \rhead{631}
	
	\MYvrule \noindent ($\bar{\xi^{i_1j_1}}\bar{\eta^{i_2j_2}}$), где $i_1, i_2, j_1, j_2$~---цифры чисел $i, j$ в базисе $(p, q)$, т.е. $i_1$\\ и  $i_2$ ~--- соответственно частное и остаток от евклидова деления $i$  на \\$q$, тоже самое для  $j$\ldots. Объединяя предыдущие два абзаца, обнару-\\живаем, что выражение $\bar{\xi}^{i_1j_1}\bar{\eta^{i_2j_2}}$ совпадает с элементом матрицы \\ $V$, расположенными в позиции ($vqi_1 + upi_2, vqj_1 + upj_2$), и с элемен-\\том матрицы $V'_p \otimes V^`_q$, расположенными в позиции  ($qi_1 + i_2, qj_1 + j_2$). \\ Положив $i = qi_1 + i_2$ и  $j = qj_1 + j_2$, получаем $(V'_p \otimes V'_q,)_{ij} = V_{\tau(i)\tau(j)}$, \\ другими словами, $V = P_\tau(V'_p \otimes V'_q,)P_{\tau^{-1}}$, равенство, содержащееся в \\ формулировке леммы.
			
			\bigskip
			 
			  Итак, нам удалось представить дискретное преобразование Фурье \\ порядка $pq$ как тензорное произведение двух дискретных преобразова-\\ ний Фурье порядка $p$ и порядка $q$, но корни из единицы,используемые \\ в этих вторичных преобразованиях, не вполне нас устраивают. Дей-\\ствительно, они не являются \textit{\textbf{каноническими}} корнями порядков $p$ и $q$,\\ $\omega^p$ и $\omega^q$. Наша цель теперь состоит в том, чтобы распространить полу-\\ченный в предыдущей демме результат на хорошие корни порядка $p$ и\\ $q$ с помощью небольшего доролнительного изменения \ldots\\
			
			\noindent \textbf{(33) Лемма.}
			
\indent\textit{Пусть $\xi = \omega^q, \eta = \omega^p, V_p$ и $V_q$ ~---матрицы Вандермонда, ассоцииро-\\ванные с корнями $\xi$ порядка $p$, и  $\eta$ порядка $q$, соответственно. Обозна-\\чим через $\sigma$ перестановку интервала $[0, [n$, определенную следующим \\ образом: $\sigma(qx_1 + x_2) = qx_1 +qx_2 \mod n$ c обычными соглашениями. То-\\гда можно записать:}
			\begin{center}
				$V = P_\sigma(V_p\otimes V_q)P_{\sigma^{-1}} = P_\sigma(V_p \otimes V_q)P_{\tau^{-1}}$,
			\end{center}
			\textit{где $\tau$~---перестановка, введенная в предыдущей лемме.} \\
			
			\noindent\textbf{Доказательство.}
			
			\MYvrule \noindent Если $i = i_1q + i_2$ и $j = j_1q + j_2$, то имеем \begin{center}
				$(V_p\otimes V_q)_{i, j} = (\omega^q)^{i_1j_1}(\omega^p)^{i_2j_2} = (\omega^{vq})^{qi_1j_1}(\omega^{up})^{pi_2j_2},$ 
			\end{center}
			так как $vq^2 \equiv q (\mod n)$ и $up^2 \equiv p (\mod n)$. Введя матрицы $V'_p$ и $V'_q$, можно переписать это выражение двумя разными способами:\\
			\begin{center}
			$(V'_p\otimes V_q)_{i_1q+i_2, q(qj_1 \mod p) + (pj_1 \mod q)} =$ \\ $= (V_p\oplus V_q)_{i, j} = (V_p^`\otimes V_q^`)_{q(qi_1\mod p) +(pi_2 \mod q), j_1q + j_2.}$
					\end{center} 
\noindent Эти два выражения симметричные относительно $i$ и $j$, появляются \\ (либо то, либо другое) в зависимотси от того, куда решают отнести 

 \newpage 
	\rhead{\small\textit{V-5\qquad Метод Гуда}}
   \lhead{632}
	
	\MYvrule\noindent изменения показателя -~ в $i$ или в $j$. Если положить $\alpha(x) = \\ q(qx_1 \mod p) + (px_2 \mod q)$, то получим, что 
	\begin{center}
		$(V_p\otimes V_q)P_{\alpha^{-1}} = V_p^`\otimes V_q^` = P_\alpha (V_p \otimes V_q).$
	\end{center} 
	В заключение остается лишь вычислить произведение $\alpha$ и $\tau$. 
	\begin{align*}
	\tau\alpha(qx_1 + x_2) &= \tau(q(qx_1 \mod p) + (px_2 \mod q)) = \\ &= vq(qx_1 \mod p) + up(px_2 \mod q).
	\end{align*}
	Используя тот факт, что $b(a\mod c) \equiv a (\mod bc)$, последнее выра-\\жение переписывается в виде $qx_1 + px_2$, что в точности есть $\sigma(x)$ в \\ обозначениях леммы.
	
	\medskip
	
	\noindent \textit{\textbf{Пример}} \\
	\indent Для $p=3, q=5, n=15$ выбираем $u=2$ и $v=-1$, что дает $up = 6$\\ и $vq = -5$. Тогда определим перестановки $\sigma$ : $i = 5i_1 + i_2 \mapsto \sigma(i) = \\ 5i_1 + 3i_2 \mod 15$ и $\tau$ : $j = 5j_1 + j_2 \mapsto \tau(i) = - 5j_1 + 6j_2 \mod 15$, что \\ позволяет проиллюстрировать метод Гуда на примере $3\times5$, используя \\ соотношение $\hat{a}_\sigma = V_p \otimes V_q(a_\tau)$. \\
	\indent Теперь совсем просто получить теорему Гуда, резюмирующую пре-\\дыдущие рассуждения. 	
	
	\medskip
	\noindent \textbf{(34) Теорема}(Гуда). \\ 
	\indent\textit{Рассмотрим два взаимно простых числа $p$ и $q$ и тождество Безу \\$up + vq = 1$. Пусть $V_p = (\omega^{qij})$ и $V_q = (\omega^{pij})$~--- матрицы Вандермонда, \\ ассоциированные, соответственно, с корнями $\omega^q$ порядка $p$ и $\omega^p$ поряд-\\ ка $q$. \\ 
		\indent Обозначим через $\sigma$ и  $\tau$ перестановки интервала $[0, n[$, определен-\\ные, соответственно, через $\sigma(x) = qx_1 + px_2$ и $\tau(x) = vqx_1 + upx_2$, где \\ $x = x_1q + x_2$ ~---евклидово деление на $x$ и $q$.} \\
	\textit{\indent ($i$) При этих условиях вычисление преобразования Фурье порядка $pq$ \\ последовательности $a$ задается любым из следующих двух выражений:}\\
	\begin{center}
		$\hat{a}_\tau = V_p \otimes V_q (a_\sigma)$ или $\hat{a}_\sigma = V_p \otimes V_q (a_\tau)$.
	\end{center} 	
	\textit{\indent ($ii$) Метод Гуда для взаимно простых $p$ и  $q$ схематически может \\ быть представлен в виде:\\}
	 \begin{center}
	 	$\textbf{Good}_{p\times q }(\omega) \equiv p DFT_{q, \omega^p} \oplus q DFT_{p, \omega^q}.$
	 \end{center} 
	\textit{\indent ($iii$) Вычислимая сложность метода Гуда ~--- $n(p+q-2)$ сложений \\ и $n(p+q-4)+p+q$ умножений (сравнительно с  $n(p+q-3)+1$ в алгоритме \\ Кули~---Тьюки), при вычислении внутренних $DFT$ наивным методом.}
	\newpage 
	\lhead{\small\textit{V-6\qquad Вычисление семейства билинейных форм}}
   \rhead{633}
	\bigskip
	\begin{Large}
		\textbf{\noindent 6 Вычисление семейства билинейных форм}
	\end{Large} 
	   
    \medskip
    
	\noindent Теперь изучим некоторые свойства билинейных форм над кольцом, в \\ частности, их выражения в виде произведения линейных формю Этим \\ способом удастся уменьшить колчисетво элементарных умножений \\ в вычислениях $DFT$\\
	\indent Ш.Виноград опубликовал несколько важных работ в этой области:\\ \textit{On the number of multiplications necessary to compute certain function, \\ Some bilinear forms whose multiplicative complesity depends on the field of \\ constans} и \textit{On Multiplication of Polinomials Modulo a Polynomial}. До-\\казательства некоторых результатов Виноградова можно найти у Кну-\\та [99], Нуссбаумера: \textit{Fast Fourier transform and convolution algorithms}\\ или еще у Ауслендера и Толимиери: \textit{Is copmuting with the finite Fouri-\\er transform pure or applied mathematics?} Виногоад дал применения \\ вычислений значений билинейных форм к эффективному вычислению \\ дискретного преобразоввания Фурье: \textit{On Computing the Discrete Fourier \\ Transform, On The Multiplicative Complexity of the Discrete Fourier Trans-\\form.}\\
	\indent Приведем достаточно простой результат, полученный применением \\
	методов Винограда для произведения многочленов. Произведение двух \\
	многочленов степени $1 X(T) = x_1T + x_0$ и $Y(Y) = y_1T+y_0$ задает три \\
	билинейные формы $z_2, z_1$ и $z_0$ от  $х$ и $у$: $X(T)Y(T) = z_2T_2 + z_1T + z_0 =$\\$ x_1y_1T^2 + (x_0y_1+x_1y_0)T + x_0y_0$  Это выражение заставляет думать, что $4$\\ 
	произведения коэффициентов необходимы для того, чтобы вычислить \\
	произведение XY. Однако это не так! Если ввести $3$ билинейные формы \\
	и $w_2(x,y) = x_1y_1$, $w_1(x,y) = (x_1 + x_0)(y_0 + y_1)$ и $w_0(x,y) = x_0y_0$, то можно \\
	выразить произведение $XY$ через $w_2T^2+ (w_1 - w_2 - w_0)T+w_0$, что дока-\\зывает: $3$ умножений вполне достаточно для вычисления произведения \\
	двух многочленов степени $1$ (итерируя этот принцип, можно получить \\ метод Карацубы умножения произвольных многочленов, см.  
	упражне-\\ния из главы I). Это преобразование, увеличивающее число сложений, \\полезно, если в базовом кольце стоимость умножения много выше, чем \\сложения, как, например, для кольца многочленов. Естественный  во-\\прос, который при этом возникает, — каково минимальное число умно-\\жений, требующихся для вычисления произведения двух многочленов? \\
	\indent Важно понимать, что вычисление значений для семейства билиней-\\ных форм не эквивалентно с точки зрения сложности вычислению
	зна-\\чений отдельных форм из этого семейства. В действительности, необ-\\ходимо уметь вычислять значения целого множества билинейных форм, \\что дает возможность определенной оптимизации, аналогично тому, \\что происходит при вычислении значений многочлена: при вычислении  \\
	\newpage 
	\rhead{\small\textit{V-6\qquad Вычисление семейства билинейных форм}}
   \lhead{634}
	\noindent дискретного преобразования Фурье последовательности целых чисел \\
	оптимизация получается за счет вычисления значений многочлена на \\
	множестве хорошо подобранных точек. Вот примеры семейств  
	били-\\нейных форм, часто встречающиеся в математике: 
	\smallskip
	\begin{itemize}
		\item умножение многочлена степени п на многочлен степени $m$  
		индуци-\\рует семейство $n+m+1$ билинейных форм типа $(n+1)\times (m+1)$ (эти 
		билинейные формы определяют коэффициенты произведения), 
		\item произведение $n\times m-$матрицы на $m\times р$-матрицу дает семейство \\
		из пр билинейных форм типа $nm\times mp$ (элемент с индексами ($i,j$) \\
		в произведении матриц есть скалярное произведение $i$-й строки \\
		первой матрицы на $j$-и столбец второй), 
		\item  циклическая свертка на $n$ точках, т.е. умножение по модулю\\
		$T^n - 1$, дает семейство п билинейных форм типа $n\times n$, 
		\item если $Е$ — алгебра размерности $n$ над телом, то ее умножение \\
		дает семейство $n$ билинейных форм типа $n\times n$, которые  
		вы-\\числяют компоненты произведения: если $(e_1,\ldots,e-n)$ — базис $E$\\ 
		и для $x, y \in E$ произведения ху записываются в виде $xy =\\ \sum_{i=1}^n (xy)_ie_i$ то это семейство билинейных форм состоит из форм\\
		типа: {$(xy)_1, (xy)_2,\ldots, (xy)_n)$}. 
	\end{itemize}
\medskip
	\begin{large}
 \begin{flushleft} 
			\noindent\textbf{6.1 Некоторые напоминания, определения \\
			\indent и основные свойства}
		\end{flushleft}
	\end{large} 
	 $E$ и $F$ — свободные модули конечного типа над коммутативным и \\
	унитарным кольцом. 	\\
	
	\noindent \textbf{(35) Напоминания. }\\
	\indent \textit{ ($i$) Билинейная форма $h$ над $E\times F$ имеет тип $n\times m$, когда $dim E = n$\\ 
		и $dim F = m$. }\\
	\indent \textit{($ii$) Если $(e_i,e_2,\ldots,e_n)$ — базис $E$ а $(f_1, f_2, \ldots, f_m)$ — базис $F$ \\  
		то $h$ представляется матрицей $H = (h_{ij})_{
			1\leq i \leq n 
			1 \leq j \leq m
		}$, такой, что $h(x,y) =$ \\ $\sum h_{ij}x_iy_j$. }\\
	\indent \textit{($iii$) Пространство билинейных форм над $E\times F$ снабжено  
		естествен-\\ной структурой свободного модуля размерности $dimi E \times dim F$. }\\
	
	\noindent\textbf{ (36) Определение. }\\
	\indent \textit{Если $a$ и $b$ — две линейные формы над $Е$ и $F$ соответственно, то их \\
		тензорное произведение $a \otimes b$ является билинейной формой над $E \times F$ \\ 
		определенной равенством $a \otimes b (x,y) = a(x)b(y)$. Ее матрица в базах $Е$ \\ 
		и $F$ имеет порождающие элементы $h_{ij} = a_ib_j$, где $(a_i)$ — матрица $a$,} 
	\newpage
	\lhead{\small\textit{V-6.1\qquad Некоторые напоминания, определения и основные свойства}}
   \rhead{635}
	\noindent \textit{a $(b_j)$ — матрица $b$. Такая билинейная форма, являющаяся тензорным\\ 
		произведением двух линейных форм, называется \textbf{элементарной.} \\
		\indent Билинейная форма $h(x,y) = \sum h_{ij}x_iy_j$ является элементарной тогда\\ 
		и только тогда, когда существует п элементов кольца $a_1, а_2,\ldots, a_n$  и $m $ \\
		других элементов $b_1, b_2, \ldots, b_m$ таких, что $h_{ij} = a_ib_j$  для $1 \leq i \leq n$ и \\
		$1 \leq j \leq m$.} \\
	
\medskip
		\noindent \textbf{(37) Предложение. }\\
		
		\indent \textit{($i$) Элементарные билинейные формы порождают пространство  \\
			билинейных форм над $Е \times F$. }\\
		\indent \textit{ ($ii$) Пусть $h$ — билинейная форма. Если $r$ — наименьшее натураль-\\ное число, такое, что $h = a_1\otimes b_1 + a_2\otimes b_2 \ldots a_r\otimes b_r$ является суммой \\
			г элементарных билинейных форм, то $r$ является рангом матрицы $h$ 
			относительно базисов $Е$ и $F$. }
		
		\smallskip
		\indent Доказательство этого предложения содержится в упражнении 25, \\
		находящемся в конце главы. 
		
		\medskip
		\noindent \textbf{(38) Определение.  } \\
		
		
		\indent \textbf{Тензорным рангом семейства $s$ }билинейных форм $h_1, h_2, \ldots, h_s$ \\ над $Е \times F$ называется наименьшее целое число $r$, для которого  
		суще-\\ствуют такие $r$ элементарных билинейных форм $a_2 \otimes b_2, \ldots, a_r \otimes b_r$, что \\
		{$h_1, h_2, \ldots, h_s$} $\subset Vect (a_1 \otimes b_1, a_2 \otimes b_2, \ldots, a_r \otimes b_r)$. Этот ранг\\  
		обозначается $rang_\otimes$, чтобы избежать путаницы с обычным рангом вектора.\\ 
		\indent Разумеется, когда семейство сводится к одному элементу, то  
		тен-\\зорный ранг этого семейства равен рангу матрицы единственной  
		фор-\\мы, из которой состоит семейство (другими словами, для одной  
		били-\\нейной формы понятия матричного ранга и тензорного ранга совпада-\\ют).\\
		\medskip 
		\textbf{(39) Предложение. } \\
		\indent \textit{Пусть $(h_i)_{1\leq i \leq s}$ — семейство билинейных форм тензорного  
			ран-\\га $r$. Пусть $D$ — матрица, явно выражающая зависимость между  
			се-\\мейством $(h_i)$ и семейством элементарных билинейных форм $(a_j \otimes b_j):$ \\
			$(h_i)_{1\leq i \leq s} = D \cdot (a_j \otimes b_j)_{1\leq j \leq r}$. \\
			\indent Тогда, в этих обозначениях, }
		\begin{center}
			$rang_\otimes(h_1, \ldots, h_s) \leq rang D \leq dim(h_1, \ldots, h_s).$ 
		\end{center} 
	\newpage
	\rhead{\small\textit{V-6\qquad Вычисление семейства билинейных форм}}
   \lhead{636}
	\noindent \textbf{Доказательство.}
	
	\smallskip
	
    \MYvrule  Пусть $\lambda_1D_{1, \cdot} + \cdots + \lambda_sD_{s, \cdot} =0$   — соотношение зависимости между \\
	строками матрицы $D.$ Это соотношение равносильно матричному \\
	равенству $(\lambda_1, \lambda_2. \ldots , \lambda_s)D = 0$, откуда $\lambda_1h_1 + \cdots + \lambda_sh_s= 0$.  
	Послед-\\нее равенство выражает тот факт, что векторный ранг семейства \\
	$(h_i)$ не превосходит векторного ранга матрицы $D$ размера $s \times r$,\\ ранг которой не превосходит $r$.
	
	\medskip

	
	\noindent\textbf{Замечание.} На этой стадии изложения не лишне уточнить  
		при-\\роду операций, число которых мы будем минимизировать.  
		Обыч-\\но эти операции называются порождающими или общими  
		умно-\\жениями. Они представляют собой умножения между элементами\\ 
		базового кольца, а не внешние умножения элементов кольца на  
		це-\\лые числа. Это число умножений дается здесь через тензорный\\ 
		ранг: порождающие произведения в действительности  
		получают-\\ся через вычисления значений билинейных форм. Сопутствующая \\
		этому рассуждению идея, которая может показаться излишне  
		спе-\\циальной, заключается в том, что для вычислений произведений \\
		многочленов или матриц, или даже преобразования Фурье, можно \\
		выделить часть вычислений, которые называются предвычисле- \\
		ниями, куда можно запрятать сложность вычисления констант. \\
		\indent Подтвердим эти идеи примером. Рассматривая произведение \\
		многочлена второй степени на многочлен первой степени,  
		пред-\\положим, что первый из них раз и навсегда зафиксирован, тогда \\
		как второй может меняться. Как лучше всего организовать  
		вы-\\числения? Бели выбрать наивный подход, исходя из вида первого\\
		многочлена, то потребуется 6 умножений и 2 сложения  
		коэффи-\\циентов. Применяя же технику, развитую в доказательстве  
		тео-\\ремы 40, можно также доказать, что, если
		\begin{center}
			
		$W_0 = a_0b_0$,  \qquad $W_1 = \frac{a_2+a_1+a_0}{2}(b_1+b_0)$\\
		\medskip
		$W_1 = \frac{a_2-a_1+a_0}{2}(b_0 -b_1)$ \qquad  $W_3=a_2b_1$,
	\end{center}
		то произведение двух многочленов $а_2Х^2+а_1Х + a_0$ и $b_X + b_0$ равно \\
		$W_3X^3 + (W_1+W_2-W_0)X^2 + (W_1-W_2-W_3)X + W_0$. Если  
		предполо-\\жить, что первый многочлен фиксирован, то можно использовать\\ 
		предвычисления выражений, содержащих си, и включить в пред-\\ 
		вычисления деления на 2. Такой способ вычисления произведения \\
		многочленов потребует 4 умножения (и 6 сложений, от которых \\
		никуда не денешься).  
		
\end{document}

 
