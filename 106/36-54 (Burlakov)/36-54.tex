\documentclass{mai_book}

\defaultfontfeatures{Mapping=tex-text}
\setdefaultlanguage{russian}
\setcounter{page}{36}
\begin{document}

\begin{table}
\centering
\begin{tabular}{|*{2}{l|}}
\hline
\underline{А. Алгоритмы с полным доказательставом} & \underline{В. Окончаиельный вариант}\\[2mm]
c $\longleftarrow$ 1; x$\longleftarrow$ $x_0$; n $\longleftarrow$ $n_0$ & x$\longleftarrow$ $x_0$; n$\longleftarrow$ $n_0$; \\
c$\times x^n$ = ${x_0}^{n_0}$ & if {\it n} mod 2 $\neq$ then\\
while n$\neq$ 0 loop & $c \longleftarrow x$;\\
c$\times x^n ={x_0}^{n_0}$ $\text{ и}$ n >0 & else \\
if n mod 2 $\neq$ 0 then  & c$ \longleftarrow$ 1;\\
 $c \longleftarrow c \times x;$ & end if;\\
end if; & loop\\
$ c(x^2)^{[n/2]} = {x_0}^{n_0}$ & $n \longleftarrow [n/2]; c \times {(x^2)}^n = {x_0}^{n_0}$\\
n $\longleftarrow [n/2]$; & exit when n = 0;\\
$ c \times {(x^2)}^n =(x^2)^{[n/2]}$ & $x \longleftarrow x \times x;$\\
$x \longleftarrow x \times x;$ & if n mod 2 $\neq$ 0 then \\
c$\times x^n$ = ${x_0}^{n_0}$ & $c \longleftarrow c \times x;$\\
end loop; & end if;\\
c$\times x^n ={x_0}^{n_0}$ $\text{ и}$ n =0 & end loop;\\
return c; & return c;\\
\hline
\end{tabular}
\end{table}
$\hfill$ {\bf Алгоритм 2.} Дихотомическое возведение в степень $\hfill$
\newline

Мы видим (алгоритм 2-В)окончательную версию дихотомического алгоритма возведения в степень. Версия эта очень близка к разработке в языке Ада. Во избежание усложнения алгоритма (и это правило будет применено к большинству представляемых алгоритмов) единственное утверждение, фигурирующее еще в тексте алгоритма,- это ивариант цикла позволяющий правильно понять испольуемый метод.
\newline

\section{2.3 Изучение сложности алгоритма}
Чтобы завершить изучение алгоритма, остается оценить его слож­
ность, т.е. сосчитать с достаточной точностью число элементарных
операций, необходимых для его выполнения при фиксированных дан­
ных. Ясно, что число итераций, необходимых для выполнения алгорит­
ма, зависит только от показателя. Упростим обозначения, предполо­
жив, что n (вместо $n_0$) — показатель, и предположим, в соответствии с
обозначениями, введенными при исследовании рекуррентного алгорит­
ма, что число цифр в двоичной записи n равно t + 1. Это равносильно
тому, что

\begin{equation*}
  2^t \le n < 2^{t+1} \  {\text {или} }  \  t \le \log_2 n < t+1 
\end{equation*}
Первая часть этого свойства может быть выражена следующим обра­
зом: [$n/2^(t+1)$] =0 и [$n/2^t$] $\not=$ 0 что позволяет точно определить число

\newpage
совершаемых делений n, равное числу итераций алгоритма при задан­
ном значении n. Очевидно, нужно совершить t + 1 итераций, чтобы
выполнить алгоритм, т.е. [$log_2 n$] + 1 итераций. Следовательно, тру­
доемкость алгоритма есть $O(log n)$. Порядок величины — достаточная
оценка, начиная с момента, когда константа, замаскированная обозна­
чением О, находится в разумных пределах, как в данном примере. Мож­
но было бы уточнить число операций, но это не представляет большого
интереса.
\newline

\begin{center}
\parbox{12cm}{
Замечание . Как было уже сказано в начале раздела, дихотоми­
ческий алгоритм возведения в степень не всегда является опти­
мальным методом для вычисления n-й степени элемента моноида,
даже если базовая операция выполняется за постоянное время.
Например, чтобы сосчитать $х^15$ , используя дихотомическое воз­
ведение в степень, требуется 6 умножений: сосчитать $х^2$ , $х^4$ , $х^8$
и умножить вместе х и эти три величины. Однако, если начать с
вычисления $х^5$ (посредством х , $х^2$ и $х^4$ ), возводя последнюю вели­
чину в куб, сосчитаем $х^15$ за 5 умножений. Метод, использован­
ный в вычислении, известен как «цепочка сложений» и идея его
следующая: цепочка сложений для n — это последовательность
целых чисел $a_0$ = 1, $a_1$ , $а_2$, . . . , $а_r$ = n, которая удовлетворяет сле­дующему свойству:}
\end{center}
\[
\forall i\in [1,r], \exists j,k \text{ такие,что } 1\leqslant k \leqslant j<i {\text{ и  }} a_i    =a_j + a_k .
\]
\begin{center}
\parbox{12cm}{
Цель изучения цепочек сложения в том, чтобы найти при лю­
бом n как можно более короткую цепь сложений. Затем можно
применить полученный результат для открытия самого эффек­
тивного метода, позволяющего вычислить $x^n$ с помощью умно­
жений. Не вдаваясь в детали метода, проиллюстрируем основ­
ной принцип использования цепочек сложения. Предположим, что
требуется вычислить $x^{54}$ . Чтобы произвести расчет дихотомиче­
ским методом, нужно сосчитать следующие степени x : x , $x^{2}$ , $x^{4}$ ,
$x^{8}$, $x^{16}$ и $x^{32}$ . Потом выполнить необходимые умножения этих
чисел друг на друга. Если выполнить сразу только одно умно­
жение и расположить полученные члены в порядке возрастания
степеней, то получим последовательность x , $x^{2} $ , $x^{4}$ , $x^{6}$ , $x^{8}$ , $x^{16}$, $x^{22}$ , $x^{32}$ и $x^{54}$ . Эта последовательность, совершенно очевидно, со­ответствует цепи сложений (1 ,2 ,4 ,6 ,8 ,1 6 ,2 2 ,3 2 ,5 4 ), которая не
минимальна, потому что 54 можно получить при помощи це­пи (1 ,2 ,3 ,6 ,9 ,1 8 ,2 7 ,5 4 ), являющейся минимальной. Это означа­ет, что вычисление 54-й степени х произойдет очень быстро привыполнении расчетов:}
\end{center}
\[
x_0=x,  x_1=x_0*x_0=x^2 ,
\]
\newpage

\begin{tabular}{c}

$\hfill$ $x_2 = x_0 \cdot  x_1 = x^3$, $x_3 = x_2 \cdot =x^6$, $x_4=x_2 \cdot =x^9$, $\hfill$\\
  $ \qquad x_5 = x_4 \cdot x_4 = x^{18}$,  $x_6 = x_4 \cdot x_5 = x^{27}$,  $x_7 = x_6 \cdot x_6 = x^{54}$.  \\
\end{tabular}

\begin{center}
\parbox{12cm}{
Заинтересованный читатель может обратиться к работе [99]: $\ll$Ис­
кусство программирования $\gg$, откуда были взяты описанные при­
меры.}
\end{center}
$\newline$
$\newline$

\section{ 3 Введение в программирование \\ на языке Ада}
$\newline$
\noindent Пришло время представить первые программы на языке Ада. Основной
прием, используемый для этого, заключается в представлении исходно­
го текста\footnote{В этом контексте исходный текст обозначает файл, который содержит текст
программы на исходном языке (здесь Ада) и который после компиляции порожда­
ет файл, записанный на целевом языке (обычно, машинный язык). Для краткости
часто просто говорят о программе или исходном модуле в отличие от объектной
программы или объектного модуля.} на языке Ада, результатов выполнения — чаще всего для
определения времени их получения — и комментария к Ада-программе
для объяснения новых введенных понятий или специальной техники
программирования.
$\newline$
\section{3.1 Программа сравнения двух методов возведения в степень} 

\noindent Эта первая программа — непосредственное воплощение алгоритма,
изученного ранее; она позволяет сравнить время вычисления дихотоми­
ческого алгоритма возведения в степень и алгоритма возведения в сте­
пень посредством последовательных умножений. Разумеется, резуль­
тат не будет неожиданным: первый алгоритм требует ${\it O}$(logn) умно­
жений, а второй ${\it O}$(n); однако, полученные величины могут удивить
того, кто не имеет опыта в этом типе вычислений и кто только с пози­
ций теории знает о различии в росте между линейной и логарифмиче­
ской функциями. Для измерения времени мы используем стандартную
библиотеку {\it Calendar}, хронометр которой имеет разрешающую способ­
ность около 50 мкс (для нашего компилятора).

\newpage
\begin{table}
\centering
\begin{tabular}{|*{6}{c|}}
\hline 
\multicolumn{3}{l}{Входные данные} & \multicolumn{2}{l}{Время вычисления (сек.)} & Результат\\
p & x & n & Послед.умн. & Дих.возв. в ст. & $x^n$ mod {\it p}\\ 
\hline
181 & 11 & 1 024 & 0.050& 0.000& 126\\
 & 17& 4 096& 0.221 & 0.000& 39\\
 & 23 & 16 384 & 0.710 & 0.000& 15\\
 & 29 & 65 536 & 2.859 & 0.000& 29\\
 & 31 & 262 144 & 11.370 & 0.000& 59\\
 & 37 & 1 048 576 & 45.529 & 0.000 & 34\\
 & 41 & 4 194 304 & 182.130 & 0.000 & 15\\
 & 43 & 16 777 216 & 728.090 & 0.000 & 43\\
 & 47 & 67 108 864 & 2912.370 & 0.000 & 102\\
\hline
\end{tabular}
\caption{ Вычисление $x^n mod p$}
\end{table}

Несколько комментариев по таблице 1:
\begin{itemize}
\item прежде всего, и это не зависит от сделанных измерений, расчеты
производились по модулю целого числа {\it p} , чтобы можно было оце­
нить большие степени, не сталкиваясь с проблемами переполнения
машины целыми числами;
\item когда используют таблицу этого типа, в которой представлены
измерения времени вычисления, не нужно никогда забывать, с ка­
кой точностью были сделаны эти измерения (разрешающая спо­
собность таймера); в этом примере, в частности, время выполне­
ния порядка 50 мкс не было значимым;
\item в самом деле, заключаем, что сложность возведения в степень ме­
тодом последовательных умножений является линейной по отно­
шению к показателю: в каждой строке таблицы, показатель, так
же, как и время вычисления, умножается на 4; предпоследнему
измерению соответствует время вычисления около 12 минут, при
вполне разумном суммарном значении показателя, а последнее из­
мерение, при показателе порядка 70 миллионов, дает нам время
абсолютно неразумное (около 50 минут); это доказывает, что ал­
горитм, работающий с помощью метода последовательных умно­
жений не может быть использован в контексте более широком,
чем сравнение алгоритмов;
\item  зато невозможно выявить малейшее изменение времени вычисле­
ния для дихотомического алгоритма возведения в степень, при
таких {\it малых} значениях {\it n};
\item число, по модулю которого производятся вычисления, является
наибольшим простым числом р таким, что (р—1)$^2$ $\leqslant$ $2^{15}$ — 1; это
означает, что умножения по модулю р могут быть сделаны на ма­
шине, оперирующей целыми 16-битовыми числами (со знаками),
\end{itemize}
\newpage
\begin{center}
\parbox{12cm}{
без риска переполнения (читатель, желающий больше узнать об
арифметике компьютеров, может обратиться к Таненбауму [168],
Мюллеру [132] или Менадье [126]);}
\end{center}
\begin{itemize}
\item результат вычисления, $x^n$ mod {\it р}, хотя и приведен в этой таблице,
абсолютно не представляет никакого интереса; но программа без
результатов еще способна шокировать чувствительные сердца.
\end{itemize}

 Этот первый пример не может служить образцом программирова­
ния на языке Ада, в том смысле, что опытный программист не записал
бы его в такой форме. В частности, типизация данных чрезвычайно
слаба: моноид, на котором действует возведение в степень, — это мно­
жество целых чисел по модулю {\it р} с обычным умножением, представлен­
ное в программе типом {\it Integer}, показатель — предопределенного ти­
па {\it Long\_ Integer}, чтобы иметь возможность использовать относительно
большие показатели. Эти два типа еще не очень различаются, но ведь
речь пока идет только о написании первой Ада-программы; этот тип
программирования больше приближен к программированию на языке
Паскаль, с которым читатель может быть более знаком. «Хороший» ва­
риант Ада-программы будет представлен в конце этого раздела после
введения основных понятий языка Ада.
\begin{center}
\parbox{8cm}{
{\it {\small Программа оценки дихотомического возведения в степень}}}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
    with ${\it Text\_ IO, Calender;}$
    procedure ${\it Exponentiation\_ First\_ Version}$ is
    ${\it p :}$ constant ${\it Integer := 181}$
    subtype ${Modular\_ Integer}$ is ${\it Integer}$ ranger ${\it 0 ..p-1}$ 
    ${\it x , Dichotomic\_ Result, Sequential\_ Result : Modular\_ Integer;}$
    ${\it n : Long\_ Integer ;}$
    ${Begin\_ Time : Calendar.Time;}$
    ${Computation\_ Time : Duration;}$
    $\newline$
    package ${Long\_ Integer\_ IO}$ is new ${Text\_ IO.Integer\_ IO (Long\_ Integer);}$
    package ${Modular\_ Integer\_ IO}$ is new ${Text\_ IO.Integer\_ IO (Modular\_ Integer);}$
    package ${ Duration\_ IO}$ is new ${Text\_ IO.Fixed\_ IO (Duration);}$
    use ${\ Calendar, Text\_ IO, Duration\_ IO, Modular\_ Integer\_ IO, Long\_ Integer\_ IO;}$
    $\newline$
    function ${Dichotomic\_ Exponentiation (x0 : Modular\_ Integer; n0 : Long\_ Integer)}$
   $\qquad$ $\qquad$ return ${\it Modular\_ Intger}$ is
   ${\it x : Modular\_ Integer := x0;}$
   ${\it n : Long\_ Integer := n0;}$
   ${\it Correction : Modular\_ Intrger;}$
   begin
   if ${\it n}$ mod ${\it 2 /=0}$ then ${Correction :=x}$ mod ${\it p;}$ else ${\it Correction := 1;}$ end if;
   loop
   ${\it n:= n/2;}$
 
   \end{lstlisting} 

\newpage
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
  exit when n = 0;
  $x := (x \ast x)$ mod p;
  if n mod ${\it 2 /= 0}$ when ${\it Correction := (Correction \ast x)}$ mod p;
  end loop;
  return ${\it Correction;}$
  end ${\it Dichotomic\_ Exponentiation;}$
  $\newline$
  function ${\it Sequntial\_ Exponentiation (x0 : Modular\_ Integer; n0 : Long\_ Intege)}$
  $\qquad$ $\qquad$ return ${\it Modular\_ Integer}$ is
  ${\it x\_ To\_ i : Modular\_ Integer := 1;}$
  begin
  for i in 1 .. n0 loop ${\it x\_ To\_ i := (x\_ To\_ i \ast x0)}$ mod p; end loop;
  return ${\it x\_ To\_ i;}$
  end ${\it Sequential\_ Exponentiation;}$
  $\newline$
  begin - - ${\bf Exponentiation\_ First\_ Version}$
  ${\it Put\_ Line }$ ${\bf ("Оценка\_ дихотомического\_ возведения\_ в\_ степень.\_");}$
  $\newline$
  loop
  ${\it Get(x);}$
  exit when ${\it x = 0}$
  ${\it Get (n); Put (x); Put(n);}$
  $\newline$
  
  ${\it {\bf Begin\_ Time} := Clock; Sequential\_ Result := Sequential\_ Exponentiation (x, n);}$
  ${\it Computation\_ Time := Clock - Begin\_ Time; Put (Computation\_ Time);}$

  $\newline$
  ${\it {\bf Begin\_ Time} := Clock; Dichotomic\_ Result := Dichotomic\_ Exponentiation (x, n);}$
  ${\it Computation\_ Time := Clock - Begin\_ Time; Put (Computation\_ Time);}$
  $\newline$
  
  if ${\it Dichotomic\_ Result = Sequential\_ Result}$ then ${\it Put  (Dichotomic\_ Result);}$
  else raise ${\it Numeric\_ Eror;}$
  end if;
  ${\it New\_ line;}$
  end loop;
  end ${\it Exponentiation\_ First\_ Version}$
  \end{lstlisting} 

Комментарий к этой программе заключается, в основном, в описа­
нии структуры Ада-программы. В общих чертах, программа в языке
Ада — это процедура (без параметров, в случае используемого нами
компилятора), построенная на основе элементарных или сложных дей­
ствий и объектов, которые можно определить во внешних {\bf блоках ком­
пиляции} — блоки могут быть процедурами, функциями или {\bf пакета­
ми} (название, данное тому, что в других языках называется модулями
или библиотеками).

\newpage
Предыдущая Ада-программа образует блок компиляции, в данном
случае являющийся главной программой; она состоит, в основном, из
двух частей:
\begin{itemize}
\item определение контекста компиляции (оператор {\bf with} ); этот опе­
ратор позволяет компилятору распознать используемые внешние
объекты, определенные в другом блоке компиляции, и убедиться
в связности между их спецификацией и использованием;
\item текст подпрограммы, соответствующий блоку компиляции.
\end{itemize}

Оператор контекста  $\blacktriangleright$ {\bf with} {\it Text\_ IO , Calendar} $\blacktriangleleft$ касается двух стан­
дартных пакетов: первый из этих модулей {\it Text\_ IO} содержит все обыч­
ные процедуры ввода-вывода текстовых файлов (включая, конечно,
клавиатуру и экран); под этим понимается считывание и написание
знаков, последовательностей знаков, чисел различных типов и т.д. Па­
кет {\it Calendar} содержит определения типов, операторов и подпрограмм,
которые позволяют произвести измерение времени.
Затем идет определение процедуры, которая играет роль главной
программы; с точки зрения структуры, эта процедура полностью ана­
логична процедуре на языке Паскаль. Она включает, в определенном
порядке, последовательность описаний констант, типов и переменных,
несколько конкретизаций настраиваемых пакетов, определения функ­
ций и, наконец, само тело процедуры.
Рассмотрим, прежде всего, описательную часть данной процедуры.
После определения константы {\it p} находим определение {\bf подтипа} , в ко­
тором будут сделаны расчеты:  {\bf subtype} {\it Modular\_ Integer} {\bf is} {\it Integer} {\bf range} O..p — 1;$\blacktriangleleft$. 
Это определение позволяет ограничить множество
допустимых значений, а среди целых значений рассматривать только
те, которые заключены между 0 и р — 1. Это приводит, в частности, к
тому, что во время выполнения программы операционная среда языка
Ада будет контролировать значения переменных типа {\it Modular\_ Integer}
и вызовет внезапную остановку программы, если эти значения выйдут
за рамки намеченного интервала. После данного определения типа мы
видим описания трех переменных этого подтипа, используемых в ходе
вычислений, потом переменную, представляющую показатель. Данная
переменная относится к (предопределенному) типу {\it Long\_ Integer}, несо­
вместимому с типом {\it Integer}.

\begin{center}
\parbox{12cm} {
{\bf Замечания.} Ада имеет несколько предопределенных типов, ко­
торые мы не будем здесь подробно рассматривать; их список
можно найти в приложении {\it F} в справочнике, сопровождающем
любой компилятор, достойный этого названия. Однако, мы ска­
жем несколько слов о целых типах. Компилятор языка Ада дол-}
\end{center}
\newpage
\begin{center}
\parbox{12cm}{
жен предоставить, как минимум, один предопределенный целый
тип, называемый {\it Integer}, кроме того, он может давать другие це­
лые типы с названиями {\it Short-Integer, Long-Integer, Short-Short-In­
teger}, . . . характеризуемые тем, что, например, тип {\it Short-Integer}
не может быть больше типа {\it Integer}, который в свою очередь не
может быть больше типа {Long\_ Integer} . . . как скучно все это объ­
яснять!
Это наложение на целые типы позволяет высказать дополни­
тельные критические замечания по поводу предыдущей програм­
мы. Действительно, идентификатор {\it Long\_ Integer} появляется там
отчетливо несколько раз, и это означает, что нужно будет сде­
лать много модификаций при переносе этой программы на ма­
шину, компилятор которой не содержит типа {\it Long\_ Integer}. Этот
недостаток исправлен в последующих Ада-программах. Данная
первая версия представляет только первый опыт программиста,
привыкшего писать на Паскале.}
\end{center}
Переменная {\it Begin\_ Time} принадлежит типу {\it Time}, определенному в
пакете {\it Calendar} и обозначающему набор время-дата. Без дополнитель­
ного уточнения после спецификатора контекста этот тип не является
непосредственно видимым, и нужно задать компилятору Ада путь, по­
зволяющий обнаружить определение в описанных модулях, что и де­
лается с помощью выражения {\it Calendar. Time}, обозначающего, что тип
{\it Time} определен в пакете {\it Calendar}. Во избежание тяжеловесности запи­
си, вызванной этим феноменом, нужно, чтобы объекты пакета Calen­
dar стали видимыми, начиная с подпрограммы, что и делается в строке
программы, содержащей спецификатор $\blacktriangleright$ {\bf use Calendar }$\blacktriangleleft$ : с этого опе­
ратора все происходит так, с точки зрения видимости, как если бы
описания пакета {\it Calendar} фигурировали в тексте подпрограммы.
Последняя переменная программы, {\it Computation\_ Time}, типа {\it Dura­
tion}, используется для выражения результатов измерений времени, вы­
полненных в программе. Тип {\it Duration} — это предопределенный тип,
позволяющий найти продолжительность, выраженную в секундах: это
реальный тип с фиксированной точкой, т.е. с точностью абсолютной,
а не относительной, как в случае реальных типов с плавающей точкой.
Язык Ада типизирован до такой степени, что, к примеру, процеду­
ры ввода-вывода отличаются для объектов различных типов; это при­
дает языку большую однородность. Однако, было бы не очень удобно
определять такие процедуры для каждого численного типа, который
хотят использовать, — на самом деле способ вывода чисел целого ти­
па всегда одинаковый, независимо от того, о каком целом идет речь:
обыкновенном, длинном или о любом другом целом типе, определенном

\newpage

пользователем. Рассуждение совершенно аналогично для определенных
пользователем действительных, символьных и других типов. По этим
причинам и по многим другим, которые возникнут позднее, язык Ада
обладает понятием настраиваемого объекта, позволяющим более легко
воплотить абстрактные типы.
Таким образом, стандартный пакет {\it Text\_ IO} содержит определен­
ное число настраиваемых подпакетов, позволяющих без труда создать
для каждого особого типа процедуры ввода-вывода, соблюдая типовые
ограничения, необходимые для связности и точности языка: для целых
типов, например, настраиваемый пакет ввода-вывода — {\it Text\_ IO.Inte­
ger\_ IO} В определении настраиваемого модуля некоторые параметры
функционирования модуля не уточняются, но прежде, чем использо­
вать такой модуль, нужно явно указать эти параметры. Таким обра­
зом, параметры настраиваемого пакета {\it Integer\_ IO} определяются целым
типом, для которого предполагается реализовать ввод-вывод; во время
своей {\bf конкретизации} — фазы, позволяющей вызвать генерацию, —
исходя из общей совокупности объектов, предназначенных для исполь­
зования, нужно уточнить целый тип, который придется обрабатывать.
В примере этой программы имеются два целых типа, для которых не­
обходимо зарегистрировать методы ввода-вывода; итак, находим две
конкретизации пакета {\it Integer\_ IO}. Два новых пакета определены; в даль­
нейшем можно будет на них ссылаться.
\begin{center}
\parbox{14cm}{
{\bf package} {\it Long\_ Integer\_ IO} {\bf is new} {\it Text\_ IO.Integer\_ IO (Long\_ Integer);}\\
{\bf package} {\it Modular\_ Integer\_ IO} {\bf is new} {\it Text\_ IO.Integer\_ IO (Modular\_ Integer);}}
\end{center}
Затем в исходном тексте находим конкретизацию для типа {\it Dura­
tion} настраиваемого пакета {\it Fixed\_ IO}, позволяющего производить ввод-
вывод действительных типов с фиксированной точкой. Потом, для об­
легчения записи последовательности программы, четыре пакета ввода-
вывода перечисляются в описанном выше операторе {\bf use} (что делает
видимым все объекты внутри пакетов, и при отсутствии конфликтов
позволяет использовать эти объекты без упоминания их источника).
После всех этих описаний находим в тексте две функции возведения
в степень, которые служат для сравнения двух разработанных методов.
Эта часть Ада-программы не требует много комментариев потому, что
она точно отражает алгоритм, изученный в разделе 2.2 (страница 36);
единственная неизвестная команда — это {\bf return} , которая вызывает
остановку функции и определение ее значения.
Важно отметить, что все параметры функции в языке Ада являются
{\bf входящими}, или в режиме {\bf in}. Таким образом значения фактических
параметров вызова функции передаются соответствующим формаль-
\newpage


ным параметрам во время активации этой функции (с помощью ме­
тода, который нет необходимости здесь описывать). Синтаксис языка
Ада не позволяет подпрограмме изменять свои формальные параметры
режима {\it in}, рассматриваемые как константы в теле подпрограммы. Это
приводит, в частности, к тому, что вызов функции не может привести
к изменению параметров вызова (это противоречило бы логике и духу
программирования).
И, наконец, программу завершает тело главной процедуры, требу­
ющее лишь небольших комментариев:

\begin{itemize}
\item функция {\it Clock} определена в пакете {\it Calendar} и возвращает дату и
время;
\item функции {\it Put} и {\it Get} позволяют, соответственно, считывание и за­
пись; однако на этом этапе напрашивается замечание: хотя про­
цедуры считывания различны для целых и вещественных, а также
различны для разных целых типов, обычно названия у них одина­
ковые. Это так называемая перегрузка идентификаторов, кото­
рая может использоваться только с идентификаторами функций,
операторов или процедур. В зависимости от контекста, в частно­
сти, от типа параметров, компилятор устраняет двусмысленно­
сти;
\item работу программы достаточно легко понять: по очереди считы­
ваются два целых: одно {\it x} типа {\it Modular\_Integer}, второе {\it n} типа
{\it Long\_ Integer} и вычисляется {\it $x^n$} сначала с помощью простого мето­
да, потом с помощью дихотомического. Во время каждой опера­
ции время выполнения измеряется и выводится на экран. Наконец,
после оценки результата двумя методами, так как речь идет об
экспериментировании, два результата вычисления сравниваются
(никто не застрахован от ошибки программирования!), и в слу­
чае (очень маловероятном), когда будет расхождение, програм­
ма возбуждает предопределенное исключение {\it Numeric\_ Error}, что
приводит к ее немедленному завершению, как если бы дело ка­
салось ошибки выполнения. Этот механизм исключения является
методом, избранным разработчиками языка Ада для обработки
ошибок и их устранения. Нам еще представится случай к нему
вернуться. Программа останавливается, когда для переменной {\it x}
берется значение, равное нулю.
\end{itemize}
\newpage

\section{ 3.2 Об использовании типов}

\noindent После этой первой версии, представим теперь другую программу, где
дихотомический алгоритм возведения в степень еще фигурирует, но в
виде, который больше приближается к тому, что мы считаем програм­
мированием на языке Ада. В частности, обрабатываемые объекты там
намного более типизированы, чем в первоначальной версии, что позво­
лит впоследствии без больших усилий построить настраиваемую вер­
сию дихотомического возведения в степень. Но прежде всего пример
выполнения (таблица 2) позволяет констатировать, что при значениях
показателя, близких к допустимому максимуму, время вычисления на
большинстве машин не всегда будет значимым.
\begin{table}
\centering
\begin{tabular}{|*{5}{c|}}
\hline 
\multicolumn{3}{l}{Входные данные} & {Время вычисления (сек.)} & Результат\\
p & x & n &  Дих.возв. в ст. & $x^n$ mod {\it p}\\ 
\hline
46 337  & 31 & 262 144 & 0.000 & 3951\\
 & 37 & 1 048 576&  0.000 & 43153\\
 & 41 & 4 194 304  & 0.000 & 1430\\
 & 43 & 16 777 216 &  0.000 & 29703\\
 & 47 & 67 108 864  & 0.000 & 26840\\
 & 53 & 268 435 456  & 0.000 & 43887\\
 & 59 & 1 073 741 824 & 0.000 & 13314\\
 & 61 & 2 147 483 647 & 0.000 & 5770\\
\hline
\end{tabular}
\caption{ Вычисление ${x^n}\mod{p}$}
\end{table}

Комментарии будут краткими:
\begin{itemize}
\item число 46337 — наибольшее простое число р такое, что (р—1)$^2$ $\leqslant$
$2^{31}$ — 1, следовательно, можно выполнять умножения по модулю р
без риска переполнения на машине, обладающей целыми 32-бито­
выми числами со знаками\footnote{В языке Ада числа могут задаваться программе с использованием символа под­
черкивание ($\_$) для того, чтобы сделать их более понятными; и возможно даже,
что они будут выражены не в десятичной системе счисления! Так, число 46337
может быть задано в тексте программы или при считывании в виде 46-337, или
$7\# 252J044\#$, когда его хотят выразить в системе с основанием 7.},
\item как в предыдущей таблице, целые {\it x} являются простыми числами,
а целые {\it n}, все (кроме последнего) — степени двойки (более точно,
{\it n} имеет форму $2^{4k}$ ),
\item целое 2 147 483 647 — это наибольшее положительное целое, ко­
торое может быть представлено в машине, оперирующей 32-би-
товыми словами и использующей целую, знаковую арифметику в
дополнительном коде (оно равно $2^{31}$ — 1).
\end{itemize}


\newpage
Основное отличие двух первых версий программы (это мы отметили
в предыдущем параграфе) состоит в различии (на уровне используемых
типов) между элементами моноида, в котором они работают, и пока­
зателями, которые всегда целые; что, впрочем, не нарушает общности
изложения. Итак, рассмотрим исходный текст этой программы:

 $\hfill$ Дихотомическое возведение в степень $\hfill$

 \begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
    with ${\it Text\_ IO;}$ use ${\it Text\_ IO;}$ with ${\it Calender;}$ use ${\it Calender;}$
    procedure ${\it Exponentiation\_ Second\_ Version}$ is
    $\newline$
    ${\it p :}$ constant ${\it Integer := 46\_ 337;}$
    type ${Modular\_ Integer}$ is  ranger ${\it 0 ..p-1}$ 
    type ${\it Exponent}$ is new ${\it Long\_ Integer}$
    $\newline$
    ${\it n : Exponet}$
    ${\it x , Result: Modular\_ Integer ;}$
    ${Begin\_ Time : Calendar.Time;}$
    ${Computation\_ Time : Duration;}$
    $\newline$
    package ${Exponent\_ IO}$ is new ${Integer\_ IO (Exponent);}$
    package ${Modular\_ Integer\_ IO}$ is new ${Integer\_ IO (Modular\_ Integer);}$
    package ${Duration\_ IO}$ is new ${Fixed\_ IO (Duration);}$
    use ${\it Exponent\_ IO,  Modular\_ Integer\_ IO, Duration\_ IO;}$
    $\newline$
    function ${\it Multiply (a, b : Modular\_ Integer)}$ return ${\it Modular\_ Integer}$ is
   $\qquad$ $\qquad$ ${\bf - -переопределение умножения для типа Modular\_ Integer}$
   begin
   $\quad$ return ${\it Modular\_ Integer ({(a \ast b)}\mod{p});}$
   end ${\it Multiply;}$
   $\newline$
   function ${\it Dichotomic\_ Exponentiation (x0 : Modular\_ Integer; n0 : Exponent)}$ 
  $\qquad$ $\qquad$ return ${\it Modular\_ Integer}$ is
  ${\it x : Modular\_ Integer := x0;}$
  ${\it n : Exponent := n0;}$
  ${\it Correction : Modular\_ Integer;}$
  $\newline$
  begin
  if n mod ${\it 2 /= 0}$ then ${\it Correction := x;}$ else ${\it Correction := 1;}$ end if;
  $\newline$
  loop
  ${\it n := n / 2;}$
  exit when n = 0;
  ${\it x := Multiply (x, x);}$
  if n mod ${\it 2 /= 0}$ then ${\it Correction := Multiply (Correction, x);}$ end if;
  end loop;
  return ${\it Correction;}$
  end ${\it Dichotomic\_ Exponrntiation;}$
   \end{lstlisting}
\newpage
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
begin ${\bf - -Exponentiation\_ Second\_ Version}$
${\it Put\_ Line}$ ${\bf("Дихотомический\_ возведение\_ в\_ степень\_,\_ вторая\_ версия");}$
loop
${\it Get (x);}$
exit when ${\it x = 0}$
${\it Get (n);}$
${\it Begin\_ Time := Clock;}$
${\it Result := Dichotomic\_ Exponentiation (x, n);}$
${\it Computation\_ Time := Clock - Begin\_ Time;}$
$\newline$
${\it Put (x); Put (n); Put (computation\_ Time); Put (Result); New\_ Line;}$
end loop;
end ${\it Exponentiation\_ Second\_ Version;}$
\end{lstlisting}
В начале этого текста стоит, как обычно в любой программе, специ­
фикатор контекста, который указывает на два пакета, а за ним сразу
же следует соответствующий спецификатор использования {\bf use}. Специ­
фикатор {\bf use} может появиться в контекстной части блока компиляции
или в любом месте описательной части: место, где появляется специ­
фикатор {\bf use}, определяет области видимости объектов, содержащихся
в пакетах, на которые он указывает.
В описательной части снова видим описание константы {\it p}, но в дан­
ной версии она недостаточно типизирована: это, так называемая, уни­
версальная константа, что означает ее совместимость со всеми целы­
ми типами. Нормой языка Ада является то, что вычисления, выпол­
няемые на универсальных константах, должны быть точными, и для
удовлетворения этой нормы любой компилятор способен производить
расчеты на любых больших универсальных константах; в дальнейшем
мы увидим это использование. Константа р используется затем, чтобы
определить {\it целый тип}; этот тип определяется абсолютным способом,
как интервал натуральных чисел (в терминологии языка Ада целые
математические числа называются целыми универсальными). Преиму­
щество этого метода в том, что он делает определения используемых
типов независимыми от предопределенных типов, существующих в кон­
кретной используемой реализации. При компиляции программы могут
происходить два события, относящиеся к этому определению типа:
\begin{itemize}
\item тип не может быть представлен в реализации: в этом случае ком­
пилятор делает предупреждение и отказывается компилировать,
\item тип может быть представлен, и язык Ада гарантирует, что ре­
зультаты вычисления будут идентичными, каковы бы ни были
\newpage

используемая машина или реализация языка, при условии, что не
будет переполнения.
\end{itemize}
После этого определения находим второе определение типа: $\blacktriangleright$ {\bf type} {\it Ex­ponent } {\bf is new} {\it Long\_ Integer} $\blacktriangleleft$- Это определение производного типа, что
означает: тип Exponent идентичен по всем пунктам типу {\it Long\_ Integer},
но эти два типа несовместимы; тип {\it Long \_ Integer} — это родительский
тип типа {\it Exponent}. Во время записи программы, при условии преобра­
зования явных типов, будет совершенно невозможно соединить пере­
менные этих двух типов в одно выражение; эта несовместимость обес­
печивает большую надежность программирования, не допуская смеше­
ния (часто легкого) идентично представленных объектов (по причинам,
связанным с реализацией данной программы), значения которых пол­
ностью отличаются друг от друга (не складывают, например, числа,
представляющие вольты, с числами, представляющими амперы — тех­
ническая версия детской задачки о картошке и моркови).
В этой программе два объектных типа — показатели и множе­
ство модулярных целых, на котором действует возведение в степень, —
должны быть полностью несовместимыми. Определения типов нас убе­
ждают в этой несовместимости. Разделение типов дает второе немало­
важное преимущество: возможность переопределения операций и под­
программ, воздействующих на объекты родительского типа; но это уже
другой случай, к которому мы обратимся впоследствии.
Когда выводится тип, производный тип наследует, априори, все
свойства родительского типа, и, в частности, все происходит так, при
отсутствии явного противоположного указания, как если бы все про­
цедуры и функции, в спецификации которых появляется родительский
тип, были повторно определены, и в этот раз с упоминанием типа, про­
изводного от родительского типа (это не совсем точно, но на данный
момент достаточно; чтение справочника, который мы не будем здесь
перефразировать, поможет в затруднительных случаях). В частности,
это приводит к тому, что обычные элементарные операции, опреде­
ленные на целых числах (сложение, умножение...) наследуются типа­
ми {\it Exponent} и {\it Modular \_ Integer}. К счастью! Если пришлось бы повторно
определять все операции каждый раз при определении нового типа,
программирование было бы очень трудным!
После нескольких определений переменных (без новшествпо отно­
шению к предыдущей программе) находим конкретизации настраивае­
мых пакетов ввода-вывода для всех обрабатываемых типов; созданные
таким образом пакеты сразу же применяются в качестве объекта спе­
цификатора {\bf use}, чтобы облегчить использование процедур, которые

\newpage

\noindent они содержат. Затем идет определение функции умножения целых мо­
дульных чисел; эта функция использует стандартное умножение целых
чисел — умножение, которое унаследовал тип {\it Modular \_ Integer} при своем
построении.
И, наконец, эта программа очень похожа на предыдущую, и мы те­
перь сможем направить наши усилия на более общую версию функции
дихотомического возведения в степень.

\section{ 3.3 Итерация в моноиде — Настраиваемые функции}


\noindent Если мы хотим реализовать метод более общим способом, перед нача­
лом программирования нужно задать себе несколько вопросов:
\begin{center}
\parbox{12cm}{
1. В каких границах применяется этот метод? В случае необходи­-
   мости, в каких особых границах он будет применяться?

2. Каково формальное определение обрабатываемых объектов?

3. Какие ошибки могут возникнуть при использовании модуля, ре­ализующего метод?           Будут ли обнаружены эти ошибки во времякомпиляции или же они появятся при выполнении?

4. Каков тип потенциальных пользователей этого модуля? Суще­-
   ствуют ли такие пользователи?

5. В каком виде он будет реализован? И каков его интерфейс?
}
\end{center}
Когда можно ответить на эти вопросы или, по крайней мере, дать ча­
стичные ответы, тогда можно приступать к программированию. В ин­
тересующем нас случае представляем некоторые элементы ответа:
\begin{enumerate}


\item Метод может применяться в любом моноиде, как уже неоднократ­
но говорилось, хотя никогда до сих пор мы не были поставлены в
столь общие рамки. Окончательное наше желание — применить
его в любом моноиде, при условии, что такая структура будет
определена в программе\footnote{В действительности, в этой версии будет еще существовать ограничение в пред­
ставлении моноида. Но это уже тонкости программирования на языке Ада.}.
\item Рассматриваемый объект — это моноид, математическое опреде­
ление которого следующее: моноид — это структура, состоящая
из некоторого множества, закона внутренней композиции, {\bf ассо-
циативного} на этом множестве, и выделенного элемента множе­
ства, который для этого закона является {\bf нейтральным элементом}. Дополнительно, метод использует множество натуральных
чисел — для показателей — и, хотя в математике этот объект
универсален, нужно его точно определить в программе.

\newpage

\item Основные ошибки, которые могут появиться:
\begin{itemize}
\item ошибки вычисления, вызванные переполнением разрядной
сетки; эти ошибки будут, в принципе, обнаружены средой
выполнения Ада-программы (дальше мы увидим, что лучше
распространять определенные исключения, чем предопреде­
ленные исключения языка; но в данный момент и без этого
все достаточно сложно);
\item ошибки, возникающие вследствие округлений или потерь точ­
ности, когда используют метод на неточно представленных
структурах, например, числах с плавающей запятой; такие
ошибки, если провести исследование числового поведения
программы, неизбежны и не поддаются обнаружению, если
серьезно не изучать результаты выполнений. Однако, этот
тип ошибок не должен появиться при использовании данно­
го метода, поскольку речь идет о точном, алгебраическом
вычислении;
\item ошибки в использовании метода: либо используемые типы
неадекватны, что компилятор обнаружит, либо эти же са­
мые типы не соблюдают определенный диапазон использова­
ния; например, если используемый показатель — целое от­
рицательное число, то в конце программы, вероятно, будет
ошибка. Можно, не перегружая слишком алгоритм, испра­
вить этот особый дефект.
Зато использование этого алгоритма с неассоциативным зако­
ном — т.е. не в моноиде — среди таких законов есть очень из­
вестные (вычитание и деление, например) приведет к получению
непредсказуемых результатов, которые невозможно будет испра­
вить; но в этом случае мы выходим за рамки применимости ме­
тода.
\end{itemize}
\item Желание каждого уважающего себя программиста состоит в том,
чтобы его продукция использовалась повсеместно. В данном слу­
чае наша цель — не увеличивать ограничения, изложенные ранее,
помня о том, что спецификация должна быть подтверждена очень
точными документальными данными.
\item Учитывая вышеизложенные моменты, мы решили реализовать
окончательную версию дихотомического возведения в степень в
виде настраиваемой функции. Это позволит определить параме­
тры модуля, построенного с помощью типа элементов обрабаты-
\end{enumerate}
\newpage

\begin{center}
\parbox{12cm}{
ваемого множества, ассоциативного закона и нейтрального эле­
мента этого закона, т.е. с помощью рассматриваемого моноида.
}
\end{center}


\subsection{ Настраиваемая функция дихотомического алгоритма возведения в степень}

\noindent Настраиваемая функция или, в более общем виде, настраиваемый блок
компиляции в основном образован из двух частей: спецификации, со­
держащей описание {\bf формальных параметров настройки} , и соот­
ветствующей реализации. Описание формальных параметров настрой­
ки позволяет установить характер и тип объектов, которые очень точ­
но определяют функцию при ее реализации. В нашем случае этих па­
раметров четыре, и первые три в точности соответствуют триплету,
определяющему моноид:
\begin{itemize}
\item тип элементов моноида,
\item закон композиции моноида,
\item нейтральный элемент моноида,
\item тип, представляющий множество натуральных чисел.
\end{itemize}
\noindent Вот спецификикация настраиваемой функции дихотомического возведе­
ния в степень:
\begin{center}
\parbox{8cm}{
{\it {\small Спецификация настраеваемой функции}}}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
generic
type ${\it Monoid\_ Element}$ is private;
with function ${\it "\ast " (a, b : Monoid\_ Element)}$ return ${\it Monoid\_ Element;}$
${\it Mooid\_ Unit :}$ in ${\it Monoid\_ Element;}$
type ${\it Exponent}$ is range <>;
function ${\it Dichotomic\_ Exponentiation (x0 : Monoid\_ Element; n0 : exponent)}$
$\qquad$ $\qquad$ return ${\it Monoid\_ Element;}$
\end{lstlisting}

Спецификация любой настраиваемой функции начинается с ключе­
вого слова {\bf generic}, затем следует список формальных параметров
настройки и заголовок функции. Спецификацией называют видимую
часть функции: она содержит все необходимые сведения для потенци­
ального пользователя. Способ реализации функции не имеет никакого
значения для пользователя (несколько оптимистический взгляд, но мы
будем его придерживаться); спецификация играет роль способа употре­
бления, списка указаний и противопоказаний. Формальные параметры
настройки представлены в особом виде:
\begin{itemize}
\item Тип элементов множества, соответствующий моноиду, является
личным типом: $\blacktriangleright$ {\bf type} {\it Monoid \_  Element} {\bf is private;} $\blacktriangleleft$. Это означа­
ет, что при определении функции не нужно знать точную струк-
\end{itemize}

\newpage
\begin{center}
\parbox{12cm}{
туру этих элементов. Это позволяет получить стиль программи­
рования, очень независимый от конкретных обрабатываемых объ­
ектов. В данном частном случае, например, мы вынуждены явно
задать настраиваемому блоку умножение и нейтральный элемент
(который не должен быть 1) и впоследствии ничто не помешает
использовать эту функцию, чтобы выполнить вычисления в ма­
тричном моноиде.}
\end{center}
\begin{itemize}
\item Формальные параметры типа функции или процедуры вводятся
ключевым словом {\bf with :}$\blacktriangleright$ {\bf with function "$\ast$"}
{\it (a,b: Monoid-Ele­ment)} {\bf return .....}$\blacktriangleleft$, что позволяет их отличить от настраивае­
мого объекта, которому задается спецификация. Здесь закон мо­
ноида обозначен операцией. Это означает, что, если мы хо­
тим, чтобы в определении функции возведения в степень появи­
лось произведение двух элементов моноида, то нужно использо­
вать операцию умножения. Разумеется, это не приводит к пере­
оценке конкретной функции, которая используется как фактиче­
ский параметр во время реализации и которая может быть стан­
дартным сложением, стандартным умножением или любой другой
функцией, определенной пользователем.
\item Третий формальный параметр настройки - это нейтральный эле­
мент моноида, который должен быть явно задан при реализации:
$\blacktriangleright$ {\it Monoid.unit}: {\bf in} {\it Monoid-Element};$\blacktriangleleft$ - Ключевое слово in, появив­
шееся в этом описании, означает, слегка упрощенно, что объект
является константой.
\item Наконец, тип показателей — это последний формальный параметр
настройки. Этот тип должен быть целым типом машины; это
уточнение выражено в виде: $\blacktriangleright$ {\bf type} {\it Exponet.Type} {\bf is range} < > ; $\blacktriangleleft$ .
В момент реализации может быть использован любой целый тип,
будет ли это целый предопределенный тип или целый тип, опреде­
ленный пользователем («целый тип» подразумевается в значении
языка Ада).
\end{itemize}
Последняя часть спецификации настраиваемого блока — это описа­
ние самой функции, т.е. описание типа параметров и результата: заго­
ловок функции.
Блок компиляции состоит из спецификации и тела; однако, иногда
спецификация интегрирована в тело; в частности, это случай проце­
дуры, которая играет роль главной программы во всех примерах. По­
сле того, как мы изучили текст спецификации настраиваемой функ­
ции, нам остается изучить ее тело. Тело настраиваемой функции очень
похоже на тело функций, которые мы изучали до сих пор, и, за ис-
\end{document}

