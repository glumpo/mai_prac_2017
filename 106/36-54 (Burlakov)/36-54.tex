\begin{table}
\centering
\begin{tabular}{|*{2}{l|}}
\hline
\underline{А. Алгоритмы с полным доказательставом} & \underline{В. Окончательный вариант}\\[2mm]

c $\longleftarrow$ 1; x$\longleftarrow$ $x_0$; n $\longleftarrow$ $n_0$ & x$\longleftarrow$ $x_0$; n$\longleftarrow$ $n_0$; \\
c$\times x^n$ = ${x_0}^{n_0}$ & {\bf if} {\it n} mod 2 $\neq$ 0 {\bf then}\\
{\bf while} $n\neq$ 0 {\bf loop} &\hspace*{8pt} $c \longleftarrow x$;\\
\hspace*{8pt} c$\times x^n ={x_0}^{n_0}$ $\text{ и}$ n >0 & {\bf else} \\
\hspace*{8pt} {\bf if} n mod 2 $\neq$ 0 {\bf then}  &\hspace*{8pt} c$ \longleftarrow$ 1;\\
 \hspace*{16pt}$c \longleftarrow c \times x;$ & {\bf end if};\\
\hspace*{8pt} {\bf end if}; & {\bf loop}\\
\hspace*{8pt} $ c(x^2)^{[n/2]} = {x_0}^{n_0}$ & \hspace*{8pt} $n \longleftarrow [n/2]; c \times {(x^2)}^n = {x_0}^{n_0}$\\
\hspace*{8pt} n $\longleftarrow [n/2]$; & {\bf exit when n} = 0;\\
\hspace*{8pt} $ c \times {(x^2)}^n =(x^2)^{[n/2]}$ & \hspace*{8pt}$x \longleftarrow x \times x;$\\
\hspace*{8pt} $x \longleftarrow x \times x;$ & \hspace*{8pt} {\bf if} n mod 2 $\neq$ 0 {\bf then} \\
\hspace*{8pt} c$\times x^n$ = ${x_0}^{n_0}$ &\hspace*{16pt} $c \longleftarrow c \times x;$\\
{\bf end loop}; &\hspace*{8pt} {\bf end if};\\
c$\times x^n ={x_0}^{n_0}$ $\text{ и}$ n =0 & {\bf end loop};\\
{\bf return} c; & {\bf return} c;\\

\hline
\end{tabular}
\end{table}
$\hfill$ {\bf Алгоритм 2.} Дихотомическое возведение в степень $\hfill$
\newline

 Мы видим (алгоритм 2-В)окончательную версию дихотомического\linebreak
алгоритма возведения в степень. Версия эта очень близка к разработке \linebreak
в языке Ада. Во избежание усложнения алгоритма (и это правило будет\linebreak применено к большинству представляемых алгоритмов) единственное\linebreak утверждение, фигурирующее еще в тексте алгоритма,- это ивариант\linebreak
 цикла позволяющий правильно понять испольуемый метод.
\newline

\subsection{Изучение сложности алгоритма}
\noindent Чтобы завершить изучение алгоритма, остается оценить его слож­-\linebreak
ность, т.е. сосчитать с достаточной точностью число элементарных\linebreak
операций, необходимых для его выполнения при фиксированных дан­-\linebreak
ных. Ясно, что число итераций, необходимых для выполнения алгорит­-\linebreak
ма, зависит только от показателя. Упростим обозначения, предполо­-\linebreak
жив, что $n$ (вместо $n_0$) — показатель, и предположим, в соответствии с\linebreak
обозначениями, введенными при исследовании рекуррентного алгорит­-\linebreak
ма, что число цифр в двоичной записи $n$ равно $t + 1$. Это равносильно\linebreak
тому, что

\begin{equation*}
  2^t \le n < 2^{t+1} \  {\text {или} }  \  t \le \log_2 n < t+1 
\end{equation*}
Первая часть этого свойства может быть выражена следующим обра­-\linebreak
зом: [$n/2^(t+1)$] =0 и [$n/2^t$] $\not=$ 0 что позволяет точно определить число\linebreak
\noindent совершаемых делений $n$, равное числу итераций алгоритма при задан­-\linebreak
ном значении $n$. Очевидно, нужно совершить $t + 1$ итераций, чтобы\linebreak
выполнить алгоритм, т.е. [$log_2 n$] + 1 итераций. Следовательно, тру­-\linebreak
доемкость алгоритма есть $O(log n)$. Порядок величины — достаточная\linebreak
оценка, начиная с момента, когда константа, замаскированная обозна­-\linebreak
чением О, находится в разумных пределах, как в данном примере. Мож­-\linebreak
но было бы уточнить число операций, но это не представляет большого\linebreak
интереса.
\newline

\begin{center}
\parbox{12cm}{
{\bf Замечание .} Как было уже сказано в начале раздела, дихотоми­
ческий алгоритм возведения в степень не всегда является опти­
мальным методом для вычисления $n$-й степени элемента моноида,
даже если базовая операция выполняется за постоянное время.
Например, чтобы сосчитать $x^{15}$ , используя дихотомическое воз­
ведение в степень, требуется 6 умножений: сосчитать $x^2$ , $x^4$ , $x^8$
и умножить вместе $х$ и эти три величины. Однако, если начать с
вычисления $x^5$ (посредством $х , x^2$ и $x^4$ ), возводя последнюю вели­
чину в куб, сосчитаем $x^{15}$ за 5 умножений. Метод, использован­
ный в вычислении, известен как «цепочка сложений» и идея его
следующая: цепочка сложений для $n$ — это последовательность
целых чисел $a_0 = 1, a_1 , a_2, . . . , a_r = n$, которая удовлетворяет сле­дующему свойству:}
\end{center}
\[
\forall i\in [1,r], \exists j,k \hspace*{10pt} \text{ такие,что } \hspace*{10pt} 1\leqslant k \leqslant j<i {\text{ и  }} a_i    =a_j + a_k .
\]
\begin{center}
\parbox{12cm}{
Цель изучения цепочек сложения в том, чтобы найти при лю­
бом n как можно более короткую цепь сложений. Затем можно
применить полученный результат для открытия самого эффек­
тивного метода, позволяющего вычислить $x^n$ с помощью умно­
жений. Не вдаваясь в детали метода, проиллюстрируем основ­
ной принцип использования цепочек сложения. Предположим, что
требуется вычислить $x^{54}$ . Чтобы произвести расчет дихотомиче­
ским методом, нужно сосчитать следующие степени $x : x , x^{2} , x^{4} ,
x^{8}, x^{16} и x^{32}$ . Потом выполнить необходимые умножения этих
чисел друг на друга. Если выполнить сразу только одно умно­
жение и расположить полученные члены в порядке возрастания
степеней, то получим последовательность $x , x^{2}  , x^{4} , x^{6} , x^{8} , x^{16}, x^{22} , x^{32} и x^{54}$ . Эта последовательность, совершенно очевидно, со­ответствует цепи сложений (1 ,2 ,4 ,6 ,8 ,1 6 ,2 2 ,3 2 ,5 4 ), которая не
минимальна, потому что 54 можно получить при помощи це­пи (1 ,2 ,3 ,6 ,9 ,1 8 ,2 7 ,5 4 ), являющейся минимальной. Это означа­ет, что вычисление 54-й степени х произойдет очень быстро привыполнении расчетов:}
\end{center}
\[
x_0=x,  x_1=x_0*x_0=x^2 ,
\]
\newpage

\begin{tabular}{c}

$\hfill$ $x_2 = x_0 \cdot  x_1 = x^3$, $x_3 = x_2 \cdot =x^6$, $x_4=x_2 \cdot =x^9$, $\hfill$\\
  $ \qquad x_5 = x_4 \cdot x_4 = x^{18}$,  $x_6 = x_4 \cdot x_5 = x^{27}$,  $x_7 = x_6 \cdot x_6 = x^{54}$.  \\
\end{tabular}

\begin{center}
\parbox{12cm}{
Заинтересованный читатель может обратиться к работе [99]: $\ll$Ис­
кусство программирования $\gg$, откуда были взяты описанные при­
меры.}
\end{center}
$\newline$
$\newline$

\section{  Введение в программирование  на языке Ада}
$\newline$
\noindent Пришло время представить первые программы на языке Ада. Основной\linebreak
прием, используемый для этого, заключается в представлении исходно­-\linebreak
го текста\footnote{В этом контексте исходный текст обозначает файл, который содержит текст
программы на исходном языке (здесь Ада) и который после компиляции порожда­
ет файл, записанный на целевом языке (обычно, машинный язык). Для краткости
часто просто говорят о программе или исходном модуле в отличие от объектной
программы или объектного модуля.} на языке Ада, результатов выполнения — чаще всего для\linebreak
определения времени их получения — и комментария к Ада-программе\linebreak
для объяснения новых введенных понятий или специальной техники\linebreak
программирования.
$\newline$
\subsection{Программа сравнения двух методов возведения в степень} 

\noindent Эта первая программа — непосредственное воплощение алгоритма,\linebreak
изученного ранее; она позволяет сравнить время вычисления дихотоми­-\linebreak
ческого алгоритма возведения в степень и алгоритма возведения в сте­-\linebreak
пень посредством последовательных умножений. Разумеется, резуль­-\linebreak
тат не будет неожиданным: первый алгоритм требует ${\it O}$(logn) умно­-\linebreak
жений, а второй ${\it O}$(n); однако, полученные величины могут удивить\linebreak
того, кто не имеет опыта в этом типе вычислений и кто только с пози­-\linebreak
ций теории знает о различии в росте между линейной и логарифмиче­-\linebreak
ской функциями. Для измерения времени мы используем стандартную\linebreak
библиотеку {\it Calendar}, хронометр которой имеет разрешающую способ­-\linebreak
ность около 50 мкс (для нашего компилятора).

\newpage
\begin{table}
\centering
\begin{tabular}{|*{6}{c|}}
\hline 
\multicolumn{3}{|l|}{Входные данные} & \multicolumn{2}{l|}{Время вычисления (сек.)} & Результат\\
p & x & n & Послед.умн. & Дих.возв. в ст. & $x^n$ mod {\it p}\\ 
\hline
181 & 11 & 1 024 & 0.050& 0.000& 126\\
 & 17& 4 096& 0.221 & 0.000& 39\\
 & 23 & 16 384 & 0.710 & 0.000& 15\\
 & 29 & 65 536 & 2.859 & 0.000& 29\\
 & 31 & 262 144 & 11.370 & 0.000& 59\\
 & 37 & 1 048 576 & 45.529 & 0.000 & 34\\
 & 41 & 4 194 304 & 182.130 & 0.000 & 15\\
 & 43 & 16 777 216 & 728.090 & 0.000 & 43\\
 & 47 & 67 108 864 & 2912.370 & 0.000 & 102\\
\hline
\end{tabular}
\caption{ Вычисление $x^n mod p$}
\end{table}
Несколько комментариев по таблице 1:

$\bullet$ прежде всего, и это не зависит от сделанных измерений, расчеты\linebreak
\hspace*{24pt}производились по модулю целого числа {\it p} , чтобы можно было оце­-\linebreak
\hspace*{24pt}нить большие степени, не сталкиваясь с проблемами переполнения
\hspace*{24pt}машины целыми числами;

$\bullet$ когда используют таблицу этого типа, в которой представлены\linebreak
\hspace*{24pt}измерения времени вычисления, не нужно никогда забывать, с ка­-\linebreak
\hspace*{24pt}кой точностью были сделаны эти измерения (разрешающая спо­-\linebreak
\hspace*{24pt}собность таймера); в этом примере, в частности, время выполне­-\linebreak
\hspace*{24pt}ния порядка 50 мкс не было значимым;

$\bullet$ в самом деле, заключаем, что сложность возведения в степень ме­-\linebreak
\hspace*{24pt}тодом последовательных умножений является линейной по отно­-\linebreak
\hspace*{24pt}шению к показателю: в каждой строке таблицы, показатель, так\linebreak
\hspace*{24pt}же, как и время вычисления, умножается на 4; предпоследнему\linebreak
\hspace*{24pt}измерению соответствует время вычисления около 12 минут, при\linebreak
\hspace*{24pt}вполне разумном суммарном значении показателя, а последнее из­-\linebreak
\hspace*{24pt}мерение, при показателе порядка 70 миллионов, дает нам время\linebreak
\hspace*{24pt}абсолютно неразумное (около 50 минут); это доказывает, что ал­-\linebreak
\hspace*{24pt}горитм, работающий с помощью метода последовательных умно­-\linebreak
\hspace*{24pt}жений не может быть использован в контексте более широком,\linebreak
\hspace*{24pt}чем сравнение алгоритмов;

$\bullet$  зато невозможно выявить малейшее изменение времени вычисле­-\linebreak
\hspace*{24pt}ния для дихотомического алгоритма возведения в степень, при\linebreak
\hspace*{24pt}таких {\it малых} значениях {\it n};

$\bullet$ число, по модулю которого производятся вычисления, является\linebreak
\hspace*{24pt}наибольшим простым числом $р$ таким, что ($р—1)^2$ $\leqslant$ $2^{15}$ — 1; это\linebreak
\hspace*{24pt}означает, что умножения по модулю р могут быть сделаны на ма­-\linebreak
\hspace*{24pt}шине,оперирующей целыми 16-битовыми числами (со знаками),\linebreak

\newpage
\begin{center}
\parbox{12cm}{
без риска переполнения (читатель, желающий больше узнать об
арифметике компьютеров, может обратиться к Таненбауму [168],
Мюллеру [132] или Менадье [126]);}
\end{center}
\begin{itemize}
\item результат вычисления, $x^n$ mod {\it р}, хотя и приведен в этой таблице,\linebreak
абсолютно не представляет никакого интереса; но программа без\linebreak
результатов еще способна шокировать чувствительные сердца.
\end{itemize}

 Этот первый пример не может служить образцом программирова­- \linebreak
ния на языке Ада, в том смысле, что опытный программист не записал\linebreak
бы его в такой форме. В частности, типизация данных чрезвычайно\linebreak
слаба: моноид, на котором действует возведение в степень, — это мно­-\linebreak
жество целых чисел по модулю {\it р} с обычным умножением, представлен­-\linebreak
ное в программе типом {\it Integer}, показатель — предопределенного ти­-\linebreak
па {\it Long\_ Integer}, чтобы иметь возможность использовать относительно\linebreak
большие показатели. Эти два типа еще не очень различаются, но ведь\linebreak
речь пока идет только о написании первой Ада-программы; этот тип\linebreak
программирования больше приближен к программированию на языке\linebreak
Паскаль, с которым читатель может быть более знаком. «Хороший» ва­-\linebreak
риант Ада-программы будет представлен в конце этого раздела после\linebreak
введения основных понятий языка Ада.
\begin{center}
\parbox{8cm}{
{\it {\small Программа оценки дихотомического возведения в степень}}}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small, frame=lrt]
    with ${\it Text\_ IO, Calender;}$
    procedure ${\it Exponentiation\_ First\_ Version}$ is
    ${\it p :}$ constant ${\it Integer := 181}$
    subtype ${Modular\_ Integer}$ is ${\it Integer}$ ranger ${\it 0 ..p-1}$ 
    ${\it x , Dichotomic\_ Result, Sequential\_ Result : Modular\_ Integer;}$
    ${\it n : Long\_ Integer ;}$
    ${Begin\_ Time : Calendar.Time;}$
    ${Computation\_ Time : Duration;}$
    $\newline$
    package ${Long\_ Integer\_ IO}$ is new ${Text\_ IO.Integer\_ IO (Long\_ Integer);}$
    package ${Modular\_ Integer\_ IO}$ is new ${Text\_ IO.Integer\_ IO (Modular\_ Integer);}$
    package ${ Duration\_ IO}$ is new ${Text\_ IO.Fixed\_ IO (Duration);}$
    use ${\ Calendar, Text\_ IO, Duration\_ IO, Modular\_ Integer\_ IO, Long\_ Integer\_ IO;}$
    $\newline$
    function ${Dichotomic\_ Exponentiation (x0 : Modular\_ Integer; n0 : Long\_ Integer)}$
   $\qquad$ $\qquad$ return ${\it Modular\_ Intger}$ is
    ${\it x : Modular\_ Integer := x0;}$
    ${\it n : Long\_ Integer := n0;}$
    ${\it Correction : Modular\_ Intrger;}$
   begin
    if ${\it n}$ mod ${\it 2 /=0}$ then ${Correction :=x}$ mod ${\it p;}$ else ${\it Correction := 1;}$ end if;
    loop
     ${\it n:= n/2;}$
 
   \end{lstlisting} 

\newpage
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small, frame=lrb]
   exit when n = 0;
    $x := (x \ast x)$ mod p;
    if n mod ${\it 2 /= 0}$ when ${\it Correction := (Correction \ast x)}$ mod p;
   end loop;
   return ${\it Correction;}$
  end ${\it Dichotomic\_ Exponentiation;}$
  $\newline$
  function ${\it Sequntial\_ Exponentiation (x0 : Modular\_ Integer; n0 : Long\_ Intege)}$
  $\qquad$ $\qquad$ return ${\it Modular\_ Integer}$ is
  ${\it x\_ To\_ i : Modular\_ Integer := 1;}$
  begin
   for i in 1 .. n0 loop ${\it x\_ To\_ i := (x\_ To\_ i \ast x0)}$ mod p; end loop;
   return ${\it x\_ To\_ i;}$
  end ${\it Sequential\_ Exponentiation;}$
  $\newline$
  begin - - ${\bf Exponentiation\_ First\_ Version}$
   ${\it Put\_ Line }$ ${\bf ("Оценка\_ дихотомического\_ возведения\_ в\_ степень.\_");}$
  $\newline$
  loop
   ${\it Get(x);}$
  exit when ${\it x = 0}$
   ${\it Get (n); Put (x); Put(n);}$
    $\newline$
  
   ${\it {\bf Begin\_ Time} := Clock; Sequential\_ Result := Sequential\_ Exponentiation (x, n);}$
   ${\it Computation\_ Time := Clock - Begin\_ Time; Put (Computation\_ Time);}$

   ${\it {\bf Begin\_ Time} := Clock; Dichotomic\_ Result := Dichotomic\_ Exponentiation (x, n);}$
   ${\it Computation\_ Time := Clock - Begin\_ Time; Put (Computation\_ Time);}$
  
   if ${\it Dichotomic\_ Result = Sequential\_ Result}$ then ${\it Put  (Dichotomic\_ Result);}$
   else raise ${\it Numeric\_ Eror;}$
   end if;
   ${\it New\_ line;}$
  end loop;
  end ${\it Exponentiation\_ First\_ Version}$
  \end{lstlisting} 

Комментарий к этой программе заключается, в основном, в описа­-\linebreak
нии структуры Ада-программы. В общих чертах, программа в языке\linebreak
Ада — это процедура (без параметров, в случае используемого нами\linebreak
компилятора), построенная на основе элементарных или сложных дей­-\linebreak
ствий и объектов, которые можно определить во внешних {\bf блоках ком­-\linebreak пиляции} — блоки могут быть процедурами, функциями или {\bf пакета­\linebreak
ми} (название, данное тому, что в других языках называется модулями\linebreak
или библиотеками).

\newpage

Предыдущая Ада-программа образует блок компиляции, в данном\linebreak
случае являющийся главной программой; она состоит, в основном, из\linebreak
двух частей:
\begin{itemize}
\item определение контекста компиляции (оператор {\bf with} ); этот опе­-\linebreak
ратор позволяет компилятору распознать используемые внешние\linebreak
объекты, определенные в другом блоке компиляции, и убедиться\linebreak
в связности между их спецификацией и использованием;
\item текст подпрограммы, соответствующий блоку компиляции.
\end{itemize}

\noindent Оператор контекста  $\blacktriangleright$ {\bf with} {\it Text\_ IO , Calendar} $\blacktriangleleft$ касается двух стан­-\linebreak
дартных пакетов: первый из этих модулей {\it Text\_ IO} содержит все обы-\linebreak
­ные процедуры ввода-вывода текстовых файлов (включая, конечно,\linebreak
клавиатуру и экран); под этим понимается считывание и написание\linebreak
знаков, последовательностей знаков, чисел различных типов и т.д. Па­-\linebreak
кет {\it Calendar} содержит определения типов, операторов и подпрограмм,\linebreak
которые позволяют произвести измерение времени.

Затем идет определение процедуры, которая играет роль главной\linebreak
программы; с точки зрения структуры, эта процедура полностью ана­-\linebreak
логична процедуре на языке Паскаль. Она включает, в определенном\linebreak
порядке, последовательность описаний констант, типов и переменных,\linebreak
несколько конкретизаций настраиваемых пакетов, определения функ­-\linebreak
ций и, наконец, само тело процедуры.

Рассмотрим, прежде всего, описательную часть данной процедуры.\linebreak
После определения константы {\it p} находим определение {\bf подтипа} , в ко­-\linebreak
тором будут сделаны расчеты:  {\bf subtype} {\it Modular\_ Integer} {\bf is} {\it Integer} \linebreak
{\bf range} $O..p — 1;\blacktriangleleft$. 
Это определение позволяет ограничить множество\linebreak
допустимых значений, а среди целых значений рассматривать только\linebreak
те, которые заключены между 0 и р — 1. Это приводит, в частности, к\linebreak
тому, что во время выполнения программы операционная среда языка\linebreak
Ада будет контролировать значения переменных типа {\it Modular\_ Integer}\linebreak
и вызовет внезапную остановку программы, если эти значения выйдут\linebreak
за рамки намеченного интервала. После данного определения типа мы\linebreak
видим описания трех переменных этого подтипа, используемых в ходе\linebreak
вычислений, потом переменную, представляющую показатель. Данная\linebreak
переменная относится к (предопределенному) типу {\it Long\_ Integer}, несо-\linebreak
вместимому с типом {\it Integer}.

\begin{center}
\parbox{12cm} {
{\bf Замечания.} Ада имеет несколько предопределенных типов, ко­
торые мы не будем здесь подробно рассматривать; их список
можно найти в приложении {\it F} в справочнике, сопровождающем
любой компилятор, достойный этого названия. Однако, мы ска­
жем несколько слов о целых типах. Компилятор языка Ада дол-}
\end{center}
\newpage
\begin{center}
\parbox{12cm}{
жен предоставить, как минимум, один предопределенный целый
тип, называемый {\it Integer}, кроме того, он может давать другие це­
лые типы с названиями {\it Short-Integer, Long-Integer, Short-Short-In­
teger}, . . . характеризуемые тем, что, например, тип {\it Short-Integer}
не может быть больше типа {\it Integer}, который в свою очередь не
может быть больше типа {Long\_ Integer} . . . как скучно все это объ­
яснять!

Это наложение на целые типы позволяет высказать дополни­
тельные критические замечания по поводу предыдущей програм­
мы. Действительно, идентификатор {\it Long\_ Integer} появляется там
отчетливо несколько раз, и это означает, что нужно будет сде­
лать много модификаций при переносе этой программы на ма­
шину, компилятор которой не содержит типа {\it Long\_ Integer}. Этот
недостаток исправлен в последующих Ада-программах. Данная
первая версия представляет только первый опыт программиста,
привыкшего писать на Паскале.}
\end{center}

Переменная {\it Begin\_ Time} принадлежит типу {\it Time}, определенному в\linebreak
пакете {\it Calendar} и обозначающему набор время-дата. Без дополнитель­-\linebreak
ного уточнения после спецификатора контекста этот тип не является\linebreak
непосредственно видимым, и нужно задать компилятору Ада путь, по­-\linebreak
зволяющий обнаружить определение в описанных модулях, что и де­-\linebreak
лается с помощью выражения {\it Calendar. Time}, обозначающего, что тип\linebreak
{\it Time} определен в пакете {\it Calendar}. Во избежание тяжеловесности запи­-\linebreak
си, вызванной этим феноменом, нужно, чтобы объекты пакета Calen­-\linebreak
dar стали видимыми, начиная с подпрограммы, что и делается в строке\linebreak
программы, содержащей спецификатор $\blacktriangleright$ {\bf use Calendar }$\blacktriangleleft$ : с этого опе-\linebreak
ратора все происходит так, с точки зрения видимости, как если бы\linebreak
описания пакета {\it Calendar} фигурировали в тексте подпрограммы.\linebreak
Последняя переменная программы, {\it Computation\_ Time}, типа {\it Dura­-\linebreak
tion}, используется для выражения результатов измерений времени, вы­-\linebreak
полненных в программе. Тип {\it Duration} — это предопределенный тип,\linebreak
позволяющий найти продолжительность, выраженную в секундах: это\linebreak
реальный тип с фиксированной точкой, т.е. с точностью абсолютной,\linebreak
а не относительной, как в случае реальных типов с плавающей точкой.\linebreak
Язык Ада типизирован до такой степени, что, к примеру, процеду­-\linebreak
ры ввода-вывода отличаются для объектов различных типов; это при­-\linebreak
дает языку большую однородность. Однако, было бы не очень удобно\linebreak
определять такие процедуры для каждого численного типа, который\linebreak
хотят использовать, — на самом деле способ вывода чисел целого ти­-\linebreak
па всегда одинаковый, независимо от того, о каком целом идет речь:\linebreak
обыкновенном, длинном или о любом другом целом типе, определенном\linebreak

\newpage

\noindent пользователем. Рассуждение совершенно аналогично для определенных\linebreak
пользователем действительных, символьных и других типов. По этим\linebreak
причинам и по многим другим, которые возникнут позднее, язык Ада\linebreak
обладает понятием настраиваемого объекта, позволяющим более легко\linebreak
воплотить абстрактные типы.

Таким образом, стандартный пакет {\it Text\_ IO} содержит определен­-\linebreak
ное число настраиваемых подпакетов, позволяющих без труда создать\linebreak
для каждого особого типа процедуры ввода-вывода, соблюдая типовые\linebreak
ограничения, необходимые для связности и точности языка: для целых\linebreak
типов, например, настраиваемый пакет ввода-вывода — {\it Text\_ IO.Inte-\linebreak
ger\_ IO} В определении настраиваемого модуля некоторые параметры\linebreak
функционирования модуля не уточняются, но прежде, чем использо­-\linebreak
вать такой модуль, нужно явно указать эти параметры. Таким обра­-\linebreak
зом, параметры настраиваемого пакета {\it Integer\_ IO} определяются целым\linebreak
типом, для которого предполагается реализовать ввод-вывод; во время\linebreak
своей {\bf конкретизации} — фазы, позволяющей вызвать генерацию, —\linebreak
исходя из общей совокупности объектов, предназначенных для исполь­-\linebreak
зования, нужно уточнить целый тип, который придется обрабатывать.\linebreak
В примере этой программы имеются два целых типа, для которых не­-\linebreak
обходимо зарегистрировать методы ввода-вывода; итак, находим две\linebreak
конкретизации пакета {\it Integer\_ IO}. Два новых пакета определены; в даль­-\linebreak
нейшем можно будет на них ссылаться.
\begin{center}
\parbox{14cm}{
{\bf package} {\it Long\_ Integer\_ IO} {\bf is new} {\it Text\_ IO.Integer\_ IO (Long\_ Integer);}\\
{\bf package} {\it Modular\_ Integer\_ IO} {\bf is new} {\it Text\_ IO.Integer\_ IO (Modular\_ Integer);}}
\end{center}
Затем в исходном тексте находим конкретизацию для типа {\it Dura­-\linebreak
tion} настраиваемого пакета {\it Fixed\_ IO}, позволяющего производить ввод-\linebreak
вывод действительных типов с фиксированной точкой. Потом, для об­-\linebreak
легчения записи последовательности программы, четыре пакета ввода-\linebreak
вывода перечисляются в описанном выше операторе {\bf use} (что делает\linebreak
видимым все объекты внутри пакетов, и при отсутствии конфликтов\linebreak
позволяет использовать эти объекты без упоминания их источника).\linebreak
После всех этих описаний находим в тексте две функции возведения\linebreak
в степень, которые служат для сравнения двух разработанных методов.\linebreak
Эта часть Ада-программы не требует много комментариев потому, что\linebreak
она точно отражает алгоритм, изученный в разделе 2.2 (страница 36);\linebreak
единственная неизвестная команда — это {\bf return} , которая вызывает\linebreak
остановку функции и определение ее значения.

Важно отметить, что все параметры функции в языке Ада являются\linebreak
{\bf входящими}, или в режиме {\bf in}. Таким образом значения фактических\linebreak
параметров вызова функции передаются соответствующим формаль-\linebreak
\newpage


\noindent ным параметрам во время активации этой функции (с помощью ме­-\linebreak
тода, который нет необходимости здесь описывать). Синтаксис языка\linebreak
Ада не позволяет подпрограмме изменять свои формальные параметры\linebreak
режима {\it in}, рассматриваемые как константы в теле подпрограммы. Это\linebreak
приводит, в частности, к тому, что вызов функции не может привести\linebreak
к изменению параметров вызова (это противоречило бы логике и духу\linebreak
программирования).
И, наконец, программу завершает тело главной процедуры, требу­-\linebreak
ющее лишь небольших комментариев:

\begin{itemize}
\item функция {\it Clock} определена в пакете {\it Calendar} и возвращает дату и\linebreak
время;
\item функции {\it Put} и {\it Get} позволяют, соответственно, считывание и за­-\linebreak
пись; однако на этом этапе напрашивается замечание: хотя про­-\linebreak
цедуры считывания различны для целых и вещественных, а также\linebreak
различны для разных целых типов, обычно названия у них одина­-\linebreak
ковые. Это так называемая перегрузка идентификаторов, кото­-\linebreak
рая может использоваться только с идентификаторами функций,\linebreak
операторов или процедур. В зависимости от контекста, в частно­-\linebreak
сти, от типа параметров, компилятор устраняет двусмысленно­-\linebreak
сти;
\item работу программы достаточно легко понять: по очереди считы­-\linebreak
ваются два целых: одно $x$ типа {\it Modular\_Integer}, второе {\it n} типа\linebreak
{\it Long\_ Integer} и вычисляется  $x^n$ сначала с помощью простого мето­-\linebreak
да, потом с помощью дихотомического. Во время каждой опера­-\linebreak
ции время выполнения измеряется и выводится на экран. Наконец,\linebreak
после оценки результата двумя методами, так как речь идет об\linebreak
экспериментировании, два результата вычисления сравниваются\linebreak
(никто не застрахован от ошибки программирования!), и в слу­-\linebreak
чае (очень маловероятном), когда будет расхождение, програм­-\linebreak
ма возбуждает предопределенное исключение {\it Numeric\_ Error}, что\linebreak
приводит к ее немедленному завершению, как если бы дело ка­-\linebreak
салось ошибки выполнения. Этот механизм исключения является\linebreak
методом, избранным разработчиками языка Ада для обработки\linebreak
ошибок и их устранения. Нам еще представится случай к нему\linebreak
вернуться. Программа останавливается, когда для переменной $\ x$\linebreak
берется значение, равное нулю.
\end{itemize}
\newpage

\subsection{Об использовании типов}

\noindent После этой первой версии, представим теперь другую программу, где\linebreak
дихотомический алгоритм возведения в степень еще фигурирует, но в\linebreak
виде, который больше приближается к тому, что мы считаем програм­-\linebreak
мированием на языке Ада. В частности, обрабатываемые объекты там\linebreak
намного более типизированы, чем в первоначальной версии, что позво­-\linebreak
лит впоследствии без больших усилий построить настраиваемую вер­-\linebreak
сию дихотомического возведения в степень. Но прежде всего пример\linebreak
выполнения (таблица 2) позволяет констатировать, что при значениях\linebreak
показателя, близких к допустимому максимуму, время вычисления на\linebreak
большинстве машин не всегда будет значимым.
\begin{table}
\centering
\begin{tabular}{|*{5}{c|}}
\hline 
 \multicolumn{3}{|l|}{Входные данные} & {Время вычисления (сек.)} & Результат\\
p & x & n &  Дих.возв. в ст. & $x^n$ mod {\it p}\\ 
\hline
46 337  & 31 & 262 144 & 0.000 & 3951\\
 & 37 & 1 048 576&  0.000 & 43153\\
 & 41 & 4 194 304  & 0.000 & 1430\\
 & 43 & 16 777 216 &  0.000 & 29703\\
 & 47 & 67 108 864  & 0.000 & 26840\\
 & 53 & 268 435 456  & 0.000 & 43887\\
 & 59 & 1 073 741 824 & 0.000 & 13314\\
 & 61 & 2 147 483 647 & 0.000 & 5770\\
\hline
\end{tabular}
\caption{ Вычисление ${x^n}\mod{p}$}
\end{table}

\noindent Комментарии будут краткими:
\begin{itemize}
\item число 46337 — наибольшее простое число $р$ такое, что ($р$—1)$^2$ $\leqslant$\linebreak
$2^{31}$ — 1, следовательно, можно выполнять умножения по модулю $р$\linebreak
без риска переполнения на машине, обладающей целыми 32-бито­-\linebreak
выми числами со знаками\footnote{В языке Ада числа могут задаваться программе с использованием символа под­черкивание ($\_$) для того, чтобы сделать их более понятными; и возможно даже,
что они будут выражены не в десятичной системе счисления! Так, число 46337
может быть задано в тексте программы или при считывании в виде 46-337, или
$7\# 252J044\#$, когда его хотят выразить в системе с основанием 7.},
\item как в предыдущей таблице, целые {\it x} являются простыми числами,\linebreak
а целые {\it n}, все (кроме последнего) — степени двойки (более точно,\linebreak
{\it n} имеет форму $2^{4k}$ ),
\item целое 2 147 483 647 — это наибольшее положительное целое, ко­-\linebreak
торое может быть представлено в машине, оперирующей 32-би-\linebreak
товыми словами и использующей целую, знаковую арифметику в\linebreak
дополнительном коде (оно равно $2^{31}$ — 1).
\end{itemize}


\newpage
Основное отличие двух первых версий программы (это мы отметили\linebreak
в предыдущем параграфе) состоит в различии (на уровне используемых\linebreak
типов) между элементами моноида, в котором они работают, и пока-\linebreak
зателями, которые всегда целые; что, впрочем, не нарушает общности\linebreak
изложения. Итак, рассмотрим исходный текст этой программы:

 $\hfill$ Дихотомическое возведение в степень $\hfill$

 \begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small, frame=lrt]
    with ${\it Text\_ IO;}$ use ${\it Text\_ IO;}$ with ${\it Calender;}$ use ${\it Calender;}$
    procedure ${\it Exponentiation\_ Second\_ Version}$ is
    $\newline$
    ${\it p :}$ constant ${\it Integer := 46\_ 337;}$
    type ${Modular\_ Integer}$ is  ranger ${\it 0 ..p-1}$ 
    type ${\it Exponent}$ is new ${\it Long\_ Integer}$
    $\newline$
    ${\it n : Exponet}$
    ${\it x , Result: Modular\_ Integer ;}$
    ${Begin\_ Time : Calendar.Time;}$
    ${Computation\_ Time : Duration;}$
    $\newline$
    package ${Exponent\_ IO}$ is new ${Integer\_ IO (Exponent);}$
    package ${Modular\_ Integer\_ IO}$ is new ${Integer\_ IO (Modular\_ Integer);}$
    package ${Duration\_ IO}$ is new ${Fixed\_ IO (Duration);}$
    use ${\it Exponent\_ IO,  Modular\_ Integer\_ IO, Duration\_ IO;}$
    $\newline$
    function ${\it Multiply (a, b : Modular\_ Integer)}$ return ${\it Modular\_ Integer}$ is
   $\qquad$ $\qquad$ ${\bf - -переопределение умножения для типа Modular\_ Integer}$
   begin
   $\quad$ return ${\it Modular\_ Integer ({(a \ast b)}\mod{p});}$
   end ${\it Multiply;}$
   $\newline$
   function ${\it Dichotomic\_ Exponentiation (x0 : Modular\_ Integer; n0 : Exponent)}$ 
  $\qquad$ $\qquad$ return ${\it Modular\_ Integer}$ is
  ${\it x : Modular\_ Integer := x0;}$
  ${\it n : Exponent := n0;}$
  ${\it Correction : Modular\_ Integer;}$
  $\newline$
  begin
  if n mod ${\it 2 /= 0}$ then ${\it Correction := x;}$ else ${\it Correction := 1;}$ end if;
  $\newline$
  loop
  ${\it n := n / 2;}$
  exit when n = 0;
  ${\it x := Multiply (x, x);}$
  if n mod ${\it 2 /= 0}$ then ${\it Correction := Multiply (Correction, x);}$ end if;
  end loop;
  return ${\it Correction;}$
  end ${\it Dichotomic\_ Exponrntiation;}$
   \end{lstlisting}
\newpage
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small, frame=lrb]
begin ${\bf - -Exponentiation\_ Second\_ Version}$
${\it Put\_ Line}$ ${\bf("Дихотомический\_ возведение\_ в\_ степень\_,\_ вторая\_ версия");}$
loop
${\it Get (x);}$
exit when ${\it x = 0}$
${\it Get (n);}$
${\it Begin\_ Time := Clock;}$
${\it Result := Dichotomic\_ Exponentiation (x, n);}$
${\it Computation\_ Time := Clock - Begin\_ Time;}$
$\newline$
${\it Put (x); Put (n); Put (computation\_ Time); Put (Result); New\_ Line;}$
end loop;
end ${\it Exponentiation\_ Second\_ Version;}$
\end{lstlisting}
В начале этого текста стоит, как обычно в любой программе, специ­-\linebreak
фикатор контекста, который указывает на два пакета, а за ним сразу\linebreak
же следует соответствующий спецификатор использования {\bf use}. Специ­-\linebreak
фикатор {\bf use} может появиться в контекстной части блока компиляции\linebreak
или в любом месте описательной части: место, где появляется специ­-\linebreak
фикатор {\bf use}, определяет области видимости объектов, содержащихся\linebreak
в пакетах, на которые он указывает.

В описательной части снова видим описание константы {\it p}, но в дан­-\linebreak
ной версии она недостаточно типизирована: это, так называемая, уни­-\linebreak
версальная константа, что означает ее совместимость со всеми целы­-\linebreak
ми типами. Нормой языка Ада является то, что вычисления, выпол­-\linebreak
няемые на универсальных константах, должны быть точными, и для\linebreak
удовлетворения этой нормы любой компилятор способен производить\linebreak
расчеты на любых больших универсальных константах; в дальнейшем\linebreak
мы увидим это использование. Константа р используется затем, чтобы\linebreak
определить {\it целый тип}; этот тип определяется абсолютным способом,\linebreak
как интервал натуральных чисел (в терминологии языка Ада целые\linebreak
математические числа называются целыми универсальными). Преиму­-\linebreak
щество этого метода в том, что он делает определения используемых\linebreak
типов независимыми от предопределенных типов, существующих в кон­-\linebreak
кретной используемой реализации. При компиляции программы могут\linebreak
происходить два события, относящиеся к этому определению типа:
\begin{itemize}
\item тип не может быть представлен в реализации: в этом случае ком­-\linebreak
пилятор делает предупреждение и отказывается компилировать,\linebreak
\item тип может быть представлен, и язык Ада гарантирует, что ре­-\linebreak
зультаты вычисления будут идентичными, каковы бы ни были\linebreak
\newpage
используемая машина или реализация языка, при условии, что не\linebreak
будет переполнения.
\end{itemize}
\noindent После этого определения находим второе определение типа: $\blacktriangleright$ {\bf type} {\it Ex­po-\linebreak
 nent } {\bf is new} {\it Long\_ Integer} $\blacktriangleleft$- Это определение производного типа, что\linebreak
означает: тип Exponent идентичен по всем пунктам типу {\it Long\_ Integer},\linebreak
но эти два типа несовместимы; тип {\it Long \_ Integer} — это родительский\linebreak
тип типа {\it Exponent}. Во время записи программы, при условии преобра­-\linebreak
зования явных типов, будет совершенно невозможно соединить пере­-\linebreak
менные этих двух типов в одно выражение; эта несовместимость обес­-\linebreak
печивает большую надежность программирования, не допуская смеше­-\linebreak
ния (часто легкого) идентично представленных объектов (по причинам,\linebreak
связанным с реализацией данной программы), значения которых пол­-\linebreak
ностью отличаются друг от друга (не складывают, например, числа,\linebreak
представляющие вольты, с числами, представляющими амперы — тех­-\linebreak
ническая версия детской задачки о картошке и моркови).

В этой программе два объектных типа — показатели и множе­-\linebreak
ство модулярных целых, на котором действует возведение в степень, —\linebreak
должны быть полностью несовместимыми. Определения типов нас убе­-\linebreak
ждают в этой несовместимости. Разделение типов дает второе немало­-\linebreak
важное преимущество: возможность переопределения операций и под­-\linebreak
программ, воздействующих на объекты родительского типа; но это уже\linebreak
другой случай, к которому мы обратимся впоследствии.

Когда выводится тип, производный тип наследует, априори, все\linebreak
свойства родительского типа, и, в частности, все происходит так, при\linebreak
отсутствии явного противоположного указания, как если бы все про­-\linebreak
цедуры и функции, в спецификации которых появляется родительский\linebreak
тип, были повторно определены, и в этот раз с упоминанием типа, про­-\linebreak
изводного от родительского типа (это не совсем точно, но на данный\linebreak
момент достаточно; чтение справочника, который мы не будем здесь\linebreak
перефразировать, поможет в затруднительных случаях). В частности,\linebreak
это приводит к тому, что обычные элементарные операции, опреде­-\linebreak
ленные на целых числах (сложение, умножение...) наследуются типа­-\linebreak
ми {\it Exponent} и {\it Modular \_ Integer}. К счастью! Если пришлось бы повторно\linebreak
определять все операции каждый раз при определении нового типа,\linebreak
программирование было бы очень трудным!

После нескольких определений переменных (без новшествпо отно­-\linebreak
шению к предыдущей программе) находим конкретизации настраивае­-\linebreak
мых пакетов ввода-вывода для всех обрабатываемых типов; созданные\linebreak
таким образом пакеты сразу же применяются в качестве объекта спе­-\linebreak
цификатора {\bf use}, чтобы облегчить использование процедур, которые\linebreak

\newpage

\noindent они содержат. Затем идет определение функции умножения целых мо­-\linebreak
дульных чисел; эта функция использует стандартное умножение целых\linebreak
чисел — умножение, которое унаследовал тип {\it Modular \_ Integer} при своем\linebreak
построении.

И, наконец, эта программа очень похожа на предыдущую, и мы те­-\linebreak
перь сможем направить наши усилия на более общую версию функции\linebreak
дихотомического возведения в степень.

\subsection{Итерация в моноиде — Настраиваемые функции}


\noindent Если мы хотим реализовать метод более общим способом, перед нача­-\linebreak
лом программирования нужно задать себе несколько вопросов:
\begin{center}
\parbox{12cm}{
1. В каких границах применяется этот метод? В случае необходи­-
  \hspace*{10pt} мости, в каких особых границах он будет применяться?

2. Каково формальное определение обрабатываемых объектов?

3. Какие ошибки могут возникнуть при использовании модуля, \hspace*{10pt}  реализующего метод? Будут ли обнаружены эти ошибки во \hspace*{10pt} время компиляции или же они появятся при выполнении?

4. Каков тип потенциальных пользователей этого модуля? Суще­-
   \hspace*{10pt} ствуют ли такие пользователи?

5. В каком виде он будет реализован? И каков его интерфейс?
}
\end{center}
\noindent Когда можно ответить на эти вопросы или, по крайней мере, дать ча­-\linebreak
стичные ответы, тогда можно приступать к программированию. В ин­-\linebreak
тересующем нас случае представляем некоторые элементы ответа:
\begin{enumerate}


\item Метод может применяться в любом моноиде, как уже неоднократ­-\linebreak
но говорилось, хотя никогда до сих пор мы не были поставлены в\linebreak
столь общие рамки. Окончательное наше желание — применить\linebreak
его в любом моноиде, при условии, что такая структура будет\linebreak
определена в программе\footnote{В действительности, в этой версии будет еще существовать ограничение в пред­ставлении моноида. Но это уже тонкости программирования на языке Ада.}.
\item Рассматриваемый объект — это моноид, математическое опреде­-\linebreak
ление которого следующее: моноид — это структура, состоящая\linebreak
из некоторого множества, закона внутренней композиции, {\bf ассо-\linebreak
циативного} на этом множестве, и выделенного элемента множе­-\linebreak
ства, который для этого закона является {\bf нейтральным элементом}.\linebreak Дополнительно, метод использует множество натуральных\linebreak
чисел — для показателей — и, хотя в математике этот объект\linebreak
универсален, нужно его точно определить в программе.

\newpage

\item Основные ошибки, которые могут появиться:
\begin{itemize}
\item ошибки вычисления, вызванные переполнением разрядной\linebreak
сетки; эти ошибки будут, в принципе, обнаружены средой\linebreak
выполнения Ада-программы (дальше мы увидим, что лучше\linebreak
распространять определенные исключения, чем предопреде­-\linebreak
ленные исключения языка; но в данный момент и без этого\linebreak
все достаточно сложно);
\item ошибки, возникающие вследствие округлений или потерь точ­-\linebreak
ности, когда используют метод на неточно представленных\linebreak
структурах, например, числах с плавающей запятой; такие\linebreak
ошибки, если провести исследование числового поведения\linebreak
программы, неизбежны и не поддаются обнаружению, если\linebreak
серьезно не изучать результаты выполнений. Однако, этот\linebreak
тип ошибок не должен появиться при использовании данно­-\linebreak
го метода, поскольку речь идет о точном, алгебраическом\linebreak
вычислении;
\item ошибки в использовании метода: либо используемые типы\linebreak
неадекватны, что компилятор обнаружит, либо эти же са­-\linebreak
мые типы не соблюдают определенный диапазон использова­-\linebreak
ния; например, если используемый показатель — целое от­-\linebreak
рицательное число, то в конце программы, вероятно, будет\linebreak
ошибка. Можно, не перегружая слишком алгоритм, испра­-\linebreak
вить этот особый дефект.
\end{itemize}
Зато использование этого алгоритма с неассоциативным зако­-\linebreak
ном — т.е. не в моноиде — среди таких законов есть очень из­-\linebreak
вестные (вычитание и деление, например) приведет к получению\linebreak
непредсказуемых результатов, которые невозможно будет испра­-\linebreak
вить; но в этом случае мы выходим за рамки применимости ме­-\linebreak
тода.
\item Желание каждого уважающего себя программиста состоит в том,\linebreak
чтобы его продукция использовалась повсеместно. В данном слу­-\linebreak
чае наша цель — не увеличивать ограничения, изложенные ранее,\linebreak
помня о том, что спецификация должна быть подтверждена очень\linebreak
точными документальными данными.
\item Учитывая вышеизложенные моменты, мы решили реализовать\linebreak
окончательную версию дихотомического возведения в степень в\linebreak
виде настраиваемой функции. Это позволит определить параме­-\linebreak
тры модуля, построенного с помощью типа элементов обрабаты-\linebreak
\end{enumerate}
\newpage

\begin{center}
\parbox{12cm}{
ваемого множества, ассоциативного закона и нейтрального эле­
мента этого закона, т.е. с помощью рассматриваемого моноида.
}
\end{center}


\subsection{ Настраиваемая функция дихотомического алгоритма возведения в степень}

\noindent Настраиваемая функция или, в более общем виде, настраиваемый блок\linebreak
компиляции в основном образован из двух частей: спецификации, со­-\linebreak
держащей описание {\bf формальных параметров настройки} , и соот­-\linebreak
ветствующей реализации. Описание формальных параметров настрой­-\linebreak
ки позволяет установить характер и тип объектов, которые очень точ­-\linebreak
но определяют функцию при ее реализации. В нашем случае этих па­-\linebreak
раметров четыре, и первые три в точности соответствуют триплету,\linebreak
определяющему моноид:
\begin{itemize}
\item тип элементов моноида,
\item закон композиции моноида,
\item нейтральный элемент моноида,
\item тип, представляющий множество натуральных чисел.
\end{itemize}
\noindent Вот спецификикация настраиваемой функции дихотомического возведе-\linebreak
ния в степень:
\begin{center}
\parbox{8cm}{
{\it {\small Спецификация настраеваемой функции}}}
\end{center}
\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
generic
type ${\it Monoid\_ Element}$ is private;
with function ${\it "\ast " (a, b : Monoid\_ Element)}$ return ${\it Monoid\_ Element;}$
${\it Mooid\_ Unit :}$ in ${\it Monoid\_ Element;}$
type ${\it Exponent}$ is range <>;
function ${\it Dichotomic\_ Exponentiation (x0 : Monoid\_ Element; n0 : exponent)}$
$\qquad$ $\qquad$ return ${\it Monoid\_ Element;}$
\end{lstlisting}

Спецификация любой настраиваемой функции начинается с ключе­-\linebreak
вого слова {\bf generic}, затем следует список формальных параметров\linebreak
настройки и заголовок функции. Спецификацией называют видимую\linebreak
часть функции: она содержит все необходимые сведения для потенци­-\linebreak
ального пользователя. Способ реализации функции не имеет никакого\linebreak
значения для пользователя (несколько оптимистический взгляд, но мы\linebreak
будем его придерживаться); спецификация играет роль способа употре­-\linebreak
бления, списка указаний и противопоказаний. Формальные параметры\linebreak
настройки представлены в особом виде:
\begin{itemize}
\item Тип элементов множества, соответствующий моноиду, является\linebreak
личным типом: $\blacktriangleright$ {\bf type} {\it Monoid \_  Element} {\bf is private;} $\blacktriangleleft$. Это означа­-\linebreak
ет, что при определении функции не нужно знать точную струк-
\end{itemize}

\newpage
\begin{center}
\parbox{12cm}{
туру этих элементов. Это позволяет получить стиль программи­
рования, очень независимый от конкретных обрабатываемых объ­
ектов. В данном частном случае, например, мы вынуждены явно
задать настраиваемому блоку умножение и нейтральный элемент
(который не должен быть 1) и впоследствии ничто не помешает
использовать эту функцию, чтобы выполнить вычисления в ма­-
тричном моноиде.}
\end{center}
\begin{itemize}
\item Формальные параметры типа функции или процедуры вводятся\linebreak
ключевым словом {\bf with :}$\blacktriangleright$ {\bf with function "$\ast$"}
{\it (a,b: Monoid-Ele-\linebreak 
­ment)} {\bf return .....}$\blacktriangleleft$,что позволяет их отличить от настраивае­-\linebreak
мого объекта, которому задается спецификация. Здесь закон мо­-\linebreak
ноида обозначен операцией. Это означает, что, если мы хо­-\linebreak
тим, чтобы в определении функции возведения в степень появи­-\linebreak
лось произведение двух элементов моноида, то нужно использо­-\linebreak
вать операцию умножения. Разумеется, это не приводит к пере­-\linebreak
оценке конкретной функции, которая используется как фактиче­-\linebreak
ский параметр во время реализации и которая может быть стан­-\linebreak
дартным сложением, стандартным умножением или любой другой\linebreak
функцией, определенной пользователем.
\item Третий формальный параметр настройки - это нейтральный эле­-\linebreak
мент моноида, который должен быть явно задан при реализации:\linebreak
$\blacktriangleright$ {\it Monoid.unit}: {\bf in} {\it Monoid-Element}; $\blacktriangleleft$ - Ключевое слово in, появив­-\linebreak
шееся в этом описании, означает, слегка упрощенно, что объект\linebreak
является константой.
\item Наконец, тип показателей — это последний формальный параметр\linebreak
настройки. Этот тип должен быть целым типом машины; это\linebreak
уточнение выражено в виде: $\blacktriangleright$ {\bf type} {\it Exponet.Type} {\bf is range} < > ; $\blacktriangleleft$ .\linebreak
В момент реализации может быть использован любой целый тип,\linebreak
будет ли это целый предопределенный тип или целый тип, опреде­-\linebreak
ленный пользователем («целый тип» подразумевается в значении\linebreak
языка Ада).
\end{itemize}
Последняя часть спецификации настраиваемого блока — это описа-­\linebreak
ние самой функции, т.е. описание типа параметров и результата: заго-­\linebreak
ловок функции.

Блок компиляции состоит из спецификации и тела; однако, иногда\linebreak
спецификация интегрирована в тело; в частности, это случай проце-­\linebreak
дуры, которая играет роль главной программы во всех примерах. По­- \linebreak
сле того, как мы изучили текст спецификации настраиваемой функ­- \linebreak
ии, нам остается изучить ее тело. Тело настраиваемой функции очень\linebreak
похоже на тело функций, которые мы изучали до сих пор, и, за ис-\linebreak
\newpage

