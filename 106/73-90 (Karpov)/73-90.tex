%\documentclass{../../template/mai_book}
%\defaultfontfeatures{Mapping=tex-text}
%\setdefaultlanguage{russian}
%\begin{document}
мы говорили. На распечатке спецификации можно увидеть определения
типов, которые должны быть представлены в личной части.
Все это может показаться невероятно сложным и неэффективным.
Это действительно сложно для того, кто не имеет достаточного опыта
в программировании. Эта сложность кажется бесполезной тому, кто
никогда не пытался повторно использовать свои программы в контек­
стах, слегка отличных от контекста разработки: с опытом приходит
понимание, что эту цену необходимо платить один только раз — лишь
во время первого написания. Некоторые могут еще сослаться на то,
что теряется четкость: пишем \textit{►~Set-Coefficient (A, i, j,\dots)~◄} вместо
\textit{►~A(i,j) := \dots~◄}. И опять, все это вопрос опыта: если стиль — однород­
ный, программы читаются так же легко, как и программы, записанные
обычным способом.
В том, что касается эффективности, язык Ада предоставляет нам
некоторые средства, позволяющие влиять на скорость выполнения про­
грамм или на объем их памяти. Для этого компилятору передаются
указания, называемые прагмами. Возможно, что эти указания будут
безрезультатны (это зависит от используемого компилятора), но не со­
ставит большого труда их предусмотреть. Как это можно увидеть в
личной части, прагма Inline — которая указывает, что обращения к
подпрограммам \textit{Set-Coefficient, Coefficient-Of,\dots} нужно развернуть «в
строке», т.е. заменить обращения к этим подпрограммам разложением
их тела, — применима для всех простейших операций этой специфика­
ции.
Вторая фаза определения типа \textit{Matrix} — его реализация, очень про­
стая операция. Действительно, внутренняя структура представляет со­
бой двумерный массив, реализация примитивов — это перезапись про­
цедур и функций спецификации в терминах массивов. Вместо долгих
объяснений проще прямо представить тело пакета.

\begin{lstlisting}
typedef double value_T;
struct _matrix_T {
    int n, m;
    value_T *body;
}
typedef struct _matrix_T *matrix_T;

bool set_coefficient(matrix_T mat,
                     row_T row,
                     column_T col,
                     value_T val) {
    int mat_i = TO_COEFFICIENT(row, col);
    if (mat_i > mat->max_i) {
        // Exception Handler...
        return false;
    }
    mat->body[mat_i] = val;
    return true;
}
value_T* last_row(matrix_T mat) {
    size_t m = mat->m;
    size_t n = mat->n;
    return mat->body + (n-1)*m;
}

value_T* last_col(matrix_T mat) {
    size_t m = mat->m;
    size_t n = mat->n;
    return mat->body + m;
}

value_T* next_col(matrix_T mat, value_T *cur_col) {
    return cur_col + mat->m;
}

value_T* next_row(matrix_T mat, value_T *cur_row) {
    return cur_row + mat->n;
}

\end{lstlisting}

Можно сразу отметить простоту кода (нельзя по-настоящему го­
	ворить об алгоритме), но, тем не менее, нужно уточнить несколько
моментов. При определении типа мы представили некоторые ошибки,
которые могут появиться при использовании этого пакета. Следова­
тельно, надо выявить эти ошибки в теле имеющих к этому отношение
простейших операций. Для этого существует несколько способов:


\begin{itemize}  
\item в начале каждого модуля, в котором может появиться ошибка,
выполняют тест, позволяющий узнать, не произойдет ли ошибка.
Для этого нужно уметь предусмотреть все потенциальные ошибки
и надо уметь распознавать их предпосылки, что не всегда легко
и возможно;
\item другое решение состоит в том, чтобы использовать механизм ис­
ключений языка Ада, т.е. дать возможность модулям следовать
\newpage
обычному ходу их выполнения и предусмотреть в конце модуля
обработчик исключений, восстанавливающий предопределенные
исключения и распространяющий одно из исключений, которое
было определено для этого типа данных. Это второе решение,
заранее привлекательное из-за своей эффективности, — в неко­
торых реализациях языка Ада обработка исключений не требует
дополнительных издержек, пока не появятся исключения — имеет
то т недостаток, что не гарантирует связности данных. В случае
матриц, как они были только что реализованы, эта проблема не
требует особого внимания.
\end{itemize}

Исключение представляет собой асинхронное или непредусмотрен­
ное событие, которое может вызвать прекращение обработки информа­
ции, обеспечивающей связанность некоторых данных. Например, при
реализации динамических структур, связность которых обеспечивает­
ся указателями, очень важно, чтобы ошибки не возникали в момент,
когда связи между структурами несогласованы, что часто происходит
при модификациях. Если это возможно, нужно обязательно выявить по­
тенциальные ошибки перед их появлением, и следовательно, применить
первый метод.
Вновь эти проблемы возникают потому, что от пользователя хотят
скрыть истинное представление обрабатываемых объектов, при этом
маскирование информации доходит до утаивания внутренних ошибок!
Итак, находим обработчики исключений в реализации двух эле­
ментарных операций Set-Coefficient и Coefficient.Of: предопределенное
исключение Constraint-Error, возбуждаемое в случае ошибки выхода
индекса матрицы за его пределы, устраняется и далее распростра­
няется исключение Index-Out-Of-Bounds. Выполнение четырех неболь­
ших примитивов, позволяющих узнать границы матрицы, не может
вызвать ошибку, следовательно, там не должно быть никакой обра­
ботки ошибки. Мы уже встречали атрибуты, действующие на масси­
вах, в разделе 4.1, и в этих последних функциях снова находим атри­
буты First и Last, это показывает, каким образом данные атрибуты
применяются в случае многомерного массива, например, в ► re tu rn
Of-The-Matrix.The.Coefficient’First (1), < параметр атрибута First ука­
зывает номер размерности, к которой применяется First.

\begin{mynotice}
Хотя только что изученные операции на матрицах
являются, действительно, единственными элементарными опера­
циями, может случиться, что в эту спецификацию добавят опе­
рации, которые очень часто используются. Это в большинстве
\newpage
случаев очень простые операции, но которые по причинам эффек­
тивности и простоты выигрывают за счет информации о точном
представлении данных.
\end{mynotice}

\subsection{Ввод-вывод матриц}

Второй модуль обработки матриц позволит нам научиться использо­
вать один тип абстрактных данных. Для задачи, которая нас сейчас
занимает, первым необходимым нам инструментом является множе­
ство функций ввода-вывода. Такой аппарат содержит, как минимум,
процедуру чтения Get и процедуру записи Put для терминала, которых
пока достаточно.
Эти две процедуры предоставляют минимальное удобство для поль­
зователя: Put имеет параметр, позволяющий задать размер поля для
вывода элементов матрицы, которую хотят вывести; a Get имеет па­
раметр, который задает выводимое для ввода одной строки матрицы.
У этих двух параметров есть, однако, одна особенность: они имеют
значение по умолчанию. Благодаря этому, если выполняется команда
► Get (Моя-Матрица);
при отсутствии второго параметра в вызове,
программа будет использовать его значение по умолчанию, и никако­
го приглашения при чтении матрицы не появится. Зато если уточнить
► Get (Моя-Матрица,
◄ , каждое чтение одной строки будет
предваряться вопросительным знаком, позволяя пользователю знать,
где он находится. Значение по умолчанию второго параметра проце­
дуры Put есть Coefficient ’Width, результат применения предопределен­
ного атрибута Width к целому типу Coefficient: этот атрибут задает
максимальное число символов для вывода какой-либо величины типа
Coefficient.
После того как описаны средства, предлагаемые модулем, т.е. услу­
ги, которые он способен предоставить, нужно познакомиться и с услу­
гами, в которых он нуждается, чтобы реализовать все это. Эти услу­
ги появятся в качестве формальных параметров настройки и должны
быть обеспечены предыдущим пакетом. Тогда получится следующая
полная спецификация:

\begin{lstlisting}
bool set_coefficient(matrix_T mat,
                     row_T row,
                     column_T col,
                     value_T val) {
    int mat_i = TO_COEFFICIENT(row, col);
    if (mat_i > mat->max_i) {
        // Exception Handler...
        return false;
    }
    mat->body[mat_i] = val;
    return true;
}
value_T* last_row(matrix_T mat) {
    size_t m = mat->m;
    size_t n = mat->n;
    return mat->body + (n-1)*m;
}
value_T* last_col(matrix_T mat) {
    size_t m = mat->m;
    size_t n = mat->n;
    return mat->body + m;
}
value_T* next_col(matrix_T mat, value_T *cur_col) {
    return cur_col + mat->m;
}
value_T* next_row(matrix_T mat, value_T *cur_row) {
    return cur_row + mat->n;
}
bool put(matrix_T mat, size_t row, size_t col, value_T val) {
    int mat_i = TO_COEFFICIENT(row, col);
    if (mat_i > mat->max_i) {
        // ERROR HANDLER
        return false;
    }
    mat->body[mat_i] = val;
    return true;
}
value_T get(matrix_T mat, size_t row, size_t col) {
    int mat_i = TO_COEFFICIENT(row, col);
    if (mat_i > mat->max_i) {
        // ERROR HANDLER
        return mat->body[0];
    }
    return mat->body[mat_i];
}
\end{lstlisting}
«Это не упрощает дела!» — сразу скажет читатель. Еще раз по­
вторим сказанное: только опыт позволит судить об этом, и во время
заключительного построения будет видно, что описанный способ дей­
ствия имеет, скорее, тенденцию к упрощению архитектуры программы.
Однако сделаем несколько уточнений:
\begin{itemize}
\item процедуры ввода-вывода нуждаются в информации о типе Ma­
trix, и поскольку он определен как личный тип, то здесь он тоже
должен быть объявлен личным;
\item для считывания и записи должны быть известны границы обра­
батываемых матриц, так же как и природа элементов, ибо, в ко­
нечном счете, именно над ними производятся действия; это объ­
ясняет присутствие первых четырех параметров настройки;
\item наконец, нужно ввести все примитивы, определенные в предыду­
щем разделе.
\end{itemize}

Данная спецификация, которая кажется довольно громоздкой, полна
и очень мало связана с другими модулями. Это означает, что исполь­
зовать указанный модуль весьма просто и что модификации описания
типа абстрактных данных Matrix или других тяготеющих к нему мо­
дулей мало скажутся на этом особом модуле.

Приводим реализацию описанной процедуры, которая пока не пред­
ставляет никакой особой трудности.
\begin{lstlisting}
bool get_all(matrix_T mat) {
	for (size_t i = 0; i < mat->max_i; ++i)
		put(mat, m, n, get_val());
	return true;
}
\end{lstlisting}

Отметим способ, с помощью которого здесь используются примити­
вы работы с матрицами, а также ассоциацию по именам фактических
параметров самих этих примитивов. Сделаем последнее замечание, ка­
сающееся имени рассмотренного пакета: что хоть и следует избегать
этого в общем случае, в данном идентификаторе используют аббреви­
атуру 10 — общепринятый акроним, означающий Input/Output, как,
например, в TextJO.

\subsection{Описание генератора биекций}

Перейдем теперь к вычислению определителя матрицы, пользуясь фор­
мулой определения 7 в начале раздела 4 и предполагая, что мы обладаем

\newpage

генератором биекций между двумя целыми интервалами. Реализация
самого генератора отнесена в конец главы, чтобы не отвлекаться от
нашей первоначальной задачи.
Даже если на время не стоит вопрос о деталях построения генера­
тора перестановок, нужно, по крайней мере, знать способ его примене­
ния и инструменты, которые он предлагает, — короче, его описание.
Первый шаг на этом пути — выбор структуры данных, допускающей
представление одной перестановки. Существует несколько стандарт­
ных обозначений для перестановок: в форме произведения циклов, в
форме таблицы, представляющей граф перестановки, и т.п. Например,
перестановка $\delta$ интервала [1,5], определенная равенствами $\delta(1)~=~2,
\delta(2) = 4, \delta(3) = 5, \delta(4) = 1 и \delta(5) = 3$, представляется в форме про­
изведения циклов как: $\delta = ( 1 2 4 )( 3 5 )$, а в форме таблицы, как
$\delta = \begin{pmatrix} 1 & 2 & 3 & 4 & 5 \\ 2 & 4 & 5 & 1 & 3 \end{pmatrix} $
Этот второй способ представления дает более
непосредственный взгляд на перестановку (по крайней мере, на нашем
уровне) и больше подходит для алгоритмической обработки, чем запись
через произведение циклов. Обычно это представление упрощают, за­
писывая только вторую строку таблицы и подразумевая первую. По
этому соглашению перестановка сг предыдущего примера представля­
ется пятеркой (2,4,5,1,3).
Выбрав структуру данных, остается найти процедуру перебора
множества перестановок. Канонический метод просмотра конечного
множества состоит в полном его упорядочении от минимального (со­
ответственно, максимального) элемента для этого порядка и функции
следования (соответственно, предшествования). Вот описание настра­
иваемого пакета, определяющего такой генератор.

\newpage
\begin{lstlisting}

typedef enum {
\\ ...
} source;

typedef enum {
\\ ...
} target;

typedef enum {
\\ ...
} signature;

typedef target bijetion[RANGE];
bijection min_bij(source s_min,
				  source s_max, 
				  target t_min,
				  target t_max);
inline void sucsessor_of(bijection bij, signature sig);

\end{lstlisting}
% TODO: code

Э тот модуль определяет, кале указывает его имя, генератор биек­
ций, а не перестановок. Разница между двумя понятиями очень незна­
чительна, но рассмотрение биекций допускает, как увидим во время
реализации, более простой подход. Заглавные параметры этого моду­
ля суть типы (целые) интервалов от начальной точки до конечной, на
которых действует биекция. В нашем случае эти интервалы будут ин­
тервалами изменения индексов строки и столбца обрабатываемой ма­
трицы. С помощью этих двух типов целых программа выдаст нам так­
же два типа: один, позволяющий представить перестановки в форме
таблицы, другой — тип-сигнатуру. Затем, основывая принцип перечи­
сления биекций на некотором порядке, используют функцию, опреде­
ляющую наименьшую биекцию относительно этого порядка, и проце­
дуру вычисления последующей за данной биекции, а также ее сигна­
туру. Когда обрабатывают перестановки, наименьшей перестановкой
в выбранном порядке является тождественная, как это увидим ниже,
чья сигнатура равна 1; это указывает инициализацию, которую должна
осуществить программа вычисления детерминанта. Тогда можно легко
перебрать множество биекций между двумя интервалами целых чисел.
Возможны две ошибки. Bijection.Overflow выполняется, когда пытают­
ся вычислить биекцию, которая следует за самой большой в выбранном
порядке; и вторая — если пытаются вычислить минимальную биекцию
между двумя множествами с разными мощностями.

\subsection{Вычисление определителя}
Чтобы достичь нашей цели — вычисление определителя — остается
только объединить множество небольших кусков, которые мы постро­
или до сих пор: матричный тип, ввод-вывод, генератор перестановок и
написать, собственно, подпрограмму вычисления.
Матрицы, которые мы будем обрабатывать, — квадратные, с целы­
ми элементами, и мы будем предполагать, что индексы строк и столб­
цов имеют то т же тип. Когда этот выбор сделан, нужно конкрети­
зировать оба настраиваемых пакета по оперированию с матрицами и

вступить в диалог с пользователем. Именно это делает первый модуль
программы, представленный здесь:

% TODO: code
\begin{lstlisting}
typedef unsigned int index;
typedef long long int coefficient;
void compute_determ

while (true){
	size_t size;
	scanf("%d", &size);
	matrix mat;
	get_all(mat);
}
\end{lstlisting}

Начинают, таким образом, с построения матричного типа и его
примитивов; тогда можно конкретизировать пакет ввода-вывода ма-
\newpage
триц (эта последняя конкретизация довольно громоздка для записи)
Конкретизация пакета Integer.IO позволяет считывать размер матри­
цы, подлежащей обработке. Это чтение размера находится в основное
цикле, который содержит также блок, в котором объявляют матри­
цу, считывают ее элементы и проводят вычисление определителя. Ис­
ключение Data.Error, вставленное в обработчик в конце этой основной
процедуры, позволяет изящно остановить программу, задавая нулевук
размерность матрицы (так как тип Index является производным от ти­
па Positive).
Функция, осуществляющая непосредственное вычисление определи­
теля, для большей ясности отделена от основной процедуры. Вот запись
этой функции, которая ничем особенным не отличается, это лишь пе­
реписанное определение 7, данное в начале раздела 4:

% TODO: code

Заметим, однако, что для облегчения записи для пакета
Matrix-Handler был добавлен спецификатор use. Кроме того, во вре-
\newpage

мя вычисления нужно осуществлять преобразование типа ► Term :=
Coefficient (s); 4 , чтобы связать элементы и сигнатуру перестановки.

\subsection{Вычисление определителя: несколько цифр}

Прежде чем продемонстрировать несколько шагов выполнения, и даже
прежде чем выполнять что бы то ни было, нужно оценить сложность
процедуры, которую мы только что описали. Дорогостоящим элемен­
том в программе, которую мы только что изучили, является функция
Determinant, а точнее, самый внешний цикл, который находится в этой
функции (тот, который повторяется для всех перестановок).
Что видно в этом цикле? Во-первых, вложенный цикл, выполняемый
n раз, где n — размерность обрабатываемой матрицы; затем суммиро­
вание, далее вычисление последователя какой-либо перестановки, что
требует времени (по максимуму), пропорционального n. Внешний цикл,
будучи выполненным $n!$ раз, дает сложность вычисления определителя
порядка $О(n \cdot n!)$. Первые примеры определителей суть определители
Майе (см. гл. III). Это определители матриц X , определенных для про­
стого р через:

\begin{center}
\( X_{i,j} = \left\lfloor \frac{ij}{p} \right\rfloor - \left\lfloor \frac{(i-1)j}{p} \right\rfloor \)
\end{center}

где i и j находятся в интервале [3, (р — 1)/2]. Абсолютная величина
определителя Майе для простого р обозначена h*(р). Эти определители

\begin{wraptable}{l}{10cm}
\begin{tabular}{|c|c|c|c|}
\hline
Значение p & Размерность & h * (p) & Время (сек) \\ \hline
11 & 3 & 1 & 0.00 \\
13 & 4 & 1 & 0.00 \\
17 & 6 & 1 & 0.72 \\
19 & 7 & 1 & 5.65 \\
23 & 9 & 3 & 501.58 \\ \hline
\end{tabular}
\caption{Определители Майе}
\end{wraptable} 

Эти определители
имеют очень тесную связь с
большой теоремой Фер­ма;
точнее, если р { Л*(р),
то уравнение х р + j f = z p
не имеет целых нетривиаль­
ных решений. Основываясь
на этих примерах, можно
констатировать, что боль-
шая теорема Ферма справедлива для простых р, заключенных между
11 и 23. С другой стороны можно также констатировать, что время
вычисления определителя размера 9 x 9 немного больше 8 минут (то,
что величины даны с двумя знаками после запятой, означает только,
что точность составляет 0,01 сек.) Чтобы дополнить измерения време­
ни счета, которые мы только что проделали, и, таким образом, оценить
коэффициент прогрессии времени счета, мы также вычислили опреде­
лители для порядков, которые не фигурируют в предыдущей таблице.

\newpage
\begin{wraptable}{l}{8cm}
\begin{tabular}{|c|c|}
\hline
Размерность определителя & Время (сек) \\ \hline
5 & 0.11 \\
8 & 52.79 \\
10 & 5666.83 \\ \hline
\end{tabular}
\end{wraptable}
Установлено, что вычисление опреде­
лителя размера 10 х 10, независимо
от его значения, требует около 1 ча­
са 30 минут; для определителя 11 по­
рядка нужно примерно один день для
определителя 12 порядка потребуется
около 10 дней... Таким образом, экспериментально установлено, что
когда переходят от определителя порядка п к определителю порядка
п + 1, время счета приблизительно умножается на (п + 1) 2 /п , что под­
тверждает теоретическую оценку сложности: О(п • п!).
Конечно, можно упрекнуть программирование в его неэффектив­
ности — маскировка информации, вынуждающая обращаться к под­
программам там, где обычно присутствует только ссылка на элементы
массива, и широкое использование настраиваемых модулей. По этой
причине приведены две другие таблицы 4: они показывают времена
вычислений, полученные при реализации, одна — без применения на­
страиваемых модулей, а другая — без маскировки информации.

\begin{multicols}{2}
%\begin{wraptable}{l}{5cm}
\begin{tabular}{|p{2.75cm}|p{2.75cm}|}
\hline
Размерность определителя & Время  (сек) \\ \hline
5 & 0.11 \\
6 & 0.77 \\
7 & 5.88 \\
8 & 51.51 \\
9 & 499.93 \\
10 & 5404.67 \\ \hline
\end{tabular}
%\end{wraptable}

\columnbreak

\begin{tabular}{|p{2.75cm}|p{2.75cm}|}
\hline
Размерность определителя & Время  (сек) \\ \hline
5 & 0.11 \\
6 & 0.77 \\
7 & 5.88 \\
8 & 51.51 \\
9 & 499.93 \\
10 & 5404.67 \\ \hline
\end{tabular}
\end{multicols}

Первая из этих двух таблиц соответствует выполнению програм­
мы вычисления определителя по методу, описанному в этой главе, но
посредством реализации без применения настраиваемых блоков, кроме
стандартных пакетов ввода-вывода. Из этой таблицы видно, что улуч­
шение времени вычислений, полученное данным методом, невелико —
улучшение касается, очевидно, только константы, на которую умножа­
ется п • п! в оценке сложности — но не является пренебрежимо малым
по отношению к полученному времени вычисления. Во всяком случае
не меняется скорость возрастания времени счета.
Вторая таблица касается измерения времени счета определителей
с помощью вполне классической реализации, которая не содержит на­
страиваемых блоков и в которой представление матриц не замаскиро­
вано; в функции вычисления определителя появляются в явной форме
такие выражения, как ► Term := Term * Of-The-Matnx (i, Sigma (i)); <.

\newpage

Здесь улучшение гораздо больше (примерно на множитель 1, б по отно­
шению ко всему первому методу), но ясно, что если меняется предста­
вление матриц, нужно полностью переписывать функцию вычисления
определителя. Таким образом, краткое сравнение издержек показыва­
ет, что часто выгоднее купить машину, которая в два раза быстрее по
сравнению с имеющейся, чем написать программу, которая действует
в два раза быстрее по сравнению с первоначальной. Кроме того, и это
здесь убийственный довод, использованный метод очень плохой (так
называемый метод «Барейса» — это эффективный метод вычисления
определителей в целых числах).
Ну, а каково время счета определителя размера 20 х 20 этим наивным
методом?

\subsection{Перестановки конечного множества}

В пункте 4.4 мы выбрали представление перестановок, которое мог­
ло бы, ко всему прочему, подойти для представления отображений од­
ного множества в другое: таблицу, содержащую элементы множества
образов (данного отображения), индексированные элементами исход­
ного множества. Это представление в форме таблицы напоминает не­
которыми аспектами понятие слова (в смысле элемента свободного мо­
ноида, см. пункт 3.3). Например, множество перестановок интервала
[1,5] может быть идентифицировано с множеством слов, образованных
из пяти различных букв и построенных в алфавите {1,2,3,4,5}. Тогда в
голову естественно приходит мысль наделить множество перестановок
индуцированным порядком, который существует для слов и который
называется лексикографическим.

\begin{determ}[лексикографический порядок на декартовом про­
изведении двух множеств]
Пусть ( Е,$\leqslant$ е ) и (F,$\leqslant$ р ) — два линейно упорядоченных множества.
Лексикографический порядок на Е х F определяется для (a,b), (a', b') $\in$
Е х F следующим образом:

$$ (a,b)\leqslant _{E \times F} (a`,b`) \Longleftrightarrow [a=a` \text{ и } b \leqslant _Fb` \text{ или } a \leqslant _Ea` ] $$
\end{determ}

Определенное таким образом отношение дает линейное упорядочение
на Е х F, которое может удобно обобщаться по индукции на любое
декартово произведение линейно упорядоченных множеств.

\begin{mynotice}
Существуют другие способы, позволяющие опре­
делить линейный порядок на декартовом произведении данных
\newpage
множеств. Один из них, в частности, упорядочивает перестановки,
чередуя их сигнатуры, чего не делает лексикографический порядок.
Заинтересованный читатель может обратиться к упражнениям
17, 23 и 24 в конце главы.
\end{mynotice}

Рассмотрим перестановку $\sigma$ множества $E$, представленную пока таблицей
из двух строк, и отыщем другую перестановку $\sigma'$, непосредственно
превосходящую $\sigma$ в лексикографическом порядке, индуцированном на второй строке таблицы.

$$
\sigma = \begin{pmatrix}
a_1 & a_2 & \cdots & a_{n-1} & a_n \\
b_1 & b_2 & \cdots & b_{n-1} & b_n \\
\end{pmatrix}
\text{и}\: \sigma' = \begin{pmatrix}
a_1 & a_2 & \cdots & a_{n-1} & a_n \\
b'_1 & b'_2 & \cdots & b'_{n-1} & b'_n \\
\end{pmatrix}
$$

\noindent выражения, в которых элементы $a_i$ и $b_i$ из $E$ удовлетворяют для всякого
 $i \in [1, n - 1]$ условию $a_i < a_{i+1}$.

Поскольку элементы $a_i$ расположены в порядке возрастания, они не
несут никакой полезной информации и могут быть подразумеваемы,
что приводит нас к представлению перестановок в форме $n$-ок.
Множество, которое мы пытаемся пронумеровать, есть, следовательно,
множество всех $n$-ок различных элементов из $E$ (мощности $n$). Предыдущее
определение лексикографического порядка без труда распространяется
на множество $n$-ок различных элементов из $E$, и задача теперь становится
такой: считая данной $n$-ку $b = (b_1,b_2, \cdots ,b_n)$ элементов из $E$, найти следующую
за ней $n$-ку $b' = (b'_1, b'_2,..., b'_n)$, удовлетворяющую условиям:\newline

(\textit{i})$\left\{ b_1,b_2,\cdots, b_n \right\} =\left\{ b'_1,b'_2, \cdots, b'_n\right\}$,

(\textit{ii})$\b = (b_1, b_2, \cdots, b_n) <_lex (b'_1, b'_2, \cdots, b'_n) = b'$,

(\textit{iii})$c > b \Rightarrow c \geq b'$, что можно также записатьдля линейной
упорядоченности через $(b,\: b') = \emptyset$.\newline

Прежде чем вычислять последователя какой-либо такой $n$-ки
 в общем случае, можно поинтересоваться существованием этого последователя.

\begin{property}
\hspace*{15pt}Пусть $E$ — линейно упорядоченное множество. Тогда единственная строго убывающая
(соответственно, возрастающая) последовательность, образованная из всех элементов $E$,
представляет наибольшую (соответственно, наименьшую) перестановку $E$ и не имеет,
таким образом, последователя (соответственно, предшественника).
\end{property}

Это очень простое свойство позволяет применить рекурсию для построения следующего
элемента для какой-либо $n$-ки в общем случае.
\newpage

\noindent Действительно, имея определеgние лексикографического порядка на $E^n$ 
для вычисления последователя какого-либо элемента нужно попытаться 
вычислить последователя в $E^{n-1}$ для $(n - 1)$-ки, образованной  
последними составляющими первоначальной $n$-ки; и этот процесс редукции 
может повторяться до тех пор, пока не достигнем набора из $(n - k)$ 
элементов, который не имеет последователя. Предыдущее свойство  
позволит нам охарактеризовать такой набор из $(n - k)$ элементов: он  
образован убывающей последовательностью элементов. Таким образом,  
первый этап в вычислении последователя для $n$-ки элементов из $E$ есть  
поиск финальной убывающей максимальной части этой $n$-ки; затем  
нужно переупорядочить элементы, и следующее свойство указывает, каким 
образом.

\begin{property}[последователя для $n$-ки различных элементов]

\hspace*{0.55cm}Пусть $E$ — множество из $n$ элементов и пусть $b = (b_1,b_2,\cdots ,b_n)$. 
Предположим, что существует такое $l \geq 1$, что для всякого $i$ из $(l, n — 1]$ 
имеют место соотношения $b_i > b_{i+1}$ и $b_l < b_{l+1}$; тогда последователь 
$n$-ки в множестве $n$-ок различных элементов из $E$ определяется как
$$
(b_1, b_2,\cdots,b_{l-1},\quad b_k,\quad b_n,b_{n-1},\cdots,b_{k+1},\quad b_l,\quad b_{k-1},\cdots,b_{l+1}),
$$
где $k$ — наибольший индекс, превосходящий $l$ и такой, что $b_k > b_l$. 
Другими словами, чтобы вычислить следующий за $b$ элемент,  
достаточно обратить финальную убывающую часть $b$, затем поменять элемент, 
предшествовавший этой части, с его последователем в этой части. 
\end{property}
\begin{myproof}
\begin{itemize}
\item Прежде всего, должно быть ясно, что если индекс $l$ не существует, 
то мы будем находиться в ситуации, выраженной в свойстве 9: $n$-ка 
не имеет последователя. 
\item Обозначим $b'$ новую $n$-ку, определяемую этим свойством. Тогда 
ясно, что $b' >_{lex} b$. Действительно, эти две $n$-ки совпадают на их 
$(l—1)$ элементах, и их элементы с индексом $l$ удовлетворяют условию 
$b'_l = b_k > b_l$. 
\item Остается показать, что $b$' является наименьшей мажорантой $b$ в 
лексикографическом порядке; а это можно сделать, показав, что  
открытый интервал $(b,b')$ пуст (в силу линейного лексикографическо- 
го порядка). Предположим, что существует такое $c$, что $b < c < b'$:
\end{itemize}
%тут должна быть таблица

Заметим прежде всего, как это подсказывает схема, что части  
слева от вертикальной черты равны во всех строках, следовательно, 
нет нужды учитывать их в дальнейшем. Рассмотрим только  
элементы каждой перестановки, чьи индексы превосходят или равны $l$, 
Следующее свойство, которое мы не будем повторять по ходу  
доказательства, является основным: \textit{части трех перестановок,  
расположенные справа от вертикальной черты, образованы из одних 
и тех же элементов, различных между собой.}\newline 
Теперь мы покажем, что если предположить, что $b < c < b',$ 
то $b_l < c_l < b'_l$. Действительно, предположим $b_l = c_l$;  
поскольку $b < c$, то из этого следует, что в лексикографическом порядке 
$b_{l+1...n} < c_{l+1...n}$, но часть $b_{l+1...n}$, будучи строго убывающей,  
максимальна в лексикографическом порядке, а так как она образована 
из тех же элементов, что и часть $c_l+1...n$, то не может быть меньше 
последней. Следовательно, $b_l \neq c_l$ и, значит, $b_l < c_l$.  
Рассматривая части $c_{l+1...n}$ и $b'_{l+1...n}$, где последняя является минимальной в 
лексикографическом порядке, аналогичным образом получаем, что 
$c_l < b'_l$. Итак, $b'_l = b_k$, и выбор $b_k$ делает невозможным найти среди 
элементов $b_{l+1},\: \cdots,\: b_n$ элемент $c_l$, заключенный строго между $b_l$ и 
$b'_l$, что противоречит первоначальному предположению  
(существует $c$, удовлетворяющее $b < c < b'$). Значит, $b'$ есть последователь 
для $b$. 
\end{myproof}

\begin{mynotice}
Предыдущее свойство позволит нам эффективно 
вычислять последователя $n$-ки различных элементов из  
множества $E$ мощности $n$. 
Кроме того, как будет видно из записи алгоритма — который 
уже должен просматриваться из этого рассуждения — нетрудно 
вычислить отношение между сигнатурами исходной $n$-ки и новой. 
\end{mynotice}

\begin{center}
\parbox{11cm}
{
\hspace{0.4cm} Наконец,  перестановка  —  первоначальный  объект  нашего
изучения — полностью исчезла, а все эти результаты могут при­
меняться в более общих рамках:  для нумерации биекций конеч­
ного множества.
}
\end{center}

Теперь  есть  возможность  разработать  алгоритм,  который  реали­
зует результаты предыдущего свойства. Перестановка будет предста­
влена таблицей элементов из \textit{Е},
 индексированной целыми числами, за­
ключенными между \textit{р} и \textit{q}.
 Перестановка, или скорее таблица, которая ее 
представляет, будет называться \textit{Sigma}.
  Дальнейшие построения  уточ­
няют преобразование \textit{Sigma}
 в ее  последователя в лексикографическом 
порядке.  Эта конструкция осуществляется  в три этапа и очень точно 
следует изложению предыдущего свойства.

\noindent \textbf{\large{Первая фаза}}

\begin{wraptable}{}{0.4\textwidth}
\begin{tabular}{|l}
\textit{\textbf{\begin{tabular}[c]{@{}l@{}}
Length = 1;\\ 
for(int i = q - 1; i \textgreater p; i--)\\ 
\{\\ 
\hspace{0.2cm} if(Sigma(i) \textgreater Sigma(i+1)) \\
\hspace{0.2cm} \{Length++;\}\\ 
\hspace{0.2cm} else First\_Index = i;\\ 
\}\\ 
if(Length == q - p + 1) \\ 
\{printf("No\_Successor");\}
\end{tabular}}}\\ 
\end{tabular}
\end{wraptable}
Первое, что нужно сделать, — это 
определить  конечный  максимальный 
убывающий  сегмент.  Соответствую­
щая  часть  алгоритма  очень  проста 
(смотри рядом). В этом фрагменте \textit{р} и \textit{q}
 суть границы таблицы \textit{Sigma}.
 
Цикл,  который  здесь  видим,  по­
зволяет определить \textit{First-Index}, нача­
ло финальной убывающей максималь­
ной  подпоследовательности  (величи­ну \textit{l}
  свойства  10).  Кроме того, пере­
менная \textit{Length}
сегмента,  что  позволяет  определить,  не  максимальной  ли  он  длины 
(что, как это уже было видно, означает отсутствие у перестановки по­
следователя)
 выражает длину этого сегмента,  что  позволяет  определить,  не  максимальной  ли  он  длины 
(что, как это уже было видно, означает отсутствие у перестановки по­
следователя).

\noindent \textbf{\large{Вторая фаза}}

Затем  нужно  обратить  конечный  сегмент,  определенный  в  пер­
вой фазе; алгоритм, который осуществляет эту операцию, тоже очень 
прост.

\begin{tabular}{|l}
\textit{\begin{tabular}[c]{@{}l@{}}
Ascending\_Index = First\_Index + 1\\ 
Descending\_Index = q\\ 
\textbf{while}(Ascending\_Index $<$ Descending\_Index)\\ 
\{\\ 
\hspace{0.2cm} tmp\_value $=$ Sigma(Ascending\_Index) \\
\hspace{0.2cm} Sigma(Ascending\_Index) $=$ Sigma(Descending\_Index)\\
\hspace{0.2cm} Sigma(Descending\_Index) $=$ tmp\_value \\
\hspace{0.2cm} Ascending\_Index $=$ Ascending\_Index $+$ 1\\ 
\hspace{0.2cm} Descending\_Index $=$ Descending\_Index $-$ 1\\ 
\}\\
\end{tabular}}\\
\end{tabular}

Нужно заметить, что это последнее преобразование перестановки \textit{Sigma}
 сделано через транспозиции, и поэтому отсюда можно вывести 
отношение между сигнатурами начальной перестановки и полученной 
из  нее  (число  осуществленных  перемен \textit{s}  =  \textit{Length}/2,
  и,  значит, это отношение равно $(—1)^{s})$.
   
\noindent \textbf{\large{Третья фаза}}

\noindent \begin{wraptable}{i}{0.55\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\textbf{\begin{tabular}[c]{@{}l@{}}
for(int i = First\_Index; i \textless q; i++)\\ 
\{\\ 
\hspace{0.3cm}if(Sigma(i) \textgreater Sigma(First\_Index)\\ 
\hspace{0.3cm}\{\\ 
\hspace{0.6cm}swap(Sigma(i),Sigma(First\_Index))\\ 
\hspace{0.3cm}\}\\ 
\}\end{tabular}}} \\ \hline
\end{tabular}
\end{wraptable}

Наконец, нужно отыскать в
только  что  обращенной  части 
таблицы  наименьший  элемент, 
превосходящий  элемент  с  ин­
дексом \textit{First-Index}
 (т.е. элемент 
с индексом \textit{l}
 из свойства 10), и
поменять их местами, что добавляет еще одну дополнительную транс­
позицию к преобразованию.

Полный алгоритм генерации биекций  формируется очень просто, 
достаточно склеить все фрагменты, которые мы только что изучили. 
Целиком это будет видно в следующем разделе, посвященном реализа­
ции всего этого.

\subsection{Настраиваемый модуль генератора биекций}
\noindent Мы закончим эту главу реализацией алгоритма перечисления биекций 
и, таким образом, построим тело цикла, спецификация которого была 
дана в  разделе 4.4. Как это было видно в предыдущем рассуждении, 
названные биекции действуют на целых интервалах, что вовсе не ли­
шает решение общности; всякая биекция между двумя конечными мно­
жествами может трактоваться как целая биекция.
Напомним все-таки, что этот пакет, кроме типа биекций между дву­
мя целыми интервалами и процедуры вычисления последующего эле­
мента, дает также наименьшую биекцию в лексикографическом поряд­
ке  (которая является и единственной  строго возрастающей  биекцией 
между двумя рассматриваемыми интервалами). Кроме того, процеду­ра \textit{Successor}
 имеет два параметра: исходная биекция и ее сигнатура, и 
эта процедура вычисляет следующую биекцию и ее сигнатуру.

%\end{document}