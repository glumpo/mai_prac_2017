
\par Первая функция {\it Multiply-M-By} позволяет умножать произвольный
одночлен на параметр {\it М} функции {\it Multiply}, вторая функция — 
конкретизация на этом преобразовании данного итеративного цикла —
дает искомый результат. Следует заметить, что в этом контексте не­
возможно выполнить конкретизацию вне функции {\it Multiply}, потому что
она зависит от одного из аргументов этой функции. Это цена, которую
приходится платить за модулярность множества. Кроме того, реали­
зация функции {\it Multiply-M-By} существенно использует целостность ис­
ходного кольца; без этого предположения было бы необходимо отдельно
рассматривать случай, когда произведение двух коэффициентов равно
нулю, что значительно усложнило бы алгоритм.
\par Имея эту элементарную функцию перемножения, можно теперь ре­
ализовать умножение многочленов в общем случае. Но, учитывая слож­
ность алгоритма сложения, рассмотренного ранее, представляется ло­
гичным сделать так, чтобы в процессе последовательных сложений
структурное разбиение было бы как можно более протяженным. Рас­
смотрение умножения двух многочленов, представленных в упражне­
нии 29, показывает, что многочлен {\it Р} , по которому разлагают про­
изведение в ряд последовательных умножений, должен пробегаться в
порядке возрастания степеней одночленов, тогда как представление в
виде списка облегчает скорее противоположное направление чтения.
Так, максимизируя структурное разделение, минимизируют сложность
прохода списков, представляющих отдельные многочлены-слагаемые.
Надо заметить, что нижеприведенная функция будет встроена в тело
пакета управления многочленами и что, как следствие, она может ис­
пользовать внутреннюю структуру многочленов.

\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
function Multiply (P : Polynomial; Q : Polynomial)
$\qquad$ $\quad$ return Polynomial is
$\quad$ RP : Polynomial := Reverse (P); R : Polynomial := Zero;
begin
$\quad$ while not Is_Null (RP) loop
$\qquad$ R := R + Multiply (Head (RP).The_Monomial, Q);
$\qquad$ RP := Tail (RP);
$\quad$ end loop;
$\quad$ return R;
end Multiply
\end{lstlisting}

\par Можно дать оценку сложности этого алгоритма умножения двух
многочленов в нескольких частных случаях, рассматривал процесс ум-
\newpage

\begin{wrapfigure}{l}{0.5\textwidth} %$a_{4}X^{\alpha _4}Q\\
%\hbox to 3 cm{\qquad\leaders\hbox{$\cdot$}\hfill }$
\hspace*{140.pt}\underline{$a_{1}X^{\alpha _1}Q$}\newline
\hspace*{100.pt}\underline{$a_{2}X^{\alpha _2}Q$}\\
\hspace*{80.pt}\hbox to 4 cm{\qquad\leaders\hbox{$\cdot$}\hfill }\newline
\hspace*{100.pt}\underline{$(a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q$}\newline
\hspace*{60.pt}\underline{$a_{3}X^{\alpha _3}Q$}\\
\hspace*{40.pt}\hbox to 5 cm{\qquad\leaders\hbox{$\cdot$}\hfill } \newline
\hspace*{60.pt}\underline{$(a_{3}X^{\alpha _3} + a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q$} \newline
\hspace*{20.pt}\underline{$a_{4}X^{\alpha _4}Q$}\\
\hbox to 7 cm{\qquad\leaders\hbox{$\cdot$}\hfill }
\hspace*{20.pt}\underline{$(a_{4}X^{\alpha _4} + a_{3}X^{\alpha _3} + a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q$}\newline

\end{wrapfigure}


\noindent
ножения на приведенной сле­ва схеме. В этих примерах так называемый левый много­член является тем, по кото­
рому осуществляется разложе­ние в произведение двух мно­гочленов. Первый случай со­ответствует умножению Р на Q, когда последний многочлен, является плотным, т.е. образо­ван из мономов с последова­тельно идущими друг за другом степенями. Начинают со сложения двух
мономов $a_{1}X^{\alpha _1}Q$ и $a_{2}X^{\alpha _2}Q$; для этого нужно лишь пробежать список,
представляющий второй моном, и сложение завершается присоедине­
нием конца первого монома. Затем это повторяется, когда добавляют
многочлен $a_{3}X^{\alpha _3}Q$  к только что полученному результату; при этом пробегают только этот последний моном, и т.д. Следовательно, каждое
сложение имеет сложность, заключенную между $\#Q$ и $2\#Q$. Так как это
повторяется для всех мономов из $Р$, в целом для алгоритма умножения
получается сложность, пропорциональная $\#P \times \#Q$.
\par Можно рассмотреть произведение левого многочлена $ P =\sum^{p-1}_{i=0}a_{i}X^i$ на правый $Q =\sum^{q-1}_{j=0}b_{j}X^{j} $, которое даст нам максимальную сложность
произведения произвольного многочлена на плотный многочлен. Здесь
на каждой итерации (или промежуточном сложении) получают слож­
ность пробега $2q — 1$; с учетом повторений для всех мономов из $Р$ это дает общую сложность пробега $(р— 1)(2q — 1)$. Пример, дающий нижнюю
границу сложности для произведения этого типа, получается вычисле­
нием $RQ$ , где $R =\sum^{r-1}_{k=0}c_{k}X^{kq}$. На каждой итерации сложность пробега
равна $q$, что дает общую сложность пробега $(r - 1)q$.
\par В первом примере для произведения $PQ$, если бы разлагать мно­гочлен $P$ по убывающим степеням, то последовательно получали бы: $q + (q - 1)$, \linebreak $(q + 1) + (q - 1), ..., (q + p - 2) + (q - 1)$ и в целом $(p - 1)(2q - 1) + (p - 2)(p - 1)/2 $. Для второго примера последовательные пробеги
оценивались бы $q, 2q, 3q, ..., (r - 1)q$, и в целом $r(r - 1)q/2$.
\par Другой типичный случай: многочлен, стоящий в произведении спра­ва, является разреженным, а тот, который слева, — плотным (пример
произведения $QR$). Принцип пробега, описанный в схеме, остается в
силе, с той лишь разницей, что высота промежуточного результата
удваивается на каждой итерации, что дает сложность пробега, равную
$r + (r - 1) + r + (2r - 2) +$ \linebreak $r + (3r - 3) + ... + r + (q - 1)(r - 1)$, т.е. $(q - 1)r + q(q - 1)(r - 1)/2$. Разложение левого многочлена $Q$ по убыванию степеней даёт точно такой же результат.
\newline
\noindent Оценим сложность алгоритма: в дальнейшем будем пренебрегать умножениями на целые константы и будем рассматривать только операции
над коэффициентами формальных рядов. Очевидно, что для вычисле­ния $i$-го терма ряда $\mathcal{B}$ необходимо $2i$ умножений ($i$ умножений скалярных) и $i-1$ сложений. Знание $i-1$ членов этого ряда и $i$ членов
формального ряда А также необходимы, что дает сложность: $i(i+1)$
умножений и $i(i-1)$ сложений в базовом кольце.

\textbf{c.} При применении к многочленам изученных в двух предыдущих
задачах принципов некоторое упрощение может быть достигнуто для
многочленов с конечным числом членов. Имеется также возможность
реализовать эти алгоритмы для многочленов, представимых массивами
(если иметь дело с плотными или не очень разряженными многочленами) . Обсудим теперь модификации алгоритма возведения в степень в
случае действий с многочленами, с учетом того, что алгоритм возведе­ния многочленов в квадрат был изучен в одном из предыдущих упражнений. В сумме для $i$-го коэффициента, встречающейся при вычислении
многочлена $\mathcal{P}^n$, число слагаемых, которые находятся под знаком суммы, зависит не только от $n$, но и от степени многочлена, над которым
производится действие. Точнее, при $i > 0$:
$$b_{i}=\frac{1}{a_{0}i}\times\sum\limits_{j=1}^{\text{min}(i,\text{deg}\mathcal{P})}((n+1)j-i)a_{j}b_{i-j},$$
и сложность вычисления существенно уменьшается. Действительно,
суммы, позволяющие вычислить коэффициент, имеют самое большее
deg $\mathcal{P}$ членов. Следовательно, вычисление коэффициентов результирующего многочлена требует: $n$ умножений для вычисления $b_{0}$, $i$ умноже­ний в базовом кольце и $i-1$ сложений в базовом кольце, если $i\leqslant\text{deg}\mathcal{Р}$,
deg$\mathcal{P}$, умножений и deg$\mathcal{P}$ сложений в базовом кольце, если $i > \text{deg}\mathcal{P}$.
Таким образом, получаем общую оценку сложности, не превышающую $d^2 n$ умножений и сложений.
\\\\
\noindent\textbf{34. Определение нулей многочлена по модулю $p^{\alpha}$}\\

\textbf{а.} Решение этого уравнения тривиально в случае, когда а обратим
по модулю $n$. Если $a$ не обратим, то вычислим $d = \Nod(a,n)$ и рассмотрим два случая: в лучшем $b$ делится на $d$, в этом случае разделим уравнение на $d$ и решим уравнение $a'x = b'$ по модулю $n'$, с обратимым $a'$.
\begin{lstlisting}[frame=none, mathescape=true]
\\ Пусть $d\geqslant 0$, $u$ и $\;v$ такие, что $\;ua+vn=d=\Nod(a,n)$
if (b % d != 0) return NULL;
else return (ub/d+kn/d) \\ $0\leqslant k<d$
\end{lstlisting}
(Если $b$ не делится на $d$, то уравнение не имеет решений.)
\newpage
Итак, разложение по убыванию степеней многочлена, стоящего в произведении
слева, дает меньшую сложность, нежели если разлагать тот же самый многочлен
в обратном порядке: квадратичную в лучшем случае (плотный многочлен справа),
или кубическую в худшем случае (плотный многочлен слева и разреженный справа).
В любом случае разложение в порядке убывания степеней дает большую сложность.\newline

\noindent\textbf{33. Действия с формальными рядами}\newline

\textbf{a.} Формула $(\sum a_iX^i)^2 = \sum a_i^2 X^{2i} + \sum_{i < j}2a_i a_j X^{i+j}$ позволяет констатировать,
что вычисления квадрата ряда возможно и, что для вычисления $n$-го коэффициента
формального ряда, являющегося результатом, необходимо $n$ начальных коэффициентов исходного ряда. Более точно, вот список итераций для осуществления чтения $i$-го коэффициента:

(\textit{i}) вычислить

\begin{equation*}
S_i = a_i X^{2i} + 2 \sum_{\substack{0 \leqslant j < i}} a_i a_j X^{i+j}
\end{equation*}
(тогда $\sum^2 = S_0 + S_1 + S_2 + \cdots$),

(\textit{ii}) прибавить $S_i$ к многочлену (вычисленному с использованием $i - 1$ первых слагаемых),
аппроксимирующему формальный результирующий ряд,

\textit{iii} вывести $i$-й коэффициент результирующего ряда; этот коэффициент
больше не будет участвовать в последующих вычислениях.

То, что было описано, есть теоретический алгоритм, показывающий выполнимость
вычисления квадрата формального ряда. Осталось предложить программу,
осуществляющую эти вычисления: структуру данных, управление, переменные и т.д.

Как ясно из предыдущего описания, исходный формальный ряд, коэффициенты которого
читаются последовательно, надо представить динамической структурой - например,
в виде списка, состоящего из пар коэффи- \linebreak циент-степень (в действительности,
в стек помещается не исходный ряд, а его копия, эффективность обязывает!).
По причине однородности, коэффициенты вычисляемого ряда размещают списком,
аналогичным коэффициентам, частично вычисленным. Для манипулирования этими
списками используются примитивы, введенные в упражнении 30. Каждый список,
участвующий в алгоритме, представляет многочлен, аппроксимирующий формальный ряд, мономы которого
упорядочены по возрастанию ( начиная со слагаемых наименьшей степени в списке).
\newpage

\begin{lstlisting}[mathescape=true, caption=Квадрат формального ряда, language=Ada]
$\textbf{input}$ a;
$Square\_Of\_A \leftarrow a^2 X^0; Double\_A \leftarrow 2aX^0; aux \leftarrow 0; i \leftarrow 0;$
$\textbf{output}$ $a^2 X^0$;
loop
  //$\text{deg}(Double\_A) \leqslant i, \text{deg}(Square\_Of\_A) \leqslant i, \text{deg}(aux) \leqslant 2i, \text{ord}(aux) \geqslant i$
  $\textbf{input}$ a;
  $i \leftarrow i + 1; aux \leftarrow aux + (aX' \times Double\_A) \oplus a^2 X^{2i}$;
  $\textbf{output}$ $First(aux)$;
  $Double\_A \leftarrow Double\_A \oplus 2aX'$;
          $Square\_Of\_A \leftarrow Square\_Of\_A \oplus First(aux);$
  $aux \leftarrow Tail(aux)$;
end loop;
\end{lstlisting}

В алгоритме 19 символ «ord» обозначает порядок формального ряда
(т.е. степень монома наименьшей степени). Символ $\oplus$ обозначает формальное
сложение многочлена и монома степени, превосходящей степень многочлена
или не превосходящей порядка многочлена, что с практической точки зрения
означает добавление элемента к началу или к концу списка. Кроме того,
обозначение $2aX^i \times Double\_A$ означает список, в котором элемент с номером $j$
является произведением элемента с тем же номером в списке $Double\_A$ на моном $2aX^i$.
Примитивы \textbf{input} и \textbf{output} — это основные примитивы алгоритма, работающего с потоком
данных: входные данные, полученные благодаря примитиву \textbf{input}, в принципе, порождают
результат, выводящийся с помощью примитива \textbf{output}. Заметим в заключение, что запоминание
результирующего формального ряда $Square\_Of\_A$ не является необходимым для алгоритма.

\textbf{b.} Определим производную формального ряда $\mathcal{B} = \mathcal{A}^n$, полученную по правилу $\mathcal{B}' = n\mathcal{A}'\mathcal{A}^{n-1}$.
Если это выражение умножить на $\mathcal{A}$, то получим $\mathcal{AB}' = n\mathcal{A}'\mathcal{B}$. Теперь можно почленно сопоставить
оба формальных ряда: $\mathcal{AB}'$ и $\mathcal{A}'\mathcal{B}$. Для члена степени $i - 1$ получим
$ia_0 b_i + \sum^i_{j=1} (i-J)a_j b_{i-j} = n\sum^i_{j=1}$ \linebreak $ja_j b_{i-j}$, что дает нам формулу для вычисления $b_i$
\begin{equation*}
b_i = \frac{1}{a_0 i} \sum\limits^i_{j=1}((n + 1)j - i)a_j b_{i-j};
\end{equation*}
она позволяет вычислить очередное значение. Детали эффективного алгоритма,
осуществляющего вычисление $\mathcal{A}^n$, оставляются читателю.
\newpage
\noindent Можно видеть, что в любом случае алгоритм должен начинаться с вы-\linebreak
числения НОД и коэффициентов Везу для $a$ и $n$. В случае, когда $a$ не­-\linebreak
обратим и $b$ делится на $d$, каждому решению по модулю $n'$ отвечают\linebreak
$d$ решений по модулю $n$, отличающихся слагаемым, кратным $n'$. Заме­-\linebreak
тим, что этот алгоритм неявно, но конкретно, обрабатывает случай,\linebreak
когда $a=0$.\newline
\\
\hspace*{15pt}\textbf{b.} Для доказательства этого факта с помощью использования двой­-\linebreak
ной индукции заметим, что $(p+1)(p+2)...(p+n-1)(p+n)=$\linebreak
$p\cdot(p+1)(p+2)...(p+n-1)+n\cdot(p+1)(p+2)...(p+n-1)$, где\linebreak
каждое слагаемое, удовлетворяющее тому или иному предположению\linebreak
индукции, делится на $n!$. К тому же, в данном рекуррентном соотно-\linebreak
шении нас интересует целочисленность величины $\left(\begin{smallmatrix}
n+p\\ p\\
\end{smallmatrix}\right).$\newline
\\
\hspace*{15pt}\textbf{c.} Формула Тейлора
$$P(a+tp^\alpha)=P(a)+tp^\alpha P'(a)/1!+...+t^dp^{ad}P^{(d)}(a)/d!$$
доказывает первое свойство, так как вопрос а позволяет показать, что\linebreak
$P^{(i)}$ делится на $i!$. Доказательство необходимого и достаточного усло-\linebreak
вия очень просто, оно опирается на то т факт, что если разделить пре-\linebreak
дыдущую формулу на $p^\alpha$, то получим доказательство в одну сторону,\linebreak
а если умножить полученную формулу на $p^\alpha$, то получится доказатель-\linebreak
ство в другую сторону. Алгоритм получается немедленно:
\begin{lstlisting}[mathescape=true, language=Ada]
$E\longleftarrow\emptyset;$ for $a$ in $\{\text{нули}$ $P$ $\text{по модулю}$ $p^{\alpha}\}$ loop
	for $t$ in $\{ \text{решение}$ $P(a)/p^\alpha+tP'(a)=0\mod{p^1} \}$ loop
		$E\longleftarrow E\cup\{a+tp^\alpha\};$
	end loop;
end loop;
\end{lstlisting}
\hspace*{15pt}\textbf{d.} Предположим, что $P$ имеет единственный корень $a_i$ по модулю $p^i$,\linebreak
который поднимает корень $a$. Сравнение $P(a_i+tp^i)\equiv P(a_i)+tp^i P'(a_i)\equiv$\linebreak
$\equiv P(a_i)+tp^iP'(a)~(\text{mod }p^{i+1})$ доказывает существование и единствен-\linebreak
ность такого $t$ по модулю $p$, что $P(a_i+tp^i)\equiv0 = 0 ~(\text{mod }p^{i+1})$. Кроме\linebreak
того, $tp^i$ дается формулой $tp^i=-P(a_i)P'(a)^{-1}$. Это доказывает, что $P$\linebreak
имеет один и только один корень $a_{i+1}$ по модулю $p^{i+1}$ , поднимающий\linebreak
корень $a$. Дальше достаточно воспользоваться индукцией.\newline
\\
\hspace*{15pt}\textbf{e.} В действительности сформулированное в предыдущем вопросе\linebreak
свойство может быть обобщено и передоказано по модулю $p^{k+\alpha}$ для\linebreak
корней $P$ по модулю $p^\alpha$ для всякого $k\leqslant a$. Необходимое и достаточное\linebreak
условие выглядит тогда так: $P(a+tp^\alpha)\equiv 0~(\text{mod }p^{k+\alpha})$ тогда и только\linebreak
тогда, когда $P(a)/p^\alpha+tP'(a)\equiv0~(\text{mod}~p^k)$. Единственное изменение\linebreak

\pagebreak
\noindent состоит в том, что надо заменить $p^1$ в предыдущем алгоритме на $p^k$ и рассмотреть $k$ как параметр алгоритма.
\newline \newline \indent
\textbf{f.} Используя алгоритмы восстановления в $\mathbb{Z}_{p^{a+k}}$ для нулей по мо­дулю $p^\alpha$, можно сконструировать алгоритм подъема корней из $\mathbb{Z}_p$ в $\mathbb{Z}_{p^n}$, минимизирующий количество промежуточных этапов. Как и вы­ше, определим корни по модулю $p$, что делается очень просто, если $p$ — простое число, — подстановкой последовательно всех точек из $\mathbb{Z}_p$. Это первичное исследование заканчивается, когда будут найдены все
корни многочлена $P$, их число равно степени НОД$(P,X^p - X)$. Далее поднимаем эти корни в $\mathbb{Z}_{p^2}$, $\mathbb{Z}_{p^4}$, $\dots$, каждый раз удваивая показатель $p$. Этот процесс заканчивается, когда будет получена достаточно большая степень $p$, не превосходящая $p^n$, и далее надо применить алгоритм
для значения $k$, которое не обязательно максимально. Например, для
перехода от $\mathbb{Z}_p$ к $\mathbb{Z}_{p^57}$ вычисляются решения по модулям $p^2$, $p^4$, $p^8$, $p^16$, $p^32$ и, наконец, $p^57$ при $k = 25$.
\newline \newline
\textbf{35. Циклическая перестановка элементов массива}
\newline \newline \indent
\textbf{a.} Алгоритм является простым обобщением классического алгорит­
ма обмена значениями двух переменных.
\begin{lstlisting}[mathescape=true]
$Aux \longleftarrow T(n-1)$
for (unsigned int i = n - 1; n$--$ > 1;) {
    $T(i) \longleftarrow T(i - 1)$
}
$T(0) \longleftarrow Aux$;
\end{lstlisting}
\textit{\indent} \textbf{b.} Можно показать, что если $i + kp = i + k'p\:mod\:n$, то $k -k'$ делится на $n/d$, где $d$ есть НОД $n$ и $p$ . Следовательно мощность множества
индексов есть $n/d$.
\newline \indent
Ротация (т.е. циклическая перестановка) элементов массива это, в действительности, сдвиги индексов и, по доказанному выше, эти сдви­ги определяют \textit{орбиты}, являющиеся общими инвариантами трансля­ций, длины $n/d$, элементы которых находятся на расстоянии $p$. Следо­вательно, осуществление ротации массива проходит по-орбитно. Это дает нам алгоритм:
\begin{lstlisting}[mathescape=true]
$Aux \longleftarrow T(n-1)$
for (unsigned int Orbite = 0; Orbite < n; Orbite++) {
    $Index \longleftarrow (Orbite - p)\:mod\:n; Aux \longleftarrow T(Index);$
    for (unsigned int $k$ = 1; $k$ < $n/d$; k++) {
        $T(Index) \longleftarrow T((Index - p)\:mod\:n); Index \longleftarrow (Index - p)\:mod\:n;$
    }
    $T(Index) \longleftarrow Aux;$
}
\end{lstlisting}
\newpage
Сложность полученного алгоритма, следовательно, составляют $n + \text{НОД}(n,p)$ присваиваний элементов массива, что дает $pn$ или $(n - p)n$ необходимых присваиваний, если повторно применять алгоритм из во­проса \textbf{а}.
\newline \newline \indent
\textbf{c.} Обмен двух участков (дополнительных) массива сводится к по­вороту таблицы в лучшую сторону в смысле некоторого числа позиций. Теперь достаточно применить предыдущий алгоритм.
\newline \newline
\textbf{36. Элементарные операции в арифметике повышенной точности}
\newline \newline \indent
\textbf{a.} Алгоритм $20-A$ получается непосредственно. Важным моментом
является управление переносом.
\begin{multicols}{2}
\begin{center}
\textbf{A.} Сложение
\end{center}
{\begin{lstlisting}[mathescape=true]
$carry \longleftarrow 0$;
for (unsigned i = 0; i <= m; i++) {
    $aux \longleftarrow u_i + v_i + carry$;
    if (aux < b) {
        $w_i \longleftarrow aux$; $carry \longleftarrow 0$;   
    } else {
        $w_i \longleftarrow aux - b$; $carry \longleftarrow 1$;
    }
}
if (carry == 1) { //$u + v \geq b^{m+1}$
   $w_{m+1} \longleftarrow 1$
}
\end{lstlisting}}
\columnbreak
\begin{center}
\textbf{B.} Вычитание
\end{center}
{\begin{lstlisting}[mathescape=true]
$carry \longleftarrow 0$;
for (unsigned i = 0; i <= m; i++) {
    $aux \longleftarrow u_i - v_i - carry$;
    if (aux < 0) {
        $w_i \longleftarrow aux + b$; $carry \longleftarrow 1$;   
    } else {
        $w_i \longleftarrow aux$; $carry \longleftarrow 0$;
    }
}
if (carry == 1) {
   $u < v$ и $w = b^{m+1} + u - v$
}
\end{lstlisting}}
\end{multicols}
\begin{center}
\textbf{Алгоритм 20.} Вычисление $(u_m \dots u_0)_b \pm (v_m \dots v_0)_b$
\end{center}
$\:$ \newline
\textit{\indent}\textbf{b.} В полном алгоритме $20-B$, если $u \geq v$, то легко доказать по ин­дукции, что $carry = 0$ или $1$ и $0 \geq (u_i - v_i - carry) + b < 2b$.
\newline \indent Что делать, если $u < v$? В этом случае можно проверить, что вычисляемое число представляет $b^{m+1} + u — v$ и то, что $u < v$ может быть обнаружено после цикла проверкой текущего значения; до того, как цикл будет проверять текущее значение.
\newline \newline \indent
\textbf{c.} Алгоритм 21 основывается на следующем соотношении:
\begin{align*}
(u_{i+1} \dots u_0) \times v = (u_i \dots u_0) \times v + u_{i+1} v b^{i+1}.
\end{align*}
\newline
\noindent Можно доказать, что в этом алгоритме являются цифрами ввиду
соотношений: $0\leqslant carry < b\;aux\leqslant(b —1)b < b$. Этот алгоритм легко распространяется на (наивное) умножение двух чисел произвольной
длины.
\def\tmpsuka{Вычисление $v\times(u_{m}\ldots u_{0})_b,0\leqslant v<b$}

\begin{lstlisting}[mathescape=true,caption=\tmpsuka]
carry=0;
for (i=0; i <= m; ++i){
	//$\;\;(w_{i-1}+carry\times b'=(u_{i-1}\ldots u_{0})_{b}\times v$
	aux = v*u$_{i}$+carry;$\;$w$_{i}$=aux%b;$\;$carry=aux/b;
}
w$_{m+1}$=carry;
\end{lstlisting}

\textbf{d.} Остаток $r = (u_{n},\ldots,u_{0})_{b}$ mod $v$, где $v$ — цифра, вычисляется по
алгоритму Горнера, где полагается $r_{n+1} = 0$ и $r_{i} = (r_{i+1}\times b + u_{i})$ mod $v$
при $i = n,n—1,\ldots,0$. Искомое значение есть $r_{0}$, что доказывается
с помощью $r_{i}=(u_{n}\ldots u_{i})_{b}$ mod $v$. Можно видеть, что алгоритм 22-A
вычисляет частное $\lfloor u/v\rfloor$, а алгоритм 22-B вычисляет остаток $u$ mod $v$.
Распространение на числа произвольной длины
\begin{table}[h!]
\centering
\begin{tabular}{|l|l|}
\hline
\underline{\textbf{A.} Вычисление частного} & \underline{\textbf{B.} Вычисление остатка} \\
{\begin{lstlisting}[mathescape=true, frame=none]
r = 0;
for (j = n;j >= 0; j--){
	aux = r*b + u$_{n}$;
	q$_{j}$ = aux/v;
	r = aux % v;
}	
\end{lstlisting}} & 
{\begin{lstlisting}[mathescape=true, frame=none]
r = 0;
for (j = n; j >= 0; j--){
	r = (r*b + u$_{j}$) % v;
}
\end{lstlisting}}	
\\ \hline

\multicolumn{2}{c}{{\large Деление $(u_{m}\ldots u_{0})_b$ на $v$ при $0\leqslant v<b$}}
\end{tabular}
\end{table}
этих двух операций не является таким простым, как в случае умноже­ния. В действительности, это тема дальнейших упражнений.
\\\\
\noindent\textbf{37. Деление в арифметике повышенной точности}
\\

Предположим, что $v$ имеет \textit{нормализованную } запись (т.е. $v_{m} \neq 0$)
и, кроме того, $n \geqslant m$ (запись не обязательно нормализованная). Надо
найти частное и остаток с помощью массива $q = (q_{n-m}\ldots q_{1}q_{0}$ и $r = (r_{m}\ldots r_{1}r_{0})$. Заметим, что условие $u/v < b$ можно записать также в
виде $(u_{m+1}\ldots u_{1})_{b}<(v_{m}\ldots v_{1}v_{0})_{b}$ В самом деле,
$$(u_{m+1}\ldots u_{0})/v<b \Leftrightarrow (u_{m+1}\ldots u_{0})/b<v \Leftrightarrow \lfloor(u_{m+1}\ldots u_{0})/b\rfloor<v$$
\newpage
\noindent и $\lfloor(u_{m+1}\ldots u_{0})/b\rfloor=(u_{m+1}\ldots u_{1})$. Вот общий алгоритм вычисления пары (частное, остаток):

\begin{leftbar}
\begin{lstlisting}[frame=none, mathescape=true]
$(r_{n+1}r_{n}\ldots r_{1}r_{0}\;=\;(0u_{n}\ldots u_{1}u_{0}$;
for (j = n-m; j >= 0; j--){
	\\$\;\;u=(q_{n-m}\ldots q_{j+1})\times vb^{j+1}+r\;\;\text{и}\;\;r<vb^{j+1}$
	q$_{j}$=$(r_{m+j+1}r_{m+j}\ldots r_{j})$/v;
	$(r_{m+j+1}\ldots r_{j}$ = $(r_{m+j+1}\ldots r_{j})$ - $q_{j}v$;
}	
\end{lstlisting}
\end{leftbar}
Частное, используемое в цикле, является частным двух чисел, удо­вле- \linebreak творяющих порождающему условию (5) (и, следовательно, каждое вычисляемое $q_{j}$ является цифрой!). Чтобы убедиться в этом, достаточно заметить, что перед присваиванием $q_{j}$ имеем:
$$ r<vb^{j+1}\;\;\;\Longleftrightarrow\;\;\;(r_{m+j+1}\ldots r_{j+1})_{b}<v,$$
что, по предыдущему замечанию, равносильно $(r_{m+j+1}\ldots r_{j})/v<b$
\\\\
\noindent\textbf{38. Вычисление частного методом проб и ошибок}
\\

\textbf{a.} Предположения (5) включают неравенство $(u_{m+1}\ldots u_{1})_{b} < (v_{m}\ldots v_{1}v_{0})_{b}$, откуда u$u_{m+1}\leqslant v_{m}$. Читатель может проверить, что
тогда:
$$\text{min}(\lfloor u_{m+1}b+u_{m})/v_{m}\rfloor,\;b-1)=\left\lbrace\begin{array}{ll}
b-1,&\text{если}\;\;u_{m+1}=v_{m},\\
\lfloor(u_{m+1}b+u_{m})/v_{m}\rfloor&\text{иначе,}
\end{array}\right.$$
и проверка для определения наименьшего из двух чисел сводится к про­- \linebreak верке $u_{m+1}=v_{m}$

Докажем сначала, что $q\leqslant\widehat{q}$. Так как $q\leqslant b — 1$ (предположение (5)),
можно очевидно предположить, что $\widehat{q}=\lfloor(u_{m+1}b+u_{m})/v_{m}\rfloor$. Запишем:
$$u=u_{m+1}b^{m+1}+u_{m}b^m+\alpha,\;\;\;\;v=v_{m}b^m+\beta,$$
с $\beta<b^m$ и $\alpha<b^m$. Тогда получим $u-\widehat{q}v=(u_{m+1}b+u_{m}-\widehat{q}v_{m})b^m+$\linebreak
$\alpha-\widehat{q}\beta$. По определению $\widehat{q}\;u_{m+1}b+u_{m}<v_{m}(\widehat{q}+1)$ и, следовательно, $u_{m+1}b+u_{m}-$ \linebreak $u_{m}\widehat{q}\leqslant v_{m}-q$, что влечет
$$u-\widehat{q}v\leqslant(v_{m}-1)b^m+\alpha-\widehat{q}\beta\leqslant(v_{m}-1)b^m+\alpha\leqslant v_{m}b^m+(\alpha-b^m)<v_{m}b^m\leqslant v,$$
и неравенство $u-\widehat{q}v<v$ дает $q\leqslant\widehat{q}$.

Для доказательства второго неравенства введем $\delta=\widehat{q}-q$. Используя неравенство для $\widehat{q}$: $\widehat{q}\leqslant\frac{u_{m+1}b+u_{m}}{v_{m}
}\leqslant\frac{u}{v_{m}b^m}$ и для $q$: $q>\frac{u}{v}-q$,
\newpage

%                                  173
\noindent
получаем:
\begin{center}
$\delta=\hat{q}-q\leqslant\dfrac{u}{v_mb^m}-\dfrac{u}{v}+1=\dfrac{u}{v}\dfrac{v-v_mb^m}{v_mb^m}+1\leqslant\dfrac{u}{v}\dfrac{b^m}{v_mb^m}+1$,
\end{center}
откуда $\delta{v_m\leqslant{\dfrac{u}{v}}+v_m}$ и, следовательно,
\begin{center}
$\delta{v_m}\leqslant\left[\dfrac{u}{v}\right]+v_m=\hat{q}-\delta+v_m\leqslant{b-1-\delta+v_m}$.
\end{center}
Отсюда получаем окончательно $\delta\leqslant(b+v_m-1)/(v_m+1)$.\newline
\hspace*{15pt}Эффективная реализация деления требует уже использования деле-\linebreak
ния числа из двух цифр на число из одной цифры.\\

\textbf{b.} Записав: $u=u_{m+1}b^{m+1}+u_mb^m+u_{m-1}b^{m-1}+\alpha, v=v_mb^m+$\linebreak
$v_{m-1}b^{m-1}+\beta$ с $\alpha<b^{m-1}$ и $\beta<b^{m-1}$, получаем:
\begin{center}
$u-\hat{q}v=((u_{m+1}b+u_m-\hat{q}v_m)b+u_{m-1}-\hat{q}v_{m-1})b^{m-1}+\alpha-\hat{q}\beta=$
\end{center}
\hspace*{80pt}$=(\hat{r}b+u_{m-1}-\hat{q}v_{m-1})b^{m-1}+\alpha-\hat{q}\beta$.\newline
В случае $(i)$ $\hat{r}b+u_{m-1}-\hat{q}v_{m-1}\leqslant-1$, что дает:
\begin{center}
$u-\hat{q}v\leqslant-b^{m-1}+\alpha-\hat{q}\beta\leqslant-b^{m-1}+\alpha<-b^{m-1}+b^{m-1}=0$,
\end{center}
а неравенство $u-\hat{q}v<0$ дает $q\leqslant\hat{q}-1$. В случае $(ii)$ $\hat{r}b+u_{m-1}-\hat{q}v_{m-1}\geqslant{0}$\linebreak
и, следовательно,
\begin{center}
$u-\hat{q}v\geqslant\alpha-\hat{q}\beta\geqslant-\hat{q}\beta\geqslant-b\times{b^{m-1}}\geqslant-v_mb^m\geqslant-v$.
\end{center}
Тогда неравенство $u-(\hat{q}-1)v\geqslant0$ дает $q\geqslant\hat{q}-1$. Алгоритм, изобра-\linebreak
\begin{multicols}{2}
\noindent
женный справа, показывает, как ин-\linebreak
терпретировать случаи $(i)$ и $(ii)$ во-\linebreak
проса \textbf{b}: они позволяют быстро кор-\linebreak
ректировать (вычисления, которые\linebreak
здесь участвуют, относятся к числам
из двух цифр) \textbf{начальную} оценку
способом получения \textbf{исправленной}\linebreak
\columnbreak
\begin{lstlisting}[mathescape=true, frame=l]
$\hat{q}\leftarrow$ min $\left(\left[\frac{u_{m+1}+u_m}{v_m}\right], b-1\right)$;
$\hat{r}\leftarrow{u_{m+1}}b+u_m-\hat{q}v_m$;
while ($q\leqslant\hat{q}$) {
  if ($\hat{q}v_{m-1}\leqslant{b}\hat{r}+u{m-1}$)  break;
  //$q\leqslant\hat{q}-1$
  $\hat{q}\leftarrow\hat{q}-1$; $\hat{r}\leftarrow\hat{r}+v_m$;
}
//$q=\hat{q}\text{ или даже }q=\hat{q}-1$
\end{lstlisting}
\end{multicols}
\noindent
оценки $\hat{q}$, где $q\in\{\hat{q},\hat{q}-1\}$. К приме-\linebreak
ру, зафиксируем $b=10, m=2, u=(u_3u_200)_{10}$ и $(q+1)v_1\leqslant10(10u_3+u_2-$\linebreak
$(q+1)v_2$, тогда исправленная оценка равна начальной оценке, которая\linebreak
равна $q+1$ (вместо $q$). Например, если $u=5000$, то возможные значения\linebreak
$v$, для которых исправленная оценка равна $q+1$, следующие:
\begin{center}
626, 627, 628, 629, 715, 716, 717, 718, 719, 834, 835, 836, 837, 838, 839.
\end{center}
\newpage
%                                174
\textbf{c.} Если $r$ обозначает остаток от деления $u$ на $v$, то имеем\linebreak
$0\leqslant{r}<b^{m+1}$, откуда следует, что достаточно определить $r$ mod\linebreak
$b^{m+1}$. Упражнение 36, для чисел $u$ и $\hat{q}$ веса $\leqslant m+1$, позволяет ре-\linebreak
ализовать одновременно вычисление проверки $u\geqslant\hat{q}v$ и вычисление\linebreak
$(u-\hat{q}v)$ mod $b^{m+2}$, следовательно и вычисление $(u-\hat{q}v)$ mod $b^{m+1}$. Кро-\linebreak
ме того, хотя участвующие числа удовлетворяют соотношениям для\linebreak
весов $\leqslant{m+1}$, внимательное изучение показывает, что можно вычи-\linebreak
слить $(u-\hat{q}v)$ mod $b^{m+1}$ в массиве $\rho=(\rho_m,\rho_{m-1},...,\rho_0)$ и реализовать\linebreak
проверку $u\geqslant\hat{q}v$. Тогда $(q,r)$ можно определить следующим образом\\

\noindent
\hspace*{40pt}если $u\geqslant\hat{q}v$,\hspace{20pt}$q=\hat{q}$\hspace{45pt}$r=\rho$;\newline
\hspace*{40pt}если $u<\hat{q}v$,\hspace{20pt}$q=\hat{q}-1$,\hspace{25pt}$r=(\rho+v)$ mod $b^{m+1}$.\\

\noindent
Получили алгоритм 23.
\begin{lstlisting}[mathescape=true, caption={Частные и остатки от деления $(u_{m+1}...u_0)$ на $(v_m...v_0)$, где $u/v<b. n\geqslant1$}]
if $u_{m+1}=v_m$  $\hat{q}\leftarrow{b-1}$; else  $\hat{q}\leftarrow\left[\frac{u_{m+1}b+u_m}{v_m}\right]$;
$\hat{r}\leftarrow{u_{m+1}}b+u_m-\hat{q}v_m$;
for (;;) {
  if ($\hat{q}v_{m+1}\leqslant{b}\hat{r}+u_{m-1}$)  break;
  $\hat{q}\leftarrow\hat{q}-1$; $\hat{r}\leftarrow\hat{r}+v_m$;
}
$\text{Одновременное вычисление }$$\rho=(u-\hat{q}v)$$\text{ mod }$$b^{m+1}$$\text{ и проверка }$$u\geqslant\hat{q}v$
if ($u\geqslant\hat{q}v$)
  $(q,r)\leftarrow(\hat{q},\rho)$;
else
  $(q,r)\leftarrow(\hat{q}-1, (\rho+v)$ mod $b^{m+1}$;
\end{lstlisting}
\textbf{39. Деление: операция нормализации}\\
\hspace*{15pt}\textbf{a.} Известно, что $0\leqslant\hat{q}-q\leqslant(b+v_m-1)/(v_m+1)$. Для получения\linebreak
$\hat{q}-q\leqslant2$ достаточно иметь $(b+v_m-1)/(v_m+1)<3$, что, после проверки\linebreak
эквивалентно $v_m\geqslant[b/2]-1$.\\

\textbf{b.} Исправленная оценка $\hat{q}$ удовлетворяет соотношению $\hat{q}v_{m-1}\leqslant{b}\hat{r}+$\linebreak
$u_{m-1}$. т.е.:
\begin{center}
$\hat{q}v_{m-1}\leqslant{b}(u_{m+1}b+u_m-\hat{q}v_m)+u_{m-1}$,
\end{center}
что влечет: $(v_mb+v_{m-1})\hat{q}\leqslant{u_{m+1}}b^2+u_mb+u_{m-1}\leqslant{u}$. Отсюда следует:\linebreak
\begin{center}
$u-\hat{q}v\geqslant{u(1-\dfrac{v}{v_mb^m+v_{m-1}b^{m-1}})}$.
\end{center}

\newpage

\noindent Однако,

$$
1-\dfrac{v}{v_mb^m+v_{m-1}b^{m-1}} = \dfrac{v_mb^m+v_{m-1}b^{m-1}-v}{v_mb^m+v_{m-1}b^{m-1}} = - \dfrac{v_{m-2}b^{m-2}+...+v_0}{v_mb^m+v_{m-1}b^{m-1}}
$$ \linebreak 
$$ > \dfrac{-b^{m-1}}{v_mb^m+v_{m-1}b^{m-1}} \ge \dfrac{-b^{m-1}}{v_mb^m} = \dfrac{-1}{v_mb}
$$

\noindent и, следовательно, $\frac{u-\hat{q}v}{bv_m} > -u$. Оценка $\hat{q}$ по предположению отлична от $q$, так что $q = \hat{q}-1$ и поэтому

\[
u-qv = v+u-\hat{q}v > v-\dfrac{u}{v_mb} = v(1-\dfrac{u}{v}\dfrac{1}{v_mb}),
\]

\noindent и, наконец, используя то, что $u/v \le q+1 = \hat{q} \le b-1$, и предположение $v_m \ge [b/2]$, имеем:

\[
u-qv > v(1-\dfrac{b-1}{v_mb}) \ge v(1-\dfrac{2}{b}).
\]

\textbf{c.} Ясно, что $u'$ имеет вес $\le n+1$, так как $[b/(v_m + 1)]$ — цифра, и осталось доказать, что $v'$ имеет вес $m$. Рассмотрим сначала частный случай $m = 1$:

\[
1 \le v \le b-1 \Longrightarrow [b/2] \le v[b/(v+1)] \le b-1 \text{ (границы достижимы)}.
\]

\noindent Из $v[b/(v+1)] < (v+1)[b/(v+1)] \le b$ получаем правое неравенство. Докажем левое неравенство. Так как всегда $v[b/(v+1)] \ge v$, то можно предположить, что $v<[b/2]$. Тогда: $v[b/(v+1)] > v(\frac{b}{v+1} - 1) = f(v)$. Но $f(v)-f(1) = (v-1)\frac{b/2-v-1}{v+1}$. Поэтому:

\[
v < [b/2] \Longrightarrow v \le b/2-1 \Longrightarrow f(v)-f(1) \ge 0 \Longrightarrow f(v) \ge f(1) = b/2-1,
\]

откуда $v[b/(v+1)] > [b/2]-1$, что и требовалось доказать.

Перейдем к общему случаю. С одной стороны:

\[
v' = [b/(v_m+1)]v < [b/(v_m+1)](v_mb^m+b^m) = [b/(v_m+1)](v_m+1)b^m<b^{m+1},
\]

\noindent что и доказывает, что старшая цифра у $v'$ не меньше $[b/2]$.

Из деления $u'$ на $v'$ можно вывести деление $u$ на $v$. Действительно, если $u'=v'q'+r'$ и $u=vq+r$, то $q=q'$ и $r=r'/d$ (имеется ввиду точное деление числа на цифру). Окончательный алгоритм деления получается объединением алгоритмов, изученных в предыдущих упражнениях.

\pagebreak

\noindent \textbf{40. Самовоспроизводящаяся программа}

Решением задачи является следующая программа:

\begin{lstlisting}[frame=none]
with Text_IO; use Text_IO;
procedure R is
	procedure P (S : String) is
		use Ascii;
	begin
		Put_Line (S);
		Put_Line ('('& Quotation & S & Quotation &%);end R;%);
	end P;
begin
	-- специальная строка
end R;
\end{lstlisting}

В этой программе $10$ содержит весьма длинную инструкцию (из которой можно удалить все ненужные пробелы):

\begin{lstlisting}[frame=none, mathescape=true, showstringspaces=false]
	P("WITH Text_I0;USE Text_I0;PROCEDURE R IS PROCEDURE
P(S:String)IS USE ASCII;BEGIN Put_Line(S);
Put_Line('('&Quotation&S&Quotation&%);end R;%);
END P; BEGIN P");
\end{lstlisting}

Если нужна программа с действительно более короткими строками \linebreak (строка "$10$" содержит около $160$ символов), то это, разумеется, можнно сделать, хотя программа станет чуть длиннее. Символ " не может просто появиться в цепочке - аргументе $P$ в строке $7$, там была использована константа Quotation, определенная в пакете Ascii. Наконец, была использована одна из возможностей языка Ада, которая позволяет разграничивать цепочки символов со знаком \% если не располагаем кавычками. Все использованные уловки только укорачивают программу, но не делают ее возможной. Можно заметить, что эта программа не воспроизводит знак за знаком оригинальный исходный текст. Она порождает программу, которая эквивалентна. И пусть этот недостаток кажется неприемлемым, зато идея
проста: эта программа порождает программу $P$, которая порождает $P$..
\newpage

%\section{Глава II}
%\section{Евклид и основная теорема арифметики}
%\newtoplo{Обобщение арифметики целых чисел}
%\setcounter{chapter}{2}
\chapter{Евклид и основная теорема арифметики}
\noindent Вычислить наибольший общий делитель двух целых чисел {\it a} и {\it b}.Такое задание иногда получают лицеисты на уроке математики. Они начинают с разложения чисел {\it a} и {\it b} в произведение степеней простых чисел (используя при необходимости нулевые показатели для степеней простых чисел, чтобы выровнять количество простых чисел в разложениях): 
\[
 a=p_1^{\alpha_1}p_2^{\alpha_2}...p_m^{\alpha_m} (\alpha_i \geqslant 0), \quad b=p_1^{\beta_1}p_2^{\beta_2}...p_m^{\beta_m} (\beta_i \geqslant 0) \quad (p_i \text{ простое}),
\]
\noindent Потом они применяют хорошо известную формулу, которая дает наибольший общий делитель (НОД): 
\[
\text{НОД}(a,b)=p_1^{\inf (\alpha_1,\beta_1)} \times p_2^{\inf (\alpha_2,\beta_2)} \times \cdots \times p_m^{\inf (\alpha_m,\beta_m)}.
\]
Легко используемый в работе с малыми числами (например, $a = 84 = 2^2 \times 3 \times 7,$ \linebreak $b = 198 = 2 \times З^2 \times 11$, что дает НОД(84,198) = 2 x 3 = 6), этот метод быстро становится неприемлемым для больших чисел. Рассмотрим, к примеру $a = 1 100 005 423$ и $b = 1 100 000 077$. Разложение этих двух чисел в произведение простых множителей с помощью обыкновенного калькулятора, требующее примерно $10^4$ делений, убеждает, что приведенная выше формула совершенно бесполезна.

К счастью, 22 века назад греческий математик Евклид открыл эффективный метод вычисления НОД. Этот метод, известный как {\it алгоритм Евклида}, настолько фундаментальный, что слово {\it алгоритм} используется математиками (помимо своего обычного смысла в информатике) для выявления делимости в некоторых кольцах. Можно с полным основанием считать Евклида предшественником алгоритмической алгебры.
\newpage

Мы продемонстрируем этот алгоритм на примере, рассмотрение которого не привело лицеистов к успеху. 

Выполним евклидово деление (вводимое в начальной школе и состоящее в нахождении частного и остатка) числа $a = 1100 005 423$ на число $b = 1 100 000 077$, т.е. запишем $a = bq_1 + r_2$, где $q_1 = 1$ и $r_2 = 5346$. Осуществим аналогичный шаг с $b$ и $r_2$, что приводит к $b = r_2q_2 + r_3$ с $q_2 = 205 761$ и $r_з = 1771$. Продолжим затем таким же образом с $r_2$ и $r_3$ и т.д. В результате получим следующую таблицу евклидовых делений: 

$\hspace*{1cm} r_0 = 1 100 005 423, \hspace*{1cm}r_1 = 1 100 000 077,$\\ 
$\hspace*{1.54cm} r_1 = 1 100 000 077,\hspace*{1cm} r_2 = 5 346, $\\
$\hspace*{1.54cm} r_2 = 5 346,\hspace*{2.08cm} r_3 = 1 771,$ \\
$\hspace*{1.54cm} r_3 = 1 771,\hspace*{2.08cm} r_4 = 33,$ \\
$\hspace*{1.54cm} r_4 = 33,\hspace*{2.4cm} r_5 = 22, $\\
$\hspace*{1.54cm} r_5 = 22,\hspace*{2.4cm} r_6 = 11,$ \\

$\hspace*{1.28cm} 1 100 005 423 = 1 100 000 077\times 1 + 5346 \hspace*{1.54cm}(q_1 = 1),$\\
$\hspace*{1.8cm} 1 100 000 077 = 5 346\times 205 761+ 1 771\hspace*{1.75cm} (q_2 = 205 761),$\\
$\hspace*{2.88cm} 5 346 = 1 771\times 3 +33 \hspace*{2.95cm}(q_3 = 3),$\\
$\hspace*{2.88cm} 1 771 = 33\times 1 +11 \hspace*{3.3cm}(q_4 = 53),$\\
$\hspace*{3.21cm} 33 = 22\times 1 + 11 \hspace*{3.34cm}(q_5 = 1),$\\
$\hspace*{3.21cm} 22 = 11\times 2 + 0 \hspace*{3.5cm}(q_6 = 2).$\\

    Алгоритм за канчивает работу после получения нулевого остатка при делении 22 на 11. Последний полученный ненулевой остаток $r_6 = 11$ является НОД чисел $a$ и $b$. Чтобы убедиться в этом, надо, с одной стороны, увидеть общее равенство (становящееся однородным с обозначением $r_0 = a, r_1 = b, r_7 = 0): r_{i-1} = r_iq_i + r_{i+1}$ для $0\leqslant i\leqslant 6$ и,с другой стороны, воспользоваться свойством натуральных чисел: $d| bq+r \text{ и } d | b$ тогда и только тогда, когда $d | b \text{и} d | r$. Эта последняя эквивалентность приводит, в частности, к равенству НОД$(bq + r,b) = \text{НОД}(b, r)$. Из этого следует, что величина НОД$(r_i,r_{i+1})$ не зависит от $i$. При $r = 0$ она равна НОД$(a, b)$, а при $i = 6 — \text{НОД}(r_6,0) = r_6 = 11$, что подтверждает результат, полученный выше.
    \begin{center}
    \parbox{12cm}{
    Замечание. Бели необходимо применить первый метод вычисления НОД $a = 1100 005 423$ и $b = 1100 000 077$, то надо разложить эти два числа в произведение простых множителей. Поиск простых делителей для разложения а и Ь и найденный общий простой делитель 11 приводят к констатации, что числа $а/11$ и $b/11$ оба являются простыми. Эта последняя проверка требует при использовании наивного метода лицеистов приблизительно $2 х (\sqrt{10^8}/2) = 10^4$ делений (каждое из двух чисел $a/11$ и $b/11$ имеют порядок $10^8$). Разложение на простые множители $a = 11 х 100 000 493, b = 11 х 100 000 007$ снова дает НОД$(a, b) = 11$,}
\end{center}

\newpage
\begin{center}
\parbox{11cm}
{
но как это далеко от итераций алгоритма Евклида! Зато первый
метод дает те сведения, которые не дает второ
}
\end{center}

Вот второй  аргумент,  доказывающий,  что  $r_{6}$ = 11 есть НОД$(a,b)$. 
Хотя он очень похож на первый, приведенный выше аргумент, но имеет 
одно преимущество.  Он  выделяет  незамеченное  в  прошлом  понятие,  а именно \textit{соотношение Безу}.
Заметим, что $bq + г$ и $b$ — линейные комби­нации $b$ и $r$
  и наоборот  (речь идет о линейных комбинациях с коэффи­
циентами из $\mathbb{Z}$).

Если обозначить через $\mathbb{Z}(bq+r)$ +  $\mathbb{Z}b$ множество линейных комбина­
ций $bq + г$ и $b$ с коэффициентами из $\mathbb{Z}$, то получим равенство множеств 
$\mathbb{Z}(bq + r)$ +$\mathbb{Z}b$ = $\mathbb{Z}b+\mathbb{Z}r$.
 Множества $\mathbb{Z}_{{r}_{i}} + \mathbb{Z}_{{r}_{i+1}}$  являются одними и теми 
же. В частности, имеем $\mathbb{Z}_{{r}_{i}}a Za + \mathbb{Z}_{{r}_{i}}b=\mathbb{Z}_{{r}_{i}} r$,
  что соответствует отношениям 
$r_{6}$ | $a$, $r_{6}$ | b и $r_{6}$ $\in$ $\mathbb{Z}a$ $\mathbb{Z}b$
$\mathbb{Z}a + \mathbb{Z}b$.
 Используя существование  целых чисел $u$ и $v$
(которые мы и не старались вычислить),  получаем $r_{6} = ua + vb$.
  Легко 
проверить,  применяя последнее  равенство,  что $\delta$  | $r_{6}$  равносильно $\delta$ | $a$ и 
$\delta$ | $b$.
 Это снова доказывает,  что $r_{6}$ = НОД$(a,b)$
 \begin{center}
 \parbox{11cm}
 {
 	\textbf{Замечание}.  Сложение оставляет на месте множество $\mathbb{Z}b$+$\mathbb{Z}r$. То
же верно для умножения на элементы из $\mathbb{Z}$.
 Математики называ­ют такое множество идеалом. Это основное понятие, к которому
мы будем неоднократно обращаться в дальнейшем.
 }
 \end{center}
 Надо отметить  последний  важный  пункт,  который  позволяет  убе­
диться,  что все лицеисты  Франции  и  Наварры  находят тот  же  самый 
результат,  когда  вычисляют  НОД  с  помощью  первого  метода.  Пра­
вильность их  метода основывается  в  действительности  на следующем 
результате  (и это еще надо доказать):

\noindent \textbf{(1)Теорема} основная теорема арифметики

\textit{Всякий элемент из $\mathbb{N}$* разлагается на 
простые множители.  Это раз­
ложение однозначно с точностью до порядка простых сомножителей.}
\newline

Теперь  декорации готовы. В  последующих сценах мы  введем и свя­
жем различные концепции: евклидово деление, НОД, соотношение Везу, 
разложение на простые  множители,  идеалы...
\section{Обобщение арифметики целых чисел}
\noindent Мы  коснемся  теперь  общих  понятий  теории  делимости.  Это  предпо­
лагает  введение  точных  определений  основных  понятий,  без  которых 
математик не может работать, и выявление их основных свойств.  Что­
бы избежать появления длинного списка определений/утверждений, мы
\pagebreak
выбрали  в  этом  разделе  конкретный  пример  для  изучения  — кольцо 
целых чисел Гаусса, сообщая предварительно минимальное количество 
сведений,  позволяющих  работать с  этим  объектом.  Другие  результа­
ты, относящиеся к свойствам делимости, будут изложены в следующем 
разделе.

Сразу же  уточним, что определения,  которые последуют,  ориенти­
рованы  на теорию  делимости,  отдающую предпочтение  элементам.  В 
общих чертах будут рассмотрены  алгебраические  структуры,  в  кото­
рых 
\textbf{основная  теорема  арифметики} 
справедлива для  их 
\textbf{элемен­тов}. 
Существуют  и  другие  теории  делимости  (кольца Дедекинда),  в 
них основная теорема арифметики справедлива для 
\textbf{идеалов}.
\subsection{Делимость и неприводимые элементы}

\noindent \textbf{(2) Определение}
Элемент  \textit{х}   коммутативного  и   унитарного\footnote{В  этой  книге  (за исключением беглого упоминания других ситуаций) все рас­
сматриваемые кольца предполагаются коммутативными и унитарными (т.е. 
с
 еди­
ницей. — 
Прим. ред).
 Добавим, что для «хорошей» теории делимости кольца долж­
ны быть целостными. Можно было бы попытаться ограничится только целостными
кольцами, но такая точка зрения чересчур стеснительна в отношении таких поня­
тий,  как  нётеров характер, простой идеал или  максимальный идеал...  Использо­
вание  свойства целостности  (без  делителей  нуля)  или  необязательно целостности
будет уточняться по мере необходимости.}
  кольца  А   называется
\textbf{единицей} 
А   и л и  обратимым в   А ,  если  найдется  такой элемент  $у \in А$,
что $ху  =  ух$ =  1. 
Множество  всех единиц в   А   является
 \textbf{мультиплика­тивной группой} 
и  обозначается $U(A)$
\newline

\noindent \textbf{(3) Определение}

$(i)$  Элемент  $а$  кольца  $А$   делит  $b$  (в  $A$ ),  если  существует  $c$  $\in$   $A$   та­
кой,  что  $Ь  =  са$.  Будем   говорить  также,  что  $b$  кратно  $a$,  и   отмечать
этот  факт  в   виде  $a$  |  $b$;  или,  если  хотим  уточнить  кольцо  $A$ ,  $a|_{A}b$.
Это  свойство делимости может быть эквивалентным образом выраже­
но  в   терминах  идеалов  (обратим  внимание  на  перевернутость  «$\subset$»  по 
отношению к «I») 
следующим  образом: $a$  |  $b$ эквивалентно $Ab \subset Aa$.

$(ii)$ Заметим 
относительно свойства делимости «|»,  что два элемента
$a$  и  $b$,  удовлетворяющие равенству $Aa=Ab$,  неразличимы .  Это отноше­
ние между $a$ и  $b$ является эквивалентностью. В  этом случае мы говорим,
что $a$  и  $b$
 ассоциированные 
элементы,  и  применяем запись $a ~ b$ ,   или,
если требуется уточнить кольцо $A$ ,  
$a \sim_{A}b$ .  Если кольцо $A$  без делителей
\newpage
