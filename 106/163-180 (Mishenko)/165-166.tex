Итак, разложение по убыванию степеней многочлена, стоящего в произведении
слева, дает меньшую сложность, нежели если разлагать тот же самый многочлен
в обратном порядке: квадратичную в лучшем случае (плотный многочлен справа),
или кубическую в худшем случае (плотный многочлен слева и разреженный справа).
В любом случае разложение в порядке убывания степеней дает большую сложность.\newline

\noindent\textbf{33. Действия с формальными рядами}\newline

\textbf{a.} Формула $(\sum a_iX^i)^2 = \sum a_i^2 X^{2i} + \sum_{i < j}2a_i a_j X^{i+j}$ позволяет констатировать,
что вычисления квадрата ряда возможно и, что для вычисления $n$-го коэффициента
формального ряда, являющегося результатом, необходимо $n$ начальных коэффициентов исходного ряда. Более точно, вот список итераций для осуществления чтения $i$-го коэффициента:

(\textit{i}) вычислить

\begin{equation*}
S_i = a_i X^{2i} + 2 \sum_{\substack{0 \leqslant j < i}} a_i a_j X^{i+j}
\end{equation*}
(тогда \small{$\sum$}$^2 = S_0 + S_1 + S_2 + \cdots$),

(\textit{ii}) прибавить $S_i$ к многочлену (вычисленному с использованием $i - 1$ первых слагаемых),
аппроксимирующему формальный результирующий ряд,

\textit{iii} вывести $i$-й коэффициент результирующего ряда; этот коэффициент
больше не будет участвовать в последующих вычислениях.

То, что было описано, есть теоретический алгоритм, показывающий выполнимость
вычисления квадрата формального ряда. Осталось предложить программу,
осуществляющую эти вычисления: структуру данных, управление, переменные и т.д.

Как ясно из предыдущего описания, исходный формальный ряд, коэффициенты которого
читаются последовательно, надо представить динамической структурой - например,
в виде списка, состоящего из пар коэффициент-степень (в действительности,
в стек помещается не исходный ряд, а его копия, эффективность обязывает!).
По причине однородности, коэффициенты вычисляемого ряда размещают списком,
аналогичным коэффициентам, частично вычисленным. Для манипулирования этими
списками используются примитивы, введенные в упражнении 30. Каждый список,
участвующий в алгоритме, представляет многочлен, аппроксимирующий формальный ряд, мономы которого
упорядочены по возрастанию ( начиная со слагаемых наименьшей степени в списке).
\newpage

\begin{lstlisting}[mathescape=true, caption=Квадрат формального ряда, language=Ada]
$\textbf{input}$ a;
$Square\_Of\_A \leftarrow a^2 X^0; Double\_A \leftarrow 2aX^0; aux \leftarrow 0; i \leftarrow 0;$
$\textbf{output}$ $a^2 X^0$;
loop
  //$\text{deg}(Double\_A) \leqslant i, \text{deg}(Square\_Of\_A) \leqslant i, \text{deg}(aux) \leqslant 2i, \text{ord}(aux) \geqslant i$
  $\textbf{input}$ a;
  $i \leftarrow i + 1; aux \leftarrow aux + (aX' \times Double\_A) \oplus a^2 X^{2i}$;
  $\textbf{output}$ $First(aux)$;
  $Double\_A \leftarrow Double\_A \oplus 2aX'$;
          $Square\_Of\_A \leftarrow Square\_Of\_A \oplus First(aux);$
  $aux \leftarrow Tail(aux)$;
end loop;
\end{lstlisting}

В алгоритме 19 символ «ord» обозначает порядок формального ряда
(т.е. степень монома наименьшей степени). Символ $\oplus$ обозначает формальное
сложение многочлена и монома степени, превосходящей степень многочлена
или не превосходящей порядка многочлена, что с практической точки зрения
означает добавление элемента к началу или к концу списка. Кроме того,
обозначение $2aX^i \times Double\_A$ означает список, в котором элемент с номером $j$
является произведением элемента с тем же номером в списке $Double\_A$ на моном $2aX^i$.
Примитивы \textbf{input} и \textbf{output} — это основные примитивы алгоритма, работающего с потоком
данных: входные данные, полученные благодаря примитиву \textbf{input}, в принципе, порождают
результат, выводящийся с помощью примитива \textbf{output}. Заметим в заключение, что запоминание
результирующего формального ряда $Square\_Of\_A$ не является необходимым для алгоритма.

\textbf{b.} Определим производную формального ряда $\mathcal{B} = \mathcal{A}^n$, полученную по правилу $\mathcal{B}' = n\mathcal{A}'\mathcal{A}^{n-1}$.
Если это выражение умножить на $\mathcal{A}$, то получим $\mathcal{AB}' = n\mathcal{A}'\mathcal{B}$. Теперь можно почленно сопоставить
оба формальных ряда: $\mathcal{AB}'$ и $\mathcal{A}'\mathcal{B}$. Для члена степени $i - 1$ получим
$ia_0 b_i + \sum^i_{j=1} (i-J)a_j b_{i-j} = n\sum^i_{j=1} ja_j b_{i-j}$, что дает нам формулу для вычисления $b_i$
\begin{equation*}
b_i = \frac{1}{a_0 i} \sum\limits^i_{j=1}((n + 1)j - i)a_j b_{i-j};
\end{equation*}
она позволяет вычислить очередное значение. Детали эффективного алгоритма,
осуществляющего вычисление $\mathcal{A}^n$, оставляются читателю.