\documentclass{mai_book}

\defaultfontfeatures{Mapping=tex-text}
\setdefaultlanguage{russian}

%\clearpage
%\setcounter{163}{} % ВОТ ТУТ ЗАДАТЬ СТРАНИЦУ
% Эти счетчики достаточно задать один раз, обновляются дальше сами
 \begin{document}
 
\par Первая функция {\it Multiply-M-By} позволяет умножать произвольный
одночлен на параметр {\it М} функции {\it Multiply}, вторая функция — кон­
кретизация на этом преобразовании данного итеративного цикла —
дает искомый результат. Следует заметить, что в этом контексте не­
возможно выполнить конкретизацию вне функции {\it Multiply}, потому что
она зависит от одного из аргументов этой функции. Это цена, которую
приходится платить за модулярность множества. Кроме того, реали­
зация функции {\it Multiply-M-By} существенно использует целостность ис­
ходного кольца; без этого предположения было бы необходимо отдельно
рассматривать случай, когда произведение двух коэффициентов равно
нулю, что значительно усложнило бы алгоритм.
\par Имея эту элементарную функцию перемножения, можно теперь ре­
ализовать умножение многочленов в общем случае. Но, учитывая слож­
ность алгоритма сложения, рассмотренного ранее, представляется ло­
гичным сделать так, чтобы в процессе последовательных сложений
структурное разбиение было бы как можно более протяженным. Рас­
смотрение умножения двух многочленов, представленных в упражне­
нии 29, показывает, что многочлен {\it Р} , по которому разлагают про­
изведение в ряд последовательных умножений, должен пробегаться в
порядке возрастания степеней одночленов, тогда как представление в
виде списка облегчает скорее противоположное направление чтения.
Так, максимизируя структурное разделение, минимизируют сложность
прохода списков, представляющих отдельные многочлены-слагаемые.
Надо заметить, что нижеприведенная функция будет встроена в тело
пакета управления многочленами и что, как следствие, она может ис­
пользовать внутреннюю структуру многочленов.

\begin{lstlisting}[mathescape=true, language=Ada, basicstyle=\small]
function Multiply (P : Polynomial; Q : Polynomial)
$\qquad$ $\quad$ return Polynomial is
$\quad$ RP : Polynomial := Reverse (P); R : Polynomial := Zero;
begin
$\quad$ while not Is_Null (RP) loop
$\qquad$ R := R + Multiply (Head (RP).The_Monomial, Q);
$\qquad$ RP := Tail (RP);
$\quad$ end loop;
$\quad$ return R;
end Multiply
\end{lstlisting}

\par Можно дать оценку сложности этого алгоритма умножения двух
многочленов в нескольких частных случаях, рассматривал процесс ум-
\newpage

\begin{wrapfigure}{l}{0.5\textwidth} %$a_{4}X^{\alpha _4}Q\\
%\hbox to 3 cm{\qquad\leaders\hbox{$\cdot$}\hfill }$
\hspace*{140.pt}\underline{$a_{1}X^{\alpha _1}Q$}\newline
\hspace*{100.pt}\underline{$a_{2}X^{\alpha _2}Q$}$\\
\hspace*{80.pt}\hbox to 4 cm{\qquad\leaders\hbox{$\cdot$}\hfill }$\newline
\hspace*{100.pt}\underline{$(a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q$}\newline
\hspace*{60.pt}\underline{$a_{3}X^{\alpha _3}Q$}$\\
\hspace*{40.pt}\hbox to 5 cm{\qquad\leaders\hbox{$\cdot$}\hfill }$\newline
\hspace*{60.pt}\underline{$(a_{3}X^{\alpha _3} + a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q $}\newline
\hspace*{20.pt}\underline{$a_{4}X^{\alpha _4}Q$}$\\
\hbox to 7 cm{\qquad\leaders\hbox{$\cdot$}\hfill }$\newline
\hspace*{20.pt}\underline{$(a_{4}X^{\alpha _4} + a_{3}X^{\alpha _3} + a_{2}X^{\alpha _2} + a_{1}X^{\alpha _1})Q$}\newline

\end{wrapfigure}


\noindent
ножения на приведенной сле­ва схеме. В этих примерах так называемый левый много­член является тем, по кото­
рому осуществляется разложе­ние в произведение двух мно­гочленов. Первый случай со­ответствует умножению Р на Q, когда последний многочлен, является плотным, т.е. образо­ван из мономов с последова­тельно идущими друг за другом степенями. Начинают со сложения двух
мономов $a_{1}X^{\alpha _1}Q$ и $a_{2}X^{\alpha _2}Q$; для этого нужно лишь пробежать список,
представляющий второй моном, и сложение завершается присоедине­
нием конца первого монома. Затем это повторяется, когда добавляют
многочлен $a_{3}X^{\alpha _3}Q$  к только что полученному результату; при этом пробегают только этот последний моном, и т.д. Следовательно, каждое
сложение имеет сложность, заключенную между $\#Q$ и $2\#Q$. Так как это
повторяется для всех мономов из $Р$, в целом для алгоритма умножения
получается сложность, пропорциональная $\#P \times \#Q$.
\par Можно рассмотреть произведение левого многочлена $ P =\sum^{p-1}_{i=0}a_{i}X^i$ на правый $Q =\sum^{q-1}_{j=0}b_{j}X^{j} $, которое даст нам максимальную сложность
произведения произвольного многочлена на плотный многочлен. Здесь
на каждой итерации (или промежуточном сложении) получают слож­
ность пробега $2q — 1$; с учетом повторений для всех мономов из $Р$ это дает общую сложность пробега $(р— 1)(2q — 1)$. Пример, дающий нижнюю
границу сложности для произведения этого типа, получается вычисле­
нием $RQ$ , где $R =\sum^{r-1}_{k=0}c_{k}X^{kq}$. На каждой итерации сложность пробега
равна $q$, что дает общую сложность пробега $(r - 1)q$.
\par В первом примере для произведения $PQ$, если бы разлагать мно­гочлен $P$ по убывающим степеням, то последовательно получали бы:$q + (q - 1), (q + 1) + (q - 1), ..., (q + p - 2) + (q - 1)$ и в целом $(p - 1)(2q - 1) + (p - 2)(p - 1)/2 $. Для второго примера последовательные пробеги
оценивались бы $q, 2q, 3q, ..., (r - 1)q$, и в целом $r(r - 1)q/2$.
\par Другой типичный случай: многочлен, стоящий в произведении спра­ва, является разреженным, а тот, который слева, — плотным (пример
произведения $QR$). Принцип пробега, описанный в схеме, остается в
силе, с той лишь разницей, что высота промежуточного результата
удваивается на каждой итерации, что дает сложность пробега, равную
$r + (r - 1) + r + (2r - 2) + r + (3r - 3) + ... + r + (q - 1)(r - 1)$, т.е. $(q - 1)r + q(q - 1)(r - 1)/2$. Разложение левого многочлена $Q$ по убыванию степеней даёт точно такой же результат.
 
 
 \end{document}