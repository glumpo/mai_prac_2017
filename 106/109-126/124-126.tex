Чтобы подтвердить конечность метода, нужно определить для целого $r$,
когда $e(r) = 1$. Ясно, что $e(r) = 1$ тогда и только тогда, когда для всякого
простого $q \sqrt[q]{r} \notin \mathbb{N}$; но если $r < 2^q$, всегда имеем $\sqrt[q]{r} \notin \mathbb{N}$.
Следовательно, имеем $e(r) = 1$ тогда и только тогда, когда $\sqrt[q]{r} \notin \mathbb{N}$ для всякого простого $q \leqslant \lfloor\log_2{r}\rfloor$.

\begin{lstlisting}[mathescape=true, language=Ada, caption=Вычисление корня из целого числа]
$e \leftarrow 1; r \leftarrow n; p \leftarrow 2$
while $p \leqslant \lfloor\log_2{r}\rfloor$ loop
  //$r^e = n, p\: - \text{простое}, \sqrt[q]{r} \notin \mathbb{N},\: q\: \text{простое} < q$
  $i \leftarrow 0$
  loop //$r^{ep^i} = n$
  $r' \leftarrow \sqrt[p]{r}$
  exit when $r'^p \neq r$
  $r \leftarrow r'; i \leftarrow i + 1$
  end loop
 $e \leftarrow ep^i; p \leftarrow Next\_prime(p)$
end loop
//$ r^e = n,\sqrt[q]{r} \notin \mathbb{N}, q\: \text{простое } \leqslant\log_2{(r)},\: \text{значит}\: e(r) = 1$
return ($r,\:e$)
\end{lstlisting} 

В цикле этого алгоритма изменяются две величины: простое $p$ возрастает
и \textit{остаток} $r$ целого $n$ убывает. При выходе из цикла имеем $r^е = n$, и ни для
какого простого $q \leqslant \lfloor\log_2{r}\rfloor$ число $r$ не является корнем $q$-й степени; как следствие,
в соответствии с выводами предыдущего абзаца $e(r) = 1$.

Все числа из интервала $[0, 2^{1009})$ могут быть \textit{уменьшены} этим алгоритмом с использованием
только простых чисел, меньших 1000. Конечно, можно применить алгоритм к числам, расположенным
вне этого интервала, но тогда получаемый с помощью алгоритма результат крайне ненадежен при отсутствии
дополнительной информации по рассматриваемому числу.\newline

\noindent\textbf{6. Порождение простых чисел}\newline

\textbf{a.} Для этого алгоритма используем таблицу целых чисел, которая содержит
все уже вычисленные простые числа и которая возникает по мере вычислений.
Что касается доказательства корректности этого алгоритма, то можно удовлетвориться
рассмотрением того, что происходит в самом внутреннем цикле, который проверяет $Candidate$ на простоту.
\newpage

В этом тесте (алгоритм 6) просматривается последовательность уже вычисленных
простых чисел и делается остановка, как только квадрат одного из них превосходит $Candidate$:
действительно, в произведении двух нетривиальных множителей один из них меньше
квадратного корня из этого числа (обычный критерий остановки решета Эратосфена).

Если обнаруживается простое число, которое делит $Candidate$, то последний объявляется непростым,
и цепочка циклов делает переход к проверке следующего нечетного числа. Зато,
если $Candidate$ преодолевает все простые числа, то он — простое число; в этом случае
выходят из цикла $Searching\_For\_Next\_Prime$, как только выполнено условие $p^2_i > Candidate$
в силу предыдущего замечания; найденное простое число помещается в таблицу.

\begin{lstlisting}[mathescape=true, language=Ada, caption=Генерация простых чисел]
$p_1 \leftarrow 3; Candidate \leftarrow 3;$
for $k$ in 2 .. $n$ loop
  $Searching\_For\_Next\_Prime:$ loop
    $Candidate \leftarrow Candidate + 2; i \leftarrow 1$;
    loop
      exit $Searching\_For\_Next\_Prime$ when $p^2_i > Candidate$;
      exit when $Candidate\: \text{mod}\: p_i = 0$;
      $i \leftarrow i + 1$;
    end loop;
  end loop $Searching\_For\_Next\_Prime$;
  $p_k \leftarrow Candidate$;
end loop;
\end{lstlisting}

Несмотря на все аргументы здравого смысла, которые позволили
провести неформальное доказательство этого алгоритма, это доказательство
неполно. Действительно, условие остановки $p^2_i > Candidate$ имеет смысл, только если отныне и впредь в таблице имеется простое число, удовлетворяющее этому неравенству. Можно избежать этой проблемы, заменяя условие выхода из цикла $Searching\_For\_Next\_Prime$ на\newline

\textbf{exit} $Searching\_For\_Next\_Prime$ \textbf{when} $i \geqslant k$ \textbf{or else} $p^2_j > Candidate$\newline

В этом случае применяется чистый аргумент Эратосфена. Но в действительности
эта модификация бесполезна, так как постулат Бертрана говорит нам,
что такое $p_i$ уже вычислено. Почему? Ответ находится во втором вопросе,
с другими оптимизациями, но здесь нужно немного поразмышлять...
\newpage

\textbf{b.} Обратимся к переменной $Ord$, которая определяет номер наименьшего простого числа,
квадрат которого превосходит $Candidate$ и вторую переменную $Square$, которая имеет
значение этого квадрата. Когда нужно менять эти переменные? Когда кандидат
превосходит $Square$! Это означает, что $Candidate \geqslant p^2_{Ord}$, а поскольку задействованные
числа — нечетные, в действительности имеем равенство. Итак, непосредственным следствием
постулата Бертрана является соотношение $p_{i+1} < p^2_i$ (что попутно доказывает корректность алгоритма \textbf{a}).
Следовательно, когда величина первого кандидата достигает $p^2_{Ord}$, имеем уже вычисленным $p_{Ord} + 1$,
и изменение переменных $Square$ и $Ord$ возможно. Кроме того, поскольку кандидат является
квадратом простого числа, он — непростое число. Это приводит нас к модификации (алгоритм 7) метода из вопроса \textbf{a}.

\begin{lstlisting}[mathescape=true, language=Ada, caption=Генерация простых чисел (оптимизация)]
$p_1 \leftarrow 3; Candidate \leftarrow 3; Square \leftarrow 9; Ord \leftarrow 1$;
for $k$ in 2 .. $n$ loop
  $Searching\_For\_Next\_Prime$: loop
    $Candidate \leftarrow Candidate + 2$;
    if $Candidate = Square$ then
      $Ord \leftarrow Ord + 1; Square \leftarrow p^2_{Ord}$;
      $Candidate \leftarrow Candidate + 2$;
    end if;
    $i \leftarrow 1$;
    loop
      exit $Searching\_For\_Next\_Prime$ when $ i > Ord$;
      //$Candidate < Square = p^2\_{Ord}\: \text{и}\: I \leqslant Ord$
      exit when $Candidate\: \text{mod}\: p_i = 0$;
      $i \leftarrow i + 1$;
    end loop;
  end loop $Searching\_For\_Next\_Prime$;
  $p_k \leftarrow Candidate$;
end loop;
\end{lstlisting}

Окончательный алгоритм — с несколькими дополнительными оптимизациями — был, кажется,
представлен впервые Далом, Дейкстрой и Хоаром [58]; его можно найти также у Кнута [101] и Верса [182].
В заключение заметим, что для нас постулат Бертрана является теперь теоремой.