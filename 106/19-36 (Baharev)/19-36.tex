%\documentclass{mai_book}
%\defaultfontfeatures{Mapping=tex-text}
%\setmainfont{DejaVuSerif}
%\setdefaultlanguage{russian}
%\usepackage{amsmath}
%\usepackage{floatflt}
%\usepackage{wrapfig,lipsum,booktabs}
%\begin{document}

	\noindent совершенно чужд этот предмет; однако, возможно, он будет удивлен не­
	обычным  подходом  в  математике.  В  информатике не редкость,  когда 
	формулировка проблемы  бывает такой  же  длинной, как  и  ее  решение.

	В книге приведены несколько полных программ; они предназначены 
	не для  «производственных целей»,  а для построения  поучительных при­
	меров. И хотя мы не включили все программы, реализующие описанные 
	методы,  — книга бы  просто  лопнула...  такж е,  как  и  наш  издатель  — 
	тем  не  менее,  все  описанные  методы  реализованы  или  на  языке  Ада, 
	когда  имевшиеся  в  нашем  расположении  средства  это  позволяли,  или 
	в среде системы формализованных вычислений  Scratch pad. Эта систе­
	ма была выбрана не за cвои мнимые достоинства или за как будто бы 
	богатое программное обеспечение, а исключительно потому, что она 
	была нам доступна и позволяла умножать числа с 100 знаками. И ес­
	ли слабость и неадекватные реакции ее компилятора довольно быстро 
	обескуражили одного из авторов, то другой еще продолжает борьбу.
	
	Мы должны особо упомянуть наш основной источник вдохновения 
	—  монументальный труд Дональда Кнута «Искусство программиро­вания».
	  Часто нам случалось самостоятельно или в процессе чтения 
	открыть
  	некий  новый  алгоритм; так  вот,  мы  можем  утверждать,  что 
	более,  чем  в  70\%  случаев,  оказывалось,  что  этот   алгоритм  уже  был 
	описан  в  его  книге  и  чаще  всего  гораздо  лучше, чем там , где мы  его 
	нашли.  Мы  не  можем  упоминать  Кнута  на  каждой  странице,  где  явно 
	присутствует  его  вклад,  ибо его  имя  появлялось бы  сотни  раз.  Мы это 
	делаем здесь.
	
	Помимо этой  серии  книг,  еще  не  оконченной  в  настоящий  момент, 
	Кнут также  реализовал — чтобы  иметь  возможность  точного написа­
	ния  своих  книг  —  компилятор  текстов 
	поистине  феноменальной 
	мощности.  Эта  книга  смогла  быть  написана  ее  авторами-любителями 
	благодаря Кнуту  и  многочисленным  бессонным  ночам  в  попытках  по­
	нять внутренние механизмы \TeX 'a.  Без  \TeX 'a мы никогда бы не смогли 
	реализовать  нашу  книгу  в  данном  виде.  И  вот  теперь  мы  можем,  на 
	манер  Кнута,  сказать: 
	\textit{If this book has any merit,  the credit should go to
	Knuth...  On the other hand, if this book has deficiencies,  the biaim should
	be directed to us ...} \footnote{Если эта книга имеет достоинства, это заслуга Кнута... С другой стороны,
	если в этой книге есть недостатки, то упрек должен быть адресован нам,..}

	Даниель  Лазар  и  Франсис  Сержераер  первыми  связали математи­
	ку и информатику в процессе преподавания в Пуатье. Мы им обязаны 
	определенной концепцией преподавания этих дисциплин и считаем сво­
	им долгом поблагодарить их здесь.	
	
	\pagebreak
	Эта книга не является творением двух отдельных личностей; мы 
	пользовались советами  наших  многочисленных  коллег.  Мы  особенно 
	благодарны Пьеру Берна, Жан-Мари Гурсо, Жан-Луи Паско, Мустафе 
	Раису, Ги Рено и Жаку Валетту; мы обязаны не только идеями упраж­
	нений, доказательств, но также и другой точкой зрения на ряд мето­
	дов,  излагаемых  в этой  книге.  Мы  благодарим такж е сотрудников фа­
	культета математики  и  информатики университета Пуатье.  В течение 
	всех тех лет,  когда шла работа над  книгой, мы ощущали их поддержку 
	и  симпатию.  Успешное  продвижение  проекта  было значительно облег­
	чено  предоставлением  места  работы  в  лаборатории  первому  автору и 
	\textit{творческого} отпуска —  второму.
	
	Мы  не  забываем  студентов  специального  курса  «Информатика для 
	математиков»,  которые  на протяжении  многих лет  вносили  различные 
	поправки  и  предлагали  идеи.
	
	Мы  не  можем  на  этом закончить,  чтобы  не  подмигнуть Жаку Бо 
	-ровчику,  без  которого  не  осмелились  бы  написать  эту  книгу,  а также 
	Жан-Пьеру  Раду,  виновному  за   выбор  языка  Ада,  Ливью  Соломону, 
	дававшему  нам  советы  по  разным  случаям,  и  Бернару  Гарро,  который 
	неотлучно  был  с  нами  в течение  всей  этой  работы.
	
	Что же  касается  якобы очень  взаимообогащающей  работы  вдвоем, 
	то это не всегда было очевидным, и проблемы не всегда были столь 
	же просты, как эта: << — Почему ты  вставляешь цитаты  по-английски? >>
	Некоторые  читатели  не  поймут.  — Я  предпочитаю  оригинальную  вер­
	сию, которая содержит в себе порой непереводимый  юмор. — Ну, а как 
	насчет цитат на немецком?  —  Ну это совсем другое дело. Я не знаю 
	немецкого».
	
	Эта  книга посвящается всем нашим друзьям, которые нас поддер­
	живали и мирились с нашим переменчивым настроением в течение этих 
	трех сумасшедших лет.
	\chapter{Алгоритмика и \newline программирование на \newline языке Ада}
	\noindent В этой главе — вероятно самой «информатической» в нашей книге —
	мы введем некоторые алгоритмические понятия и опишем несколько
	получисленных алгоритмов, необходимых для реализации алгебраиче­
	ских методов.
	
	Точное определение алгоритмических границ, в которых будут из­
	ложены методы вычисления, станет предметом особого внимания. Цель
	нашего труда не ознакомить с основами алгоритмики — предполага­
	ется, что читатель не новичок в данной области, — а определить без­
	укоризненным способом семантику построений, используемых в алгоритмах\footnote{Что совсем не умаляет ни корректность (верность) программ, которые можно
	будет потом получить, ни соответствие компилятора его спецификациям. Эти усло­
	вия,  однако, необходимы для  истинности математической теоремы,  доказанной с
	помощью компьютера.}.
	
	После изложения общих направлений мы приступим к исследова­
	нию первого фундаментального алгоритма этой книги: дихотомиче­
	ского алгоритма возведения в степень. Для этого будут использоваться
	два метода построения алгоритмов. Один очень близок к математиче­
	ским рассуждениям, другой — чисто алгоритмический. При этом у нас
	появится возможность открыть первый рекурсивный алгоритм, пред­
	ставленный в данной работе.
	
	Начав с первого примера алгоритма, мы перейдем к изучению на­
	чальных понятий программирования на языке Ада. И здесь тоже речь
	пойдет не об изложении полного курса языка Ада, а только о пред-
	
	\pagebreak
	\noindent ставлении нескольких ключевых понятий, необходимых для понимания
	приведенных программ.
	
	Вообще говоря, все понятия будут представлены (по мере надоб­
	ности) на примерах, во избежание их формального описания (по по­
	следнему вопросу лучше обратиться к справочному изданию: Reference
	manual for the Ada programming language\footnote{См. книгу [186]. — Прим, перев.} ).
	
	И наконец, завершит эту главу разработка совершенно неэффек­
	тивного метода вычисления определителей целочисленных матриц. Об­
	суждаемый метод, основанный на математическом определении детер­
	минанта, позволяет наилучшим образом использовать все возможности
	современных компьютеров и получить идеальное приближение к беско­
	нечности на машине! Кроме того, обсуждение ситуации позволит нам
	несколько пополнить представление о программировании на языке Ада.
	
	\section{Введение в алгоритмику}
	\noindent Прежде чем приступить к описанию любого алгоритма, нужно ого­
	ворить общепринятые соглашения, используемые в работе. В инфор­
	матике чаще, чем в любой другой дисциплине, встречается взаимное
	непонимание между пользователем и разработчиком новых программ.
	Поэтому так важно сформулировать аксиоматику, позволяющую связ­
	но рассуждать об алгоритмах.
	
	Множество аксиом, которое мы собираемся сейчас описать, извест­
	но как \textit{аксиоматика Хоара} [86], в честь исследователя, который первым
	формализовал семантику структур и действий последовательной алго
	ритмики.
	
	\subsection{Терминология и обозначения}
	
	\noindent \textbf{Алгоритм} — это последовательность более или менее элементарных
	действий, которая позволяет пошагово решить поставленную задачу за
	конечное время. Можно формально по индукции определить, что та­
	кое алгоритм, нижеследующим образом. Цель этого введения в алго­
	ритмику — изучение и представление всех терминов, фигурирующих в
	предыдущем определении (стиль определения, который в информатике
	называется \textbf{грамматикой}).
	
	Можно описать алгоритм в терминах состояний системы: состояние
	системы до применения алгоритма, состояние той же системы после
	\pagebreak
	
\noindent применения алгоритма. Эти два состояния образуют то, что называет­
ся спецификацией задачи. Таким же образом можно, описывая поэ­

\begin{wraptable}{i}{0.55\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\textbf{\begin{tabular}[c]{@{}l@{}}
	\text{$                  $} \\
	$\bullet$ Алгоритм — это действие \\
 	$\bullet$ Действие — это:\\
 		--- элементарное действие\\
 		--- последовательность действий\\
 		--- альтернатива \\
 		--- итерация\\
 	 $\bullet$ Элементарное действие — это:\\
 		--- пустое действие\\
 		---присваивание  —  ...\end{tabular}}} \\
	\text{$                  $} \\
\hline
\end{tabular}
\end{wraptable}
\noindent тапно последовательные состоя­ния\linebreak
(между действиями) рассма­
триваемой системы, проводить обоснование алгоритма. Систе­
ма доказательства по Флой­ду [71] — это способ формализа­
ции данного процесса. Но эта ак­сиоматика не просто метод дока­
зательства: в случае ее обобще­ния она может претендовать на роль хорошей методологии програм
мирования.
\newline

Состояния данной системы выражаются в виде утверждений, т.е.
логических формул. Рабочие гипотезы алгоритма называются
предусловиями или данны ми алгоритма. Заключения называются
постусловиями или результатам и. Вот, например, способ
формального описания алгоритма:
\begin{center}
[предусловия] Алгоритм [постусловия]
\end{center}
И это то, что можно назвать \textbf{спецификацией} алгоритма. Используя 
данную форму выражений, можно описать аксиомы Хоара в следующем 
виде:
\newline
\noindent $\vartriangleright$ \textit{Посылки} : предварительные условия к применению аксиомы. Эти 
условия  выражаются,  в  основном,  в  терминах  преобразований  утвер­
ждений посредством некоторых действий.
\newline
$\vartriangleright$ \textit{Заключение} : результат построения, которым описывают аксиому.
\subsection{Присваивание}
\noindent Это элементарное  действие,  наиболее опасное  и  наиболее трудное  для 
понимания  в  последовательных  алгоритмах.  Его  семантика  чрезвы­
чайно  проста:  переменной  (иногда очень  сложной)  придают  значение 
какого-либо выражения.  Действие  присваивания  представляется  в  ал­
горитмах, как правило, двумя способами: обычно с помощью стрелки, 
направленной  влево,  а  иногда  последовательностью  знаков  «:=»,  как, 
например, в языках программирования.
\newline
\textbf{(1) Аксиома} (присваивания).
\newline
$\vartriangleright$ \textit{Посылки: х является переменной,  e  —  выражением}
\newline

\noindent $\vartriangleright$ \textit{Заключение: [] х $\leftarrow$ е [x = значению е]}
\pagebreak

Интерпретация  этой  аксиомы  следующая:  нет  никакого  предусло­
вия,  кроме  природы  его  операндов,  для  использования  присваивания. 
Каково  бы  ни  было состояние  системы,  сведенной  к  переменной х,  по­
сле выполнения присваивания х будет иметь то же самое значение,  что и е.

Если задействовано несколько переменных,  то иногда форму посту­
словия  присваивания  модифицируют.  Возьмем,  например,  систему,  со­
стоящую  из  двух  переменных х  и у,  предположим  к  тому  же,  что у
имеет значение  е.  Выполним предыдущее  присваивание. В предусловие 
можно включить  переменную у,  хотя она не  входит в присваивание.  В 
результате  имеем:  [у =   е].  Довольно часто  вместо  того,  чтобы писать 
постусловие  в  виде  [у =   е  и х  =   е],  запись  сокращают  до  [х  =   у], 
 что, разумеется,  приводит  к  исчезновению  некоторой  начальной  информа­ции.
 
Все  это  может  показаться  тривиальным,  и  обычно  совершаемая 
ошибка  состоит  в  смешении  присваивания с  частной  формой  записи 
уравнений (в математическом смысле)  или подстановкой. Простой при­
мер,  иллюстрирующий  трудность  проблемы,  относится  к  системе  из 
двух переменных  и  предыдущему  условию
\begin{equation*}
\textit{$[\Re(x,n)] n \leftarrow n + 1 [\Re(x,n - 1)]$}
	\end{equation*}
где $\Re$ - отношение,  связывающее соответствующие значения двух его 
аргументов.
\subsection{Последовательность}
\noindent Это  алгоритмическая конструкция,  заключающаяся  в соединении  дей­
ствий  в цепочку.  Ее часто представляют с помощью знака «;», который 
служит связкой  между  последовательными  действиями.  Э та конструк­
ция самая простая среди тех, которые встречаются в последовательных 
алгоритмах.

Если А и В — действия,  то обозначим  через  «А;В» действие, со­
стоящее из последовательности действий А и В в данном порядке. Э та 
горизонтальная запись обладает некоторыми неудобствами, так что 
очень часто ту же последовательность действий записывают, распола­
гая вертикально на одной прямой действия одной и той же последова­
тельности (и аннулируя, в случае необходимости, знак «;»).
\newline
\textbf{(2) Аксиома} (последовательности).
\newline

\noindent $\vartriangleright$ \textit{Посылки: А и В --- действия, P, Q и R} --- утверждения
\begin{center}
\textit{$[ P ]\textit{ }A\textit{ }[ Q ]  \text{ и } [Q]\textit{ }B\textit{ }[ R ]$}
\end{center}
\pagebreak
$\vartriangleright$ \textit{Заключение:  [Р] А; В [R]}
\newline

Эта  аксиома  просто  выражает  тот  факт,  что  в  последовательно­
сти двух действий  предусловие  второго является  постусловием  перво­
го. Иными словами, два действия одной и той же последовательности, 
следующие  одно за другим,  действуют  совместно.  Второе  использует 
результаты первого.

Вот очень простой пример, позволяющий конкретизировать преды-\linebreak
дущее  высказывание.  Рассмотрим систему,  образованную тремя цело­-\linebreak
численными переменными: \textit{C, x} и \textit{n}, и предположим, что эти перемен­-\linebreak
ные удовлетворяют следующему свойству (которое будет предусловием \linebreak
этой последовательности):\textit{$[C\times x^{n} = x_{0}^{n_{0}}]$}, где \textit{$x_{0}$} и \textit{$n_{0}$} --- две це-\linebreak
лочисленные константы. Последовательность действий, которую при­-

\begin{wraptable}{r}{0.18\textwidth}
\vspace{-20pt}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}\textit{C $\leftarrow$ C $\times$ x}\\
\textit{n $\leftarrow$ n - 1}\end{tabular}} \\ 
\hline
\end{tabular}
\vspace{-10pt}
\end{wraptable}
\noindent меняют к этой системе, представлена справа. Пре­-\linebreak
образуем сначала исходное утверждение, используя тот 
факт, что 
\noindent n > 0 и \textit{$[C\times x^{n-1} \times x = x_{0}^{n_{0}}$} и n > 0 ], и применим
первое  действие  последовательности, придав С значение, полученное 
при умножении его начального значения на х.Это выражается в пре­
дыдущем утверждении слиянием двух первых термов левого члена ра­
венства:\textit{$[C\times x^{n-1} = x_{0} и n > 0]$}. Потом, рассматривая это новое утвер­
ждение как  предусловие,  применим  второе действие, которое состоит 
в уменьшении значения \textit{n} на единицу.

Таким образом, получаем постусловие  рассматриваемой последова­
тельности действий \textit{$[C\times x^{n} = x_{0}^{n_{0}} \textit{ и } n \geqslant 0]$}. Это последнее преобразова­
ние является примером типичного случая, упомянутого в конце преды­
дущего раздела.

\subsection{Альтернатива}
\noindent Альтернатива — это структура управления,  соответствующая  приня­
тию решения в алгоритме. Ее часто выражают в виде «если ...  т о  ...». 
Во всех алгоритмах, представленных в книге, структуры управления и 
примитивные конструкции будут записаны на английском языке, в ви­
де схем, близких к языку Ада.  Этот прием имеет два важных преиму­
щества: во-первых, алгоритмы пишутся на алгоритмическом диалекте, 
приближенном к языку  программирования; и потом,  выбранный язык 
Ада чрезвычайно точен  (небольшой эвфемизм!)  и достаточно понятен 
для записи алгоритмов.

Нет необходимости объяснять действие структуры  управления.  Ее 
семантика тождественна семантике, используемой в разговорном языке.
\newline
\pagebreak

\noindent \textbf{(3) Аксиома} (Альтернатива).
\newline
$\vartriangleright$ \textit{Посылки: А и В --- действия; С --- предикат, P и Q --- условия.}
\begin{center}
\textit{[ P и С] A [ Q ]  и [Р и (не С)] B [ Q ]}
\end{center}

\noindent $\vartriangleright$ \textit{Заключение:  \textbf{if} \textit{C} \textbf{then} \textit{A} \textbf{else} \textit{B} \textbf{end if}} [ Q ]
\newline

\noindent Прежде всего эта аксиома выражает тот факт, что какова бы ни 
была  ветвь  используемого  теста\footnote{ Ветвью теста называют каждую часть альтернативной структуры: часть «то*
или часть «в  противном случае»}, получаем  один  и  тот  же  результат 
(благодаря разделению действий А и В).

Если продолжить анализ, то из этой аксиомы можно извлечь некото­
рую философию  (или  методологию)  программирования.  В  самом деле, 
можно субъективно объяснить такой подход и сделать вывод, что хоро­
шая альтернативная структура (т.е. альтернатива, простая для понима­
ния доказательства)  — это конструкция, в которой действия,  предста­
вленные  в каждом  из  ответвлений, очень  похожи.  Не редко,  например, 
можно  встретить  в  программах  начинающих,  а  также  в  работах лю­
дей  более  опытных  (что  красноречиво  свидетельствует  об  их опыте!) 
альтернативные структуры, в которых в зависимости от того, является 
истинным или ложным предикат, совершается вычисление с внутренни­
ми переменными  или выполняется действие  с промежуточным резуль­
татом (обычно на экран выводится сообщение). Конечно, эти програм­
мы  могут  быть  правильными  и,  следовательно,  вполне  доказуемыми, 
но  ценой  каких  искажений  в  изложении  алгоритма  и  в  формулиров­
ках  утверждений!  Не  говоря  уже  о  том,  какой  будет через  несколько 
месяцев степень понятности программы этого программиста! Зато хо­
роший алгоритм не содержит особенностей, сопровождается простыми 
и ясными утверждениями и потребует намного меньше затрат во время 
его возможной доработки.

В качестве примера рассмотрим следующую альтернативу, предста­
вляющую  небольшую  часть  дихотомического  алгоритма возведения  в 
степень,  который мы рассмотрим в дальнейшем.  Возьмем снова систе­
му, состоящую из трех целочисленных переменных С, х и n, удовлетво­
ряющую условию:
\begin{equation*}
\textit{$[C\cdot x^{n} = x_{0}^{n_{0}} $ и $ n > 0]$}    \eqno(1)             
\end{equation*}
Исходя  из  этой  системы  переменных,  применим  нижеследующий  эле­
ментарный   алгоритм,   который   в  основном  записывают  в   виде:
\newline
$\blacktriangleright$ \textbf{if} \text{ \textit{n нечетно }} \textbf{ then } \textit{$C$} := \textit{$C$} $\ast$ \textit{$x$}; \textbf{end if};$\blacktriangleleft$ Ключевое слово \textbf{null}
\pagebreak

\begin{wraptable}{i}{0.28\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
	\textbf{if} (\textit{n - нечетно})\\
	\text{	 С = С} $\times$ x\\
	\textbf{else} null\end{tabular}} \\
 \hline
\end{tabular}
\vspace{-10pt}
\end{wraptable}
\noindent является примитивом алгоритмического языка, 
выражающим пустое действие (для структура­
листов это действие является нейтральным эле­
ментом ассоциативной операции последователь­
ной композиции). Семантика пустого действия та­
кова (для любого утверждения Р):  [Р]  \textbf{null} [Р].

Итак, необходимо отдельно исследовать влияние действий каждой 
из двух ветвей теста на исходное утверждение, учитывая значение пре­
диката «n нечетно». Сначала можно записать: \textit{n = 2q + г}, деление с
остатком \textit{n} на 2; \textit{q} --- это неполное частное, а \textit{r} --- остаток. Когда \textit{n}
и \textit{p} --- целые числа удобно обозначить через n/р неполное частное  от 
деления с остатком \textit{n} на \textit{p} и через \textit{n mod p} --- остаток при этом делении; 
учитывая вышесказанное,  получаем: \textit{n = 2(n/2) + т mod 2}. Кроме того, 
значение \textit{n mod 2} выражает четность \textit{n}. Исходное  утверждение  может 
быть преобразовано в
\begin{equation*}
[C\times x^{2(n/2)+n\text{ }mod 2} = x_{0}^{n_{0}} \text{ и } n > 0].       \eqno(2)         
	\end{equation*}
Теперь рассмотрим две ветви альтернативы. Если \textit{n} нечетно, то \textit{n mod} 
2 равно 1 и исходное утверждение переписывается в виде: [$C \cdot x \cdot x^{2(n/2)}=$
$x_{0}^{n_0}$ и n > 0] --- выражение,  которое легко преобразуется  после приме­
нения  действия $C \leftarrow C \times x$ в
\begin{equation*}
[C \cdot x^{2(n/2)} = x_0^{n_0} \text{ и } n > 0].  \eqno(3)
\end{equation*}
Аналогичным образом, если \textit{n} четно, то 
\textit{n mod 2} равно 0 и без  всякого 
преобразования утверждение  (2)  становится тождественным  (3).

Итак, утверждение (1) преобразуется с помощью алгоритма в утвер­
ждение  (3)  при любом значении  предиката «n  нечетно».

В примере, рассмотренном выше, и в исследовании последовательно­
сти,  представленной в предыдущем  разделе,  мы  всегда начинали  дока­
зательство с преобразования исходного утверждения. Преобразование, 
которое может показаться  магическим  и  без  которого трудно  понять 
результат вычислений. В обычной практике алгоритмики все происхо­
дит  иначе;  действительно,  чрезвычайно  сложно,  если  вообще  возмож­
но, обосновать уже написанный алгоритм, и эта задача становится еще 
более сложной для  автора доказательства, если только он не автор ал­
горитма.  Чтобы  правильно составить  алгоритм,  нужно  сначала фор­
мально рассмотреть решаемую задачу, потом вывести несколько утвер­
ждений, описывающих основные этапы решения, и, наконец, построить 
одновременно алгоритм и его доказательство.
\pagebreak

Но,  разумеется,  приведенные  примеры  являются  всего  лишь  учеб­
ными.  Их  цель  —  разъяснить  аксиомы,  у  которых,  как  известно,  яс­
ность — не  главнейшее  достоинство!
\subsection{Итерация}
\noindent Существует много итеративных структур управления во всех языках 
программирования, а также во всех алгоритмических формализмах. 
На самом деле, все эти структуры образуются от одной и той же эле­
ментарной структуры управления: обобщенной итерации. Обобщенная 
итерация построена с помощью примитивов \textbf{loop},  \textbf{end loop} и \textbf{exit}. Два 
первых примитива \textbf{loop} и \textbf{end loop}  являются, соответственно, левой и 
правой скобками, ограничивающими действие или последовательность 
действий, которая должна повторяться, априори, бесконечно. Прими­
тив \textbf{exit} допускает выход из цикла, в котором он представлен; этот 
примитив  всегда  ассоциируется содним  или  несколькими  условиями 
выхода из цикла и часто появляется в алгоритмах в виде \textbf{exit when}.

\begin{wraptable}{i}{0.28\textwidth}
\begin{tabular}{|l|}
\textit{\begin{tabular}[c]{@{}l@{}}
while(true)\\ 
\{\\ 
\hspace*{0.5cm}Действие 1\\ 
\textbf{if}(Условие 1) \textbf{break};\\ 
\hspace*{0.5cm}Действие 2\\ 
\textbf{if}(Условие 2) \textbf{break};\\ 
\hspace*{1.5cm} .\\ 
\hspace*{1.5cm} .\\ 
\hspace*{1.5cm} .\\ 
\textbf{if}(Условие i) \textbf{break};\\ 
\hspace*{1.5cm} .\\ 
\hspace*{1.5cm} .\\ 
\hspace*{1.5cm} .\\ 
\textbf{if}(Условие n) \textbf{break};\\ 
\hspace*{0.5cm}Действие n+1\\ 
\}
\end{tabular}}\\ 
\end{tabular}%
\end{wraptable}
\noindent Справа представлена наиболее общая форма 
итерации. Эта запись достаточно ясна и не 
требует других объяснений.  На практике, что­
бы сохранить четкость алгоритмов (что озна­
чает также их понимание), мы ограничимся              
использованием  циклов,  имеющих,  самое  боль­
шее,  два  выхода.  Ни  теперь,  ни  в  дальнейшем, 
мы  не  дадим  самой  общей  аксиомы  (правиль­
нее  сказать  мета-аксиомы)  итерации;  понима­
ние нескольких частных случаев итераций, изу­
чаемых в следующих разделах,  позволяет легко 
ввести  любую  нужную  аксиому.

Любопытно отметить,  что  в  практическом  плане  концепции  алго­
ритмов альтернатива, определенная в предыдущем разделе, может быть 
представлена в виде обобщенной итерации  (теоретические  последствия 
см.  [25]).
\subsection{Итерация со счетчиком или цикл «для»}
\noindent Конечно,  это  самая  распространенная  форма  итерации.  Она использу­
ется, когда точно известно количество повторений действия, необходи-
\pagebreak

\begin{wraptable}{i}{0.5\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
\hspace{0.5cm} \underline{Итерация со счетчиком}\\ 
\textbf{for}(\textbf{int} i = p; i < q; i++)\\ 
\{\\ 
\hspace{0.5cm} Повторяющееся действие\\ 
\}
\end{tabular}}\\ 
\hline
\end{tabular}%
\vspace{-10pt}
\end{wraptable}
									\noindent мого для решения данной задачи. Схема 
									слева представляет сосчитанную итера­
									цию, в которой \textit{i} — это переменная, \textit{р} и 
									\textit{q} — выражения. Запись \textit{р..q} обозначает 
									интервал, у которого нижняя и  верхняя
границы — соответственно \textit{p} и \textit{q} (что приводит, в частности, к возмож­
ности обозначения пустого интервала). Результатом этой конструкции 
является повторение внутреннего действия цикла, называемого \textbf{телом}
\textbf{цикла}, для всех значений \textbf{индекса цикла i} в заданном интервале. Это 
построение обладает как преимуществами, так и некоторыми ограни­чениями:

\noindent $\bullet$ по своему применению переменная \textit{i} (индекс  цикла)  относится к 
командной  части  цикла  (это  семантика  индекса  цикла  в  языке 
Ада),
\newline
$\bullet$ следовательно,эта переменная существует и имеет определенное 
значение только в теле цикла и было бы  неправильно и бессмы­
сленно использовать ее предполаг аемое значение после выполне­
ния цикла.
\newline
\textbf{(4) Аксиома} (цикла «для»).
\newline
$\vartriangleright$ \textit{Посылки: А(i) --- действия, зависящие от значения i; P(i) --- условие,}
\textit{при котором i --- свободная переменная и вынолнено:}
\begin{equation*}
\textit{$[P(i - 1) и p \leqslant i \leqslant q] A(i) [P(i)]$}
\end{equation*}
$\vartriangleright$ \textit{Заключение:  \textit{[P(i - 1)]} \textbf{for} \textit{i} \textbf{in} \textit{p .. q} \textbf{loop} \textit{A(i)} \textbf{end loop}} \textit{[P(q)]}

Эта аксиома,  действительно,  выражает  в  алгоритмике  метод,  по­
добный принципу индукции в математике. Можно также выразить эту 
аксиому  в  слегка отличной форме,  изменив  индексацию  утверждений 
или действий... Все зависит от контекста и от ясности доказательства.

\begin{wraptable}{i}{0.28\textwidth}
\begin{tabular}{l|}
\textit{\begin{tabular}[c]{@{}l@{}}
i = p - 1;\\ 
\textbf{while}(\textbf{true})\\ 
\{\\ 
\hspace{0.1cm} \textbf{if}(i >= q) \textbf{break};\\ 
\hspace{0.1cm} i++;\\ 
\hspace{0.1cm} A(i);\\ 
\}\end{tabular}} \\ 
\end{tabular}%
\end{wraptable}
					\noindent Теоретически цикл «для» может быть реализо­
					ван с помощью обобщенной итерации, как в ал­
					горитме слева. Однако, на практике реализация 
						этим упрощенным методом цикла «для» с помо­
										щью компилятора не проводится.

\noindent Конструкция, представленная в последнем алгоритме, — это ите­
рация с выходом в начале цикла. Она так часто используется, что все 
языки программирования, достойные так называться, имеют особую 
структуру для ее выражения: цикл «пока».
\pagebreak
\subsection{Цикл «пока»}
\begin{wraptable}{}{0.28\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
\hspace{0.45cm} \underline{Цикл пока}\\
\textbf{while}(Условие)\\ 
\{\\ 
\hspace{0.25cm} Действие\\ 
\}
\end{tabular}} \\ 
\hline
\end{tabular}%
\end{wraptable}
\noindent Справа  дана  общая  форма  цикла  «пока»;  его 
действие заключается в следующем: проверяется 
условие, и, если оно верно, то действие, предста­
вленное в теле цикла, выполняется; затем снова 
проверяется предикат, и процесс повторяется до
тех пор, пока проверка условия не даст значение «ложно». Конечно, если 
предикат ложный с самого начала, никаких действий не производится: 
тело цикла не выполняется.
\newline
\textbf{(5) Аксиома} (цикла «пока»).
\newline
$\vartriangleright$ \textit{Посылки: А --- действие; P --- утверждение; C --- предикат;}
\begin{center}
\textit{[P и C] A [P]}
\end{center}
$\vartriangleright$ \textit{Заключение:  \textit{[P]} \textbf{while} \textit{C} \textbf{loop} \textit{A} \textbf{end loop} \textit{[P и (не C)]}}

Более точно, цикл «пока» является аббревиатурой более общего ци­
кла:
\begin{center}
\textbf{loop exit when not} \textit{C}; \text{  Действие;} \textbf{end loop} 
\end{center}
В аксиоме цикла «пока» заложен более общий принцип рассуждения, чем 
рекуррентность,  — индукция.  Из  сформулированной аксиомы можно 
сразу же сделать вывод, что любое свойство \textit{Р}, выполненное до входа 
в цикл и сохраняющееся при выполнении тела цикла, остается верным 
после окончания выполнения цикла. Такое утверждение \textit{Р} называется 
\textbf{инвариантом цикла.}

Кроме того, при выходе из цикла предикат \textit{C}, называемый \textbf{усло­-}
\textbf{вием  циклического  перехода},  — ложный.  Этот последний  фено­
мен необходимо рассмотреть более подробно, так как он затрагивает 
важный этап доказательства алгоритма. До сих пор все изученные ал­
горитмические конструкции были построениями, выполнение которых 
ограничивалось во времени: последовательность, альтернатива или ите­
рация со счетчиком заканчиваются за определенное время, если пред­
положить,  что составляющие  их действия  выполняются за конечный 
отрезок времени. Но это не относится ни к циклу «пока», ни к любой 
другой итерации, более общей, чем цикл «для». Эти последние струк­
туры управления потенциально бесконечны во времени, а на практике 
ограничены только проверкой условий выхода (когда они есть!).

Таким образом,  обоснование  алгоритма, в  котором представлены 
одна  или  несколько  итераций,  должно содержать  две  части:  доказаг 
тельство частичной корректности, цель которого— показать, что если
\pagebreak

\begin{wraptable}{i}{0.4\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
\hspace{0.5cm} \underline{Гипотеза Сиракуз}\\
\textbf{while}(n != 1)\\ 
\{\\ 
\hspace{0.25cm} \textbf{if}(n \textdiscount \text{ } 2 == 0) n=n/2;\\
\hspace{0.25cm} \textbf{else} n = (3*n + 1) / 2;\\ 
\}\\
\end{tabular}} \\ 
\hline
\end{tabular}%
\end{wraptable}
									\noindent алгоритм  завершен,  то  он  дает  ожидаемый 
									результат,  и  доказательство  выхода,  под­
									тверждающее,  что  всякое  выполнение  алго­
									ритма при любом наборе данных завершает­
									ся по истечении определенного времени. Эти 
									два этапа иногда очень отличаются по слож­
									ности;  наиболее  простой  пример,  известный 
									как \textit{гипотеза  Сиракуз},представлен  напро­
									тив. Доказательство  частичной  корректно­
сти  этого  алгоритма,  принимающего  целое  положительное  число \textit{n} в 
качестве  исходного данного,  является  простым:  если  он  завершен,  то 
он преобразует \textit{n} в  1; однако в настоящее время никто не может дока­
зать,  что он завершается  при любом  положительном значении \textit{n} (см., 
например, Терра  [169], Лагариа [108]  или Арзак  [7]).

Мы  не  будем  пока  приводить  примеры  алгоритмов   (и  доказа­
тельств),  использующих  итеративные  структуры.  Это  будет  сделано 
во время исследования первых получисленных алгоритмов.
\subsection{Итерация (продолжение и окончание)}
\begin{wraptable}{i}{0.3\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
\textbf{while}(\textbf{true})\\ 
\{\\ 
\hspace{0.4cm} Действие 1\\ 
\hspace{0.4cm} \textbf{if}(C) break;\\ 
\hspace{0.4cm} Действие 2\\ 
\}\\
\end{tabular}} \\ 
\hline
\end{tabular}%
\end{wraptable}
							\noindent Прежде,  чем  перейти  к  следующему  разделу,  в  ко­
							тором будет представлен дихотомический алгоритм 
							возведения в степень — один  из  основных алгорит­
							мов для алгебраических вычислений — и его реали­
							зация  на языке Ада, опишем третью особую форму 
							итерации и ее аксиоматику.  Основываясь на  этом,
читатель  сможет  обобщить  и  изобрести  аксиому,  адекватную  любой 
форме  итерации.  Эта  третья  форма  итерации  является  итерацией  с 
одним выходом, расположенным в середине цикла.

Вот, без объяснений (предыдущие параграфы в полной мере развили 
интуитивный  аспект  аксиом),  аксиома,  управляющая  действием  этой 
структуры.
\newline
\textbf{(6) Аксиома} (итерации).
\newline
$\vartriangleright$ \textit{Посылки: А и B --- действия; C --- предикат; P и Q --- утверждения;}
\begin{center}
\textit{[Q] A [P] и [P] и (не С)] B; A [P]}
\end{center}
$\vartriangleright$ \textit{Заключение:  \textit{[Q]} \textbf{loop} \textit{A} \textbf{exit when} \textit{C}; \textit{B} \textbf{end loop} \textit{[P и C]}}

\pagebreak
\section{Дихотомический алгоритм возведения в степень}
\noindent В настоящем разделе рассматривается дихотомический алгоритм воз­
ведения в степень. В общем виде он позволяет вычислить n-ю степень 
элемента в моноиде. Будучи применен к множеству целых чисел с опе­
рацией сложения, этот метод позволяет умножать два целых  числа и 
более известен как египетское умножение.

Рассматриваемый алгоритм — один из наиболее употребительных 
в  методах алгебраических вычислений.  В  самом деле,  наряду с  алго­
ритмами Евклида, возведение в степень является основой большинства 
арифметических  вычислений  в  конечных кольцах Z/pZ, в частности, 
для проверки простоты чисел Ферма и Мерсенна, нахождения квадра­
тичных вычетов и т.д.

Будут использованы два совершенно различных подхода для пред­
ставления этого алгоритма: алгоритмический подход, наиболее распро­
страненный  в курсах информатики,  и более классический,  математи­
ческий подход. Эти два подхода позволяют дать, с одной стороны, до­
казательство (корректности)  некоторого очень простого алгоритма, а 
с  другой  —  показать,  как  на основе явных математических  формул 
можно построить соответствующий вычислительный алгоритм. В ал­
горитмах, которые мы в дальнейшем представим, будут равным обра­
зом использованы оба эти подхода в зависимости от природы решаемой 
задачи.

Классический алгоритм возведения в степень посредством последо­
вательного умножения характерен,  главным образом, своей  неэффек­
тивностью в обычных обстоятельствах - его время работы линейным 
образом зависит  от  показателя  степени  (упражнение  28  показывает, 
что в более сложных случаях это не так).

Дихотомическое  возведение  в степень,  несмотря  на логарифмиче­
скую оценку сложности в зависимости от показателя степени, не явля­
ется наилучшим из всех известных методов (цепочки сложений иногда 
дают лучшие результаты, см. Кнут [99]), но оно, вне всякого сомнения, 
является самым простым из них. Основным его предположением явля­
ется то, что время вычисления операции умножения является констан­
той независимо от того, к каким элементам эта операция применяется. 
Если  же  это  не  так  (например,  в  кольце  полиномов),  то  существует 
много других простых и более эффективных  методов (см.,  в частно­
сти, упражнение 28).
\subsection{ Математический (или рекуррентный) подход}
Возьмем моноид \textit{M}\footnote{ Напомним, что моноид - это структура, состоящая из множества и определенно­
го на нем внутреннего ассоциативного закона композиции и содержащая нейтраль­
ный по отношению к этому закону элемент. Например, множество всех слов, которые
можно записать с  помощью букв фиксированного алфавита, наделено структурой
моноида, если добавить еще операцию конкатенации (заключающуюся в приписыва­
нии одного слова в конец другому), которая обладает свойством ассоциативности, и
пустое слово, которое является нейтральным элементом для этого закона; в резуль­
тате  получается  свободный  моноид  —  структура, имеющая  чрезвычайно  важное
значение в информатике} с операцией умножения и рассмотрим некоторый 
элемент $x_0$ из \textit{M}, а также произвольное натуральное число $n_{0}$. Для того, 
чтобы вычислить $x_{0}^{n_{0}}$, представим $n_{0}$ в двоичной системе счисления:
\begin{equation*}
n_{0} = b_{t}2^{t} + b_{t - 1}2^{t - 1} + ... + b_{1}2^{1} + b_{0}2^{0},
\end{equation*}
предполагая, что $n_{0}$ содержит \textit{$(t + 1)$} двоичных цифр (т.е. что $b_{t}$ $\neq$ 0 и  \linebreak
$b_{t + 1}$ = 0). В этих условиях вычисляемое выражение может быть запи­сано:
\begin{equation*}
x_{0}^{n_{0}} = \prod_{i=0}^t x^{b_{i}2^{i}} \text{  или же  } x_{0}^{n_{0}} = \prod_{i=0}^t x^{2^{i}}.
\end{equation*}
\newline

Если задана последовательность: $(x_{i})_{0 \leqslant i \leqslant t}$, первый  элемент  которой 
\newline
есть $x_{o}$, и $x_{i}$ для \textit{$i \in [1,t]$} определено соотношением \textit{$x_{i} = x_{i-1}^2$}, то можно\linebreak
записать $x_{0}^{n_{0}} = \prod \{ x_{i} | 0 \leqslant i \leqslant t, b_{t} \neq 0\}$.Чтобы завершить построе-\linebreak
ние алгоритма и иметь возможность получить значение предыдущего\linebreak
произведения, необходимо вычислить биты $b_{i}$,- числа $n_{0}$.

Читатель легко сможет проверить для последовательности

\begin{wraptable}{i}{0.35\textwidth}
\begin{tabular}{l|}
\textit{\begin{tabular}[c]{@{}l@{}}
P = 1;\\ 
i = 0;\\ 
while(n[i] != 0)\\ 
\{\\ 
\hspace{0.2cm} \textbf{if}(n[i] $\textdiscount$ 2 != 0)\\
\hspace{0.2cm} \{\\
\hspace{0.3cm} P = P * x[i];\} \\ 
\hspace{0.3cm} n[i + 1] = n[i] / 2;\\ 
\hspace{0.3cm} x[i + 1] = x[i] * x[i];\\ 
\hspace{0.3cm} i++;\\ 
\hspace{0.2cm} \}\\
\}\\ 
\hspace{0.2cm} \textbf{return} P;\\
\end{tabular}} \\ 
\end{tabular}%
\end{wraptable}
\noindent $(n_{i})_{0 \leqslant i \leqslant t}$ (c начальным элементом $n_{0}$, опре-\linebreak
деленной соотношением $n_{i} = [n_{i-1} / 2]$ для \linebreak
любого \textit{$i \in [1,t + 1]$}, что бит $b_{i}$ равен ну-\linebreak
лю, если $n_{i}$ четно, и равен единице в против­-\linebreak
ном случае и что первое значение индекса \textit{i} \linebreak
для которого \textit{$n_{i}$},- равно нулю, есть \textit{t + 1}. Пре­-\linebreak
дыдущее рассуждение позволяет представить\linebreak
«математическую» версию дихотомического\linebreak
алгоритма возведения в степень с исходными\linebreak
данными $x_{0}$ (элемент моноида М) и $n_{0}$ (неко­-\linebreak
торое натуральное число) и результатом \textit{$P = x_{0}^{n_{0}}$}.
\newline

Этот алгоритм представляет собой простой синтез предыдущих вы­
числений, представленный в алгоритмической форме вместо того, что­
бы быть выраженным с помощью лемм, свойств и т.п. Заметим, что в процессе построения алгоритма появляется
\pagebreak

\noindent переменная $x_{t+1}$, которая
не встречается в последовательности $x_{i}$. В последующих алгоритмах
будем избегать бесполезного вычисления этого значения. Естественно,
что предложенный алгоритм не очень удобен для использования в той
форме, в какой он изложен. В частности, в нем присутствуют пере­
менные с индексами — объекты, которые программисты используют в
своих программах очень неохотно и при крайней необходимости.
Тем не менее, на базе этого псевдо-алгоритма нетрудно построить

\begin{wraptable}{}{0.35\textwidth}
\vspace{-10pt}
\begin{tabular}{l}
\hline
\multicolumn{1}{|l|}{\textit{\textbf{\begin{tabular}[c]{@{}l@{}}
x = x\_{0};\\ 
n = n\_{0};\\ 
P = 1; \\ 
while(n!=0)\\
\{\\
\hspace{0.4pt} if(n$\textdiscount$2!=0) P = P * x;\\ 
\hspace{0.4pt} n = (n/2);\\ 
\hspace{0.4pt} x = x * x;\\ 
\}\\ 
return P;
\end{tabular}}}} \\ \hline
\hspace{20pt} Алгоритм 1.                                                                                                                                                                                                        
\end{tabular}
\vspace{-12pt}
\end{wraptable}
\noindent настоящий. Для этого достаточно опти­
мизировать использование входящих в
него переменных. Каждая переменная \textit{$х_{i}$}-
появляется только два раза: первый раз,
когда определяется ее значение, а второй
— в вычислении, использующем это зна­
чение. Следовательно, все вхождения пе­
ременных \textit{$х_{i}$}, можно заменить на вхожде­
ния одной единственной переменной \textit{$х$}.

Совершенно аналогична процедура для переменных \textit{$n_{i}$} (заменяемых од­
ной переменной \textit{$n$}), что делает ненужной переменную \textit{$i$}. Здесь приведена
эффективная версия (Алгоритм 1) дихотомического алгоритма возве­
дения в степень. Благодаря использованному методу построения, не
требуется никакого доказательства его корректности.

Достаточна лишь проверка последней приведенной записи. Далее мы
дадим окончательную версию алгоритма, которая несколько отличает­
ся от приведенной здесь, главным образом, возможностью обнаружения
ошибок и надежностью алгоритма.

Рассмотрим теперь другой подход, позволяющий конструировать
алгоритмы, — алгоритмический подход. Этот метод концептуально
сильно отличается от предыдущего, но не более и не менее совершенен.
В зависимости от условий тот или иной будет использоваться с большей
или меньшей легкостью.
\subsection{ Алгоритмический подход}
\noindent Этот подход основан на следующем замечании: для натурального чиcла \textit{n}
\begin{equation*}
 x^n = 
 \begin{cases}
   (x^{2})^{n/2}, \text{ если n четно}
   \\
   x(x^{2})^{n/2}, \text{ если n нечетно}
   \\
 \end{cases}
\end{equation*}

\pagebreak
\begin{wraptable}{}{0.6\textwidth}
\begin{tabular}{|l|}
\hline
\textit{\begin{tabular}[c]{@{}l@{}}
\textbf{if}(n == 0) return 1;\\ 
\textbf{else if} (n \textdiscount 2 == 0) \\ 
\{\textbf{return} Exponentiation(x * x, n / 2);\}\\ 
\textbf{else if} (n \textdiscount 2 == 1) \\ 
\{\textbf{return} x * Exponentiation(x * x, n / 2);\}
\end{tabular}} \\ 
\hline
\end{tabular}%
\vspace{-12pt}
\end{wraptable}
\noindent Он приводит к алгоритмам
двух типов. Первый, получа­
емый без вычислений из вы­
шеприведенного определения,
является рекурсивным алго­
ритмом и не требует никакого
обоснования, поскольку он —
результат непосредственного
применения безупречного определения.

Второй является итеративным алгоритмом, который требует дока­
зательства. Рекурсивный алгоритм по очевидным причинам записан в
виде функции \textit{Exponentiation} (см. предыдущий рисунок).

В этом алгоритме рекурсивные вызовы имеют место во время опре­
деления возвращаемого значения функции и в точности соответствуют
индуктивному определению, приведенному в начале раздела.

В более общем алгоритме использование этой функции осуществля­
лось бы операцией типа: \textit{$Resultat$} $\leftarrow$ \textit{$Exponentiation(xo,no)$}.
\newline
\begin{center}
\parbox{11cm}
{
\textbf{Замечание.} Определение возведения в степень может быть дано
также в следующем виде:
\begin{equation*}
x^{n} = (x^{ \frac{n}{2} }) ^ {2} \text{, если n четно, } x^{n} = (x^{ \frac{n-1}{2} }) ^ {2}  \text{, если n нечетно, }
\end{equation*}
который позволяет построить рекурсивный алгоритм, слегка от­
личающийся от предыдущего. Однако эта последняя формулиров­
ка несколько хуже подходит для конструирования итеративного
алгоритма, чем исходная. В качестве упражнения читатель мо­
жет попробовать записать соответствующий алгоритм.
}
\end{center}
Главная идея, на которой основывается построение итеративного
алгоритма, представляет собой другую интерпретацию определения,
приведенного в начале этого раздела:

\parindent=1.2cm $\bullet$ \text{ чтобы вычислить } \textit{$x^{n}$}, \text{где  } \textit{$n$} \text{ положительно, достаточно возвести }

\parindent=1.2cm  \textit{$x$} в квадрат и возвести полученный результат в степень \textit{$n/2$}, до-

\parindent=1.2cm множая поправочный множитель на \textit{x}, если \textit{n} нечетно;

\parindent=1.2cm $\bullet$ \text{ кроме того, когда } \textit{n} \text{ принимает значение 0, искомый результат }

\parindent=1.2cm должен быть равен поправочному множителю, что и дает началь­

\parindent=1.2cm ное значение поправочного множителя.

\noindent Таким образом, алгоритм состоит в вычислении поправочного множи­
теля так, чтобы произведение текущего значения \textit{$х^{n}$} и поправочного
множителя было все время равно искомому результату \textit{$x_{0}^{n_{0}}$}, где \textit{$x_{0}$} и по
являются начальными значениями \textit{$x$} и \textit{$n$} соответственно. Итак, инвари­
антным соотношением алгоритма будет \textit{$c \times x^{n} = x_0^{n_0}$}.
\pagebreak

Предыдущие замечания приводят нас к искомому итеративному ал­
горитму (рис. 2-А), вполне аналогичному тому алгоритму, который был 
получен  в  результате  рекуррентного  подхода к  решению  проблемы.  В 
этом  алгоритме до  и  после  каждого шага рассматриваются соотноше­
ния,  которые  позволяют  доказать  справедливость  метода.  Проверка 
корректности  этих  утверждений  становится  детской  игрой  для  того, 
кто понял смысл обозначений.  Чтобы облегчить чтение,  обозначим пе­
ременную,  которая позволяет вычислять 
\textit{поправку}, буквой  с.

В  реальной  программе  или  же  алгоритме,  в  котором,  возможно, 
представлены  не  все  утверждения,  использовалось бы,  разумеется,  бо­
лее  выразительное имя.

Всюду  в дальнейшем входящие в алгоритмы утверждения  будут за­
тушеваны,  как  на  рис.  2,  для  того,  чтобы  отличать  утверждения  от 
действий,  совершаемых  алгоритмом.

Документирование  алгоритма  посредством  утверждений  доказы­
вает  его  частичную  корректность.  Остается  показать,  что  алгоритм 
останавливается  при любых данных,  поданных на вход, только бы они 
соответствовали спецификациям.

Общим  принципом  доказательства  остановки  алгоритма  является 
введение  некоторой положительной величины,  которая строго убывает 
с  каждой  итерацией,  — величины,  которую  можно  назвать 
\textit{длиной}  ал­горитма  (или  же \textit{расстоянием}
  до  точки  окончания).  В  этом  частном 
случае  такая  работа  чрезвычайно  проста,  ибо  длина  алгоритма изме­
ряется  на самом деле самим же  целым числом 
п.
  Это целое  число поло­
жительно, строго убывает с каждой итерацией — оно делится  каждый 
раз  пополам — и, следовательно,  через  конечный отрезок времени ста­
новится  нулем,  делая тем самым условие возобновления цикла ложным, 
и  алгоритм останавливается за конечное  время.

Внимательное  изучение  последнего  алгоритма показывает,  что да­
же если с теоретической или алгоритмической точки зрения он коррек­
тен, в процессе его буквальной реализации  могут появиться определен­
ные  проблемы.  Некоторые  вычисления  могут  оказаться  бесполезными 
и даже опасными: так,  возведение \textit{х}
  в квадрат может вызвать перепол­
нение  во  время  выполнения  последней  итерации,  даже  если  искомый 
результат  вполне  вычислим.

Аналогичным образом, описанный алгоритм не способен  корректно 
вычислить  результат,  когда показатель отрицательный  или  не являет­
ся  целым  числом.  Проверка природы целого числа 
по
  обычно является 
функцией  среды  реализации  языка.  И  хотя  можно  снова опираться  на 
язык, если речь идет о языке Ада, будет удобнее, по крайней мере в экс­
периментальной версии, приступить самому к проверкам первого типа.
%\end{document} 